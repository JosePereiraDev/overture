/*******************************************************************************
* Copyright (c) 2009, 2011 Overture Team and others.
*
* Overture is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Overture is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Overture.  If not, see <http://www.gnu.org/licenses/>.
*
* The Overture Tool web-site: http://overturetool.org/
*******************************************************************************/

/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overture.ast.analysis;


import org.overture.ast.intf.lex.ILexIdentifierToken;
import org.overture.ast.modules.AOperationValueImport;
import org.overture.ast.expressions.ACasesExp;
import org.overture.ast.expressions.AUnaryPlusUnaryExp;
import org.overture.ast.expressions.ALetDefExp;
import org.overture.ast.expressions.PModifier;
import org.overture.ast.definitions.ARenamedDefinition;
import org.overture.ast.statements.AAssignmentStm;
import org.overture.ast.statements.AFieldObjectDesignator;
import org.overture.ast.expressions.AIsOfBaseClassExp;
import java.lang.Integer;
import org.overture.ast.definitions.AInstanceVariableDefinition;
import org.overture.ast.expressions.AUndefinedExp;
import org.overture.ast.expressions.ASubtractNumericBinaryExp;
import org.overture.ast.patterns.PPattern;
import org.overture.ast.definitions.PAccess;
import org.overture.ast.definitions.traces.PTraceCoreDefinition;
import java.lang.Long;
import org.overture.ast.expressions.ALetBeStExp;
import org.overture.ast.expressions.AIotaExp;
import org.overture.ast.expressions.AElementsUnaryExp;
import org.overture.ast.types.ASetType;
import org.overture.ast.definitions.ATypeDefinition;
import org.overture.ast.statements.PStmtAlternative;
import org.overture.ast.analysis.intf.IQuestion;
import org.overture.ast.types.SBasicType;
import org.overture.ast.expressions.SBinaryExp;
import org.overture.ast.definitions.traces.AConcurrentExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AMapInverseUnaryExp;
import org.overture.ast.expressions.AMapUnionBinaryExp;
import org.overture.ast.types.AUnresolvedType;
import org.overture.ast.types.ARealNumericBasicType;
import org.overture.ast.patterns.AObjectPattern;
import org.overture.ast.statements.ACyclesStm;
import org.overture.ast.expressions.AExists1Exp;
import org.overture.ast.expressions.ATupleExp;
import org.overture.ast.patterns.AIntegerPattern;
import org.overture.ast.node.tokens.TStatic;
import org.overture.ast.expressions.ABooleanConstExp;
import org.overture.ast.patterns.ATypeBind;
import org.overture.ast.expressions.SMapExp;
import org.overture.ast.expressions.PExp;
import org.overture.ast.statements.ANonDeterministicSimpleBlockStm;
import org.overture.ast.expressions.AAbsoluteUnaryExp;
import org.overture.ast.statements.AApplyObjectDesignator;
import org.overture.ast.expressions.AIsExp;
import org.overture.ast.types.AOptionalType;
import org.overture.ast.types.AUnionType;
import org.overture.ast.definitions.APrivateAccess;
import org.overture.ast.definitions.traces.ALetBeStBindingTraceDefinition;
import org.overture.ast.modules.PModules;
import org.overture.ast.definitions.AImplicitFunctionDefinition;
import org.overture.ast.types.AVoidType;
import org.overture.ast.patterns.ATuplePattern;
import org.overture.ast.statements.ACallStm;
import org.overture.ast.statements.ASelfObjectDesignator;
import org.overture.ast.typechecker.ClassDefinitionSettings;
import org.overture.ast.statements.AFieldStateDesignator;
import org.overture.ast.types.AVoidReturnType;
import org.overture.ast.patterns.AStringPattern;
import org.overture.ast.definitions.APublicAccess;
import org.overture.ast.expressions.ADomainResByBinaryExp;
import org.overture.ast.patterns.AMapletPatternMaplet;
import org.overture.ast.expressions.ACardinalityUnaryExp;
import org.overture.ast.types.ABooleanBasicType;
import org.overture.ast.definitions.traces.AInstanceTraceDefinition;
import org.overture.ast.statements.ASubclassResponsibilityStm;
import org.overture.ast.expressions.SSeqExp;
import org.overture.ast.expressions.ASetEnumSetExp;
import org.overture.ast.patterns.PMultipleBind;
import org.overture.ast.expressions.ADefExp;
import org.overture.ast.types.AFunctionType;
import org.overture.ast.expressions.AProperSubsetBinaryExp;
import org.overture.ast.types.AUnknownType;
import org.overture.ast.modules.AModuleExports;
import org.overture.ast.expressions.ATimeExp;
import org.overture.ast.definitions.traces.AApplyExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AImpliesBooleanBinaryExp;
import org.overture.ast.statements.ACaseAlternativeStm;
import org.overture.ast.patterns.ANamePatternPair;
import org.overture.ast.definitions.AStateDefinition;
import org.overture.ast.patterns.ASetBind;
import org.overture.ast.types.SSeqType;
import org.overture.ast.statements.AForAllStm;
import org.overture.ast.expressions.AGreaterNumericBinaryExp;
import org.overture.ast.expressions.ASetCompSetExp;
import org.overture.ast.patterns.AUnionPattern;
import org.overture.ast.expressions.AHeadUnaryExp;
import org.overture.ast.types.AUndefinedType;
import org.overture.ast.expressions.AFieldExp;
import org.overture.ast.patterns.ARealPattern;
import org.overture.ast.definitions.APerSyncDefinition;
import org.overture.ast.definitions.ABusClassDefinition;
import org.overture.ast.analysis.intf.IAnalysis;
import org.overture.ast.statements.ACasesStm;
import org.overture.ast.node.IToken;
import org.overture.ast.expressions.AMapRangeUnaryExp;
import org.overture.ast.statements.AIdentifierStateDesignator;
import org.overture.ast.intf.lex.ILexToken;
import org.overture.ast.expressions.AFloorUnaryExp;
import org.overture.ast.definitions.AExplicitOperationDefinition;
import org.overture.ast.statements.AMapSeqStateDesignator;
import org.overture.ast.patterns.APatternListTypePair;
import org.overture.ast.patterns.AMapPattern;
import org.overture.ast.expressions.ASubsetBinaryExp;
import org.overture.ast.statements.AReturnStm;
import org.overture.ast.modules.SValueImport;
import org.overture.ast.expressions.AStarStarBinaryExp;
import org.overture.ast.types.PAccessSpecifier;
import org.overture.ast.modules.AFunctionValueImport;
import org.overture.ast.statements.AElseIfStm;
import org.overture.ast.modules.AOperationExport;
import org.overture.ast.types.ANatOneNumericBasicType;
import org.overture.ast.expressions.SBooleanBinaryExp;
import org.overture.ast.intf.lex.ILexStringToken;
import org.overture.ast.expressions.ADistIntersectUnaryExp;
import org.overture.ast.statements.SSimpleBlockStm;
import org.overture.ast.patterns.ARecordPattern;
import org.overture.ast.expressions.APlusNumericBinaryExp;
import org.overture.ast.modules.AValueValueImport;
import org.overture.ast.types.ANamedInvariantType;
import org.overture.ast.expressions.ACaseAlternative;
import org.overture.ast.types.ARecordInvariantType;
import org.overture.ast.types.ASeqSeqType;
import org.overture.ast.patterns.PMaplet;
import org.overture.ast.expressions.ASameClassExp;
import org.overture.ast.expressions.ASetIntersectBinaryExp;
import org.overture.ast.patterns.ABooleanPattern;
import org.overture.ast.expressions.AForAllExp;
import org.overture.ast.definitions.traces.ATraceDefinitionTerm;
import org.overture.ast.expressions.ASelfExp;
import org.overture.ast.statements.AForPatternBindStm;
import org.overture.ast.modules.PImports;
import org.overture.ast.statements.PObjectDesignator;
import org.overture.ast.expressions.ASubseqExp;
import org.overture.ast.types.AMapMapType;
import org.overture.ast.statements.ACallObjectStm;
import org.overture.ast.expressions.SNumericBinaryExp;
import org.overture.ast.definitions.PDefinition;
import org.overture.ast.expressions.ASeqConcatBinaryExp;
import org.overture.ast.statements.AAlwaysStm;
import org.overture.ast.expressions.APostOpExp;
import org.overture.ast.statements.PClause;
import org.overture.ast.types.ASeq1SeqType;
import org.overture.ast.definitions.ANamedTraceDefinition;
import org.overture.ast.expressions.ALessEqualNumericBinaryExp;
import org.overture.ast.statements.AAtomicStm;
import org.overture.ast.expressions.ARangeResToBinaryExp;
import org.overture.ast.expressions.ASetRangeSetExp;
import org.overture.ast.statements.ABlockSimpleBlockStm;
import org.overture.ast.definitions.SClassDefinition;
import org.overture.ast.types.ARationalNumericBasicType;
import org.overture.ast.statements.ATixeStmtAlternative;
import org.overture.ast.expressions.AFuncInstatiationExp;
import org.overture.ast.types.AProductType;
import org.overture.ast.statements.PCase;
import org.overture.ast.typechecker.Pass;
import org.overture.ast.expressions.AGreaterEqualNumericBinaryExp;
import org.overture.ast.types.AAccessSpecifierAccessSpecifier;
import org.overture.ast.statements.AExternalClause;
import java.lang.Boolean;
import java.util.LinkedList;
import org.overture.ast.definitions.AValueDefinition;
import org.overture.ast.definitions.traces.ABracketedExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AExistsExp;
import org.overture.ast.expressions.AThreadIdExp;
import org.overture.ast.expressions.ACompBinaryExp;
import org.overture.ast.expressions.ARealLiteralExp;
import org.overture.ast.statements.ATixeStm;
import org.overture.ast.definitions.traces.PTerm;
import org.overture.ast.intf.lex.ILexQuoteToken;
import org.overture.ast.expressions.ANotEqualBinaryExp;
import org.overture.ast.expressions.AElseIfExp;
import org.overture.ast.expressions.ASameBaseClassExp;
import org.overture.ast.types.PField;
import org.overture.ast.expressions.APowerSetUnaryExp;
import org.overture.ast.types.PType;
import org.overture.ast.patterns.AIgnorePattern;
import org.overture.ast.statements.AWhileStm;
import org.overture.ast.statements.AIfStm;
import org.overture.ast.statements.APeriodicStm;
import org.overture.ast.patterns.AMapUnionPattern;
import org.overture.ast.statements.ALetBeStStm;
import org.overture.ast.modules.AModuleImports;
import org.overture.ast.expressions.AIntLiteralExp;
import org.overture.ast.expressions.ATimesNumericBinaryExp;
import org.overture.ast.expressions.AMapEnumMapExp;
import org.overture.ast.expressions.AIfExp;
import org.overture.ast.patterns.ADefPatternBind;
import org.overture.ast.statements.ANewObjectDesignator;
import org.overture.ast.statements.AStartStm;
import org.overture.ast.statements.ANotYetSpecifiedStm;
import org.overture.ast.statements.AClassInvariantStm;
import org.overture.ast.expressions.AMkBasicExp;
import org.overture.ast.expressions.APreOpExp;
import org.overture.ast.modules.PExport;
import org.overture.ast.modules.ATypeExport;
import org.overture.ast.expressions.ADistMergeUnaryExp;
import org.overture.ast.definitions.AMutexSyncDefinition;
import org.overture.ast.definitions.SFunctionDefinition;
import org.overture.ast.definitions.AInheritedDefinition;
import java.util.Set;
import org.overture.ast.modules.AFunctionExport;
import org.overture.ast.patterns.AConcatenationPattern;
import org.overture.ast.expressions.ALenUnaryExp;
import org.overture.ast.expressions.AApplyExp;
import org.overture.ast.expressions.AFieldNumberExp;
import org.overture.ast.patterns.ASetMultipleBind;
import org.overture.ast.modules.AAllImport;
import org.overture.ast.modules.PExports;
import org.overture.ast.expressions.ANewExp;
import org.overture.ast.definitions.AMultiBindListDefinition;
import org.overture.ast.expressions.ADivideNumericBinaryExp;
import org.overture.ast.expressions.AVariableExp;
import org.overture.ast.expressions.ADomainResToBinaryExp;
import org.overture.ast.statements.ADurationStm;
import org.overture.ast.expressions.ASubclassResponsibilityExp;
import org.overture.ast.definitions.AUntypedDefinition;
import org.overture.ast.expressions.ASetDifferenceBinaryExp;
import org.overture.ast.expressions.AIsOfClassExp;
import org.overture.ast.expressions.ADivNumericBinaryExp;
import org.overture.ast.definitions.AImplicitOperationDefinition;
import org.overture.ast.patterns.AExpressionPattern;
import org.overture.ast.intf.lex.ILexIntegerToken;
import java.util.ArrayList;
import org.overture.ast.types.AFieldField;
import org.overture.ast.types.ATokenBasicType;
import org.overture.ast.expressions.AModNumericBinaryExp;
import java.lang.String;
import org.overture.ast.expressions.ANilExp;
import org.overture.ast.definitions.AClassClassDefinition;
import org.overture.ast.node.tokens.TAsync;
import org.overture.ast.expressions.ARangeResByBinaryExp;
import org.overture.ast.types.ABracketType;
import org.overture.ast.statements.AStopStm;
import org.overture.ast.expressions.ASeqCompSeqExp;
import org.overture.ast.expressions.AOrBooleanBinaryExp;
import org.overture.ast.definitions.AClassInvariantDefinition;
import org.overture.ast.expressions.AMkTypeExp;
import org.overture.ast.statements.AIdentifierObjectDesignator;
import org.overture.ast.expressions.AMapletExp;
import org.overture.ast.expressions.APreExp;
import org.overture.ast.expressions.AMapDomainUnaryExp;
import org.overture.ast.types.AInMapMapType;
import org.overture.ast.expressions.ASeqEnumSeqExp;
import org.overture.ast.definitions.ASystemClassDefinition;
import org.overture.ast.intf.lex.ILexLocation;
import org.overture.ast.expressions.AAndBooleanBinaryExp;
import org.overture.ast.types.AQuoteType;
import org.overture.ast.expressions.AQuoteLiteralExp;
import org.overture.ast.statements.AErrorStm;
import org.overture.ast.expressions.SSetExp;
import org.overture.ast.patterns.PBind;
import org.overture.ast.types.AOperationType;
import org.overture.ast.util.ClonableString;
import org.overture.ast.util.ClonableFile;
import org.overture.ast.expressions.ADistConcatUnaryExp;
import org.overture.ast.expressions.ANotInSetBinaryExp;
import org.overture.ast.types.SInvariantType;
import org.overture.ast.expressions.APlusPlusBinaryExp;
import org.overture.ast.expressions.AEquivalentBooleanBinaryExp;
import org.overture.ast.definitions.ALocalDefinition;
import org.overture.ast.modules.AAllExport;
import org.overture.ast.expressions.AIndicesUnaryExp;
import org.overture.ast.types.AIntNumericBasicType;
import org.overture.ast.definitions.AThreadDefinition;
import org.overture.ast.intf.lex.ILexNameToken;
import org.overture.ast.statements.ALetStm;
import org.overture.ast.types.AParameterType;
import org.overture.ast.node.INode;
import org.overture.ast.patterns.PPair;
import org.overture.ast.statements.ASporadicStm;
import org.overture.ast.statements.ATrapStm;
import org.overture.ast.intf.lex.ILexRealToken;
import org.overture.ast.definitions.ACpuClassDefinition;
import org.overture.ast.statements.AForIndexStm;
import org.overture.ast.patterns.ASeqPattern;
import org.overture.ast.modules.ATypeImport;
import org.overture.ast.types.SMapType;
import org.overture.ast.patterns.ATypeMultipleBind;
import org.overture.ast.definitions.AAssignmentDefinition;
import org.overture.ast.definitions.AImportedDefinition;
import org.overture.ast.intf.lex.ILexBooleanToken;
import org.overture.ast.expressions.ACharLiteralExp;
import org.overture.ast.expressions.ANarrowExp;
import org.overture.ast.analysis.AnalysisException;
import java.util.List;
import org.overture.ast.expressions.ANotUnaryExp;
import org.overture.ast.definitions.AProtectedAccess;
import org.overture.ast.definitions.SOperationDefinition;
import org.overture.ast.typechecker.NameScope;
import org.overture.ast.definitions.AExternalDefinition;
import org.overture.ast.expressions.AMuExp;
import org.overture.ast.expressions.SUnaryExp;
import org.overture.ast.expressions.AUnaryMinusUnaryExp;
import org.overture.ast.types.AClassType;
import org.overture.ast.statements.AExitStm;
import org.overture.ast.expressions.AReverseUnaryExp;
import org.overture.ast.statements.PStm;
import org.overture.ast.expressions.ASetUnionBinaryExp;
import org.overture.ast.expressions.ALambdaExp;
import org.overture.ast.modules.PImport;
import org.overture.ast.types.ANatNumericBasicType;
import org.overture.ast.definitions.traces.ARepeatTraceDefinition;
import org.overture.ast.expressions.ARemNumericBinaryExp;
import org.overture.ast.patterns.AIdentifierPattern;
import org.overture.ast.expressions.AHistoryExp;
import org.overture.ast.expressions.ALessNumericBinaryExp;
import org.overture.ast.patterns.ACharacterPattern;
import org.overture.ast.expressions.AStringLiteralExp;
import org.overture.ast.expressions.AEqualsBinaryExp;
import org.overture.ast.expressions.AMapCompMapExp;
import org.overture.ast.intf.lex.ILexCharacterToken;
import org.overture.ast.expressions.ATailUnaryExp;
import org.overture.ast.statements.ASkipStm;
import org.overture.ast.patterns.AQuotePattern;
import org.overture.ast.statements.PStateDesignator;
import org.overture.ast.statements.ASpecificationStm;
import org.overture.ast.expressions.ANotYetSpecifiedExp;
import org.overture.ast.definitions.traces.PTraceDefinition;
import org.overture.ast.modules.AModuleModules;
import org.overture.ast.types.SNumericBasicType;
import org.overture.ast.patterns.ASetPattern;
import org.overture.ast.definitions.AEqualsDefinition;
import org.overture.ast.types.ACharBasicType;
import org.overture.ast.modules.AFromModuleImports;
import org.overture.ast.statements.PAlternativeStm;
import org.overture.ast.definitions.traces.ALetDefBindingTraceDefinition;
import org.overture.ast.expressions.ADistUnionUnaryExp;
import org.overture.ast.expressions.AStateInitExp;
import org.overture.ast.patterns.ANilPattern;
import org.overture.ast.modules.AValueExport;
import org.overture.ast.expressions.ARecordModifier;
import org.overture.ast.expressions.AInSetBinaryExp;
import org.overture.ast.patterns.PPatternBind;
import org.overture.ast.statements.AErrorCase;
import org.overture.ast.definitions.AExplicitFunctionDefinition;
import org.overture.ast.patterns.APatternTypePair;
import org.overture.ast.expressions.PAlternative;


/**
* Generated file by AST Creator
* @author Kenneth Lausdahl
*
*/
@SuppressWarnings({"all"})
public abstract class DepthFirstAnalysisAdaptorQuestion<Q> implements IQuestion<Q>
{
	private static final long serialVersionUID = 1L;

	protected Set<INode> _visitedNodes = new java.util.HashSet<INode>();
	final protected IQuestion<Q> THIS;

	/**
	* Creates a new {@code DepthFirstAnalysisAdaptorQuestion} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param visitedNodes_ the {@link Set} node for the {@code visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestion} node
	* @param THIS_ the {@link IQuestion} <b>graph</a> node for the {@code THIS} child of this {@link DepthFirstAnalysisAdaptorQuestion} node.
	*  <i>The parent of this {@code THIS } will not be changed by adding it to this node.</i>
	*/
	public DepthFirstAnalysisAdaptorQuestion(Set<INode> visitedNodes_, IQuestion<Q> THIS_)
	{
		super();
		this.setVisitedNodes(visitedNodes_);
		this.THIS = THIS_;

	}


	/**
	 * Creates a new {@link DepthFirstAnalysisAdaptorQuestion} node with no children.
	 */
	public DepthFirstAnalysisAdaptorQuestion()
	{
		this.THIS=this;

	}


	/**
	 * Sets the {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestion} node.
	 * @param value the new {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestion} node
	*/
	public void setVisitedNodes(Set<INode> value)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexToken(ILexToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexToken(node, question);


		outILexToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexToken(ILexToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexToken(ILexToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexNameToken(node, question);


		outILexNameToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexIdentifierToken(node, question);


		outILexIdentifierToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexBooleanToken(node, question);


		outILexBooleanToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexCharacterToken(node, question);


		outILexCharacterToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexIntegerToken(node, question);


		outILexIntegerToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexQuoteToken(node, question);


		outILexQuoteToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexRealToken(node, question);


		outILexRealToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexStringToken(node, question);


		outILexStringToken(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexLocation(ILexLocation node, Q question) throws AnalysisException
	{
		inILexLocation(node, question);


		outILexLocation(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexLocation(ILexLocation node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexLocation(ILexLocation node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClonableFile(ClonableFile node, Q question) throws AnalysisException
	{
		inClonableFile(node, question);


		outClonableFile(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClonableFile(ClonableFile node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClonableFile(ClonableFile node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClonableString(ClonableString node, Q question) throws AnalysisException
	{
		inClonableString(node, question);


		outClonableString(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClonableString(ClonableString node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClonableString(ClonableString node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{
		inClassDefinitionSettings(node, question);


		outClassDefinitionSettings(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseNameScope(NameScope node, Q question) throws AnalysisException
	{
		inNameScope(node, question);


		outNameScope(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inNameScope(NameScope node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outNameScope(NameScope node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void casePass(Pass node, Q question) throws AnalysisException
	{
		inPass(node, question);


		outPass(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inPass(Pass node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outPass(Pass node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseBoolean(Boolean node, Q question) throws AnalysisException
	{
		inBoolean(node, question);


		outBoolean(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inBoolean(Boolean node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outBoolean(Boolean node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseInteger(Integer node, Q question) throws AnalysisException
	{
		inInteger(node, question);


		outInteger(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inInteger(Integer node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outInteger(Integer node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseString(String node, Q question) throws AnalysisException
	{
		inString(node, question);


		outString(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inString(String node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outString(String node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseLong(Long node, Q question) throws AnalysisException
	{
		inLong(node, question);


		outLong(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inLong(Long node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outLong(Long node, Q question) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseTStatic(TStatic node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inTStatic(node, question);


		outTStatic(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inTStatic(TStatic node, Q question) throws AnalysisException
	{
		defaultInIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outTStatic(TStatic node, Q question) throws AnalysisException
	{
		defaultOutIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseTAsync(TAsync node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inTAsync(node, question);


		outTAsync(node, question);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inTAsync(TAsync node, Q question) throws AnalysisException
	{
		defaultInIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outTAsync(TAsync node, Q question) throws AnalysisException
	{
		defaultOutIToken(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultInPExp(PExp node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultOutPExp(PExp node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultPExp(PExp node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void inPExp(PExp node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void outPExp(PExp node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void caseAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getRoot() != null && !_visitedNodes.contains(node.getRoot())) 
		{
			node.getRoot().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgtypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getRecursive() != null && !_visitedNodes.contains(node.getRecursive())) 
		{
			node.getRecursive().apply(this, question);
		}

		outAApplyExp(node, question);

	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void inAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void outAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void caseANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANarrowExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this, question);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this, question);
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			node.getBasicType().apply(this, question);
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			node.getTypedef().apply(this, question);
		}

		outANarrowExp(node, question);

	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void inANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void outANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultInSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultOutSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		defaultPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void inSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void outSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultInSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultOutSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		defaultPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void inSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void outSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void caseABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanConstExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outABooleanConstExp(node, question);

	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void inABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void outABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void caseACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACasesExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		{
			List<ACaseAlternative> copy = new ArrayList<ACaseAlternative>(node.getCases());
			for( ACaseAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			node.getOthers().apply(this, question);
		}

		outACasesExp(node, question);

	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void inACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void outACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void caseACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharLiteralExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outACharLiteralExp(node, question);

	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void inACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void outACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void caseAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElseIfExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			node.getElseIf().apply(this, question);
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			node.getThen().apply(this, question);
		}

		outAElseIfExp(node, question);

	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void inAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void outAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void caseAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExists1Exp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outAExists1Exp(node, question);

	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void inAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void outAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void caseAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExistsExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outAExistsExp(node, question);

	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void inAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void outAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void caseAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this, question);
		}
		if(node.getMemberName() != null ) 
		{
			node.getMemberName().apply(this, question);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this, question);
		}

		outAFieldExp(node, question);

	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void inAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void outAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void caseAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldNumberExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTuple() != null && !_visitedNodes.contains(node.getTuple())) 
		{
			node.getTuple().apply(this, question);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this, question);
		}

		outAFieldNumberExp(node, question);

	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void inAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void outAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void caseAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForAllExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outAForAllExp(node, question);

	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void inAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void outAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void caseAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFuncInstatiationExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			node.getFunction().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getActualTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExpdef() != null && !_visitedNodes.contains(node.getExpdef())) 
		{
			node.getExpdef().apply(this, question);
		}
		if(node.getImpdef() != null && !_visitedNodes.contains(node.getImpdef())) 
		{
			node.getImpdef().apply(this, question);
		}

		outAFuncInstatiationExp(node, question);

	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void inAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void outAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void caseAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAHistoryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getHop() != null ) 
		{
			node.getHop().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOpnames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}

		outAHistoryExp(node, question);

	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void inAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void outAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void caseAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIfExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this, question);
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			node.getThen().apply(this, question);
		}
		{
			List<AElseIfExp> copy = new ArrayList<AElseIfExp>(node.getElseList());
			for( AElseIfExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getElse() != null && !_visitedNodes.contains(node.getElse())) 
		{
			node.getElse().apply(this, question);
		}

		outAIfExp(node, question);

	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void inAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void outAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void caseAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntLiteralExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAIntLiteralExp(node, question);

	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void inAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void outAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void caseAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIotaExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outAIotaExp(node, question);

	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void inAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void outAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void caseAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this, question);
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			node.getBasicType().apply(this, question);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this, question);
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			node.getTypedef().apply(this, question);
		}

		outAIsExp(node, question);

	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void inAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void outAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void caseAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsOfBaseClassExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBaseClass() != null ) 
		{
			node.getBaseClass().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAIsOfBaseClassExp(node, question);

	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void inAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void outAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void caseAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsOfClassExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this, question);
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			node.getClassType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAIsOfClassExp(node, question);

	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void inAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void outAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void caseALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALambdaExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ATypeBind> copy = new ArrayList<ATypeBind>(node.getBindList());
			for( ATypeBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParamPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getFunctionType() != null && !_visitedNodes.contains(node.getFunctionType())) 
		{
			node.getFunctionType().apply(this, question);
		}

		outALambdaExp(node, question);

	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void inALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void outALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void caseALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			node.getSuchThat().apply(this, question);
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			node.getValue().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outALetBeStExp(node, question);

	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void inALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void outALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void caseALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetDefExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outALetDefExp(node, question);

	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void inALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void outALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void caseADefExp(ADefExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADefExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outADefExp(node, question);

	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void inADefExp(ADefExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void outADefExp(ADefExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultInSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultOutSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		defaultPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void inSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void outSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void caseAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapletExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAMapletExp(node, question);

	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void inAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void outAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void caseAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMkBasicExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getArg() != null && !_visitedNodes.contains(node.getArg())) 
		{
			node.getArg().apply(this, question);
		}

		outAMkBasicExp(node, question);

	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void inAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void outAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void caseAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMkTypeExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAMkTypeExp(node, question);

	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void inAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void outAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void caseAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMuExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getRecord() != null && !_visitedNodes.contains(node.getRecord())) 
		{
			node.getRecord().apply(this, question);
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this, question);
		}
		{
			List<ARecordModifier> copy = new ArrayList<ARecordModifier>(node.getModifiers());
			for( ARecordModifier e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getModTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAMuExp(node, question);

	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void inAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void outAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void caseANewExp(ANewExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANewExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			node.getClassdef().apply(this, question);
		}
		if(node.getCtorDefinition() != null && !_visitedNodes.contains(node.getCtorDefinition())) 
		{
			node.getCtorDefinition().apply(this, question);
		}

		outANewExp(node, question);

	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void inANewExp(ANewExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void outANewExp(ANewExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void caseANilExp(ANilExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANilExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outANilExp(node, question);

	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void inANilExp(ANilExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void outANilExp(ANilExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void caseANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotYetSpecifiedExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outANotYetSpecifiedExp(node, question);

	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void inANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void outANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void caseAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPostOpExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		if(node.getPreexpression() != null && !_visitedNodes.contains(node.getPreexpression())) 
		{
			node.getPreexpression().apply(this, question);
		}
		if(node.getPostexpression() != null && !_visitedNodes.contains(node.getPostexpression())) 
		{
			node.getPostexpression().apply(this, question);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}

		outAPostOpExp(node, question);

	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void inAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void outAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void caseAPreExp(APreExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPreExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			node.getFunction().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAPreExp(node, question);

	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void inAPreExp(APreExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void outAPreExp(APreExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void caseAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPreOpExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}

		outAPreOpExp(node, question);

	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void inAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void outAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void caseAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuoteLiteralExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAQuoteLiteralExp(node, question);

	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void inAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void outAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void caseARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealLiteralExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outARealLiteralExp(node, question);

	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void inARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void outARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void caseASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASameBaseClassExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASameBaseClassExp(node, question);

	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void inASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void outASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void caseASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASameClassExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASameClassExp(node, question);

	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void inASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void outASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void caseASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASelfExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outASelfExp(node, question);

	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void inASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void outASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultInSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultOutSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		defaultPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void inSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void outSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultInSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultOutSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		defaultPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void inSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void outSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void caseAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStateInitExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}

		outAStateInitExp(node, question);

	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void inAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void outAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void caseAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStringLiteralExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAStringLiteralExp(node, question);

	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void inAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void outAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void caseASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubclassResponsibilityExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outASubclassResponsibilityExp(node, question);

	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void inASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void outASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void caseASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubseqExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getSeq() != null && !_visitedNodes.contains(node.getSeq())) 
		{
			node.getSeq().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this, question);
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			node.getFtype().apply(this, question);
		}
		if(node.getTtype() != null && !_visitedNodes.contains(node.getTtype())) 
		{
			node.getTtype().apply(this, question);
		}

		outASubseqExp(node, question);

	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void inASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void outASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void caseAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAThreadIdExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAThreadIdExp(node, question);

	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void inAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void outAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void caseATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATimeExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outATimeExp(node, question);

	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void inATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void outATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void caseATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATupleExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outATupleExp(node, question);

	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void inATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void outATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void caseAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUndefinedExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAUndefinedExp(node, question);

	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void inAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void outAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void caseAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVariableExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getVardef() != null && !_visitedNodes.contains(node.getVardef())) 
		{
			node.getVardef().apply(this, question);
		}

		outAVariableExp(node, question);

	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void inAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void outAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void caseAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAbsoluteUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAAbsoluteUnaryExp(node, question);

	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void inAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void outAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void caseACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACardinalityUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outACardinalityUnaryExp(node, question);

	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void inACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void outACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void caseADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistConcatUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outADistConcatUnaryExp(node, question);

	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void inADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void outADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void caseADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistIntersectUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outADistIntersectUnaryExp(node, question);

	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void inADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void outADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void caseADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistMergeUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outADistMergeUnaryExp(node, question);

	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void inADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void outADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void caseADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistUnionUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outADistUnionUnaryExp(node, question);

	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void inADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void outADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void caseAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElementsUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAElementsUnaryExp(node, question);

	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void inAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void outAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void caseAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFloorUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAFloorUnaryExp(node, question);

	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void inAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void outAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void caseAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAHeadUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAHeadUnaryExp(node, question);

	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void inAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void outAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void caseAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIndicesUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAIndicesUnaryExp(node, question);

	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void inAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void outAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void caseALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALenUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outALenUnaryExp(node, question);

	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void inALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void outALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void caseAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapDomainUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAMapDomainUnaryExp(node, question);

	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void inAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void outAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void caseAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapInverseUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this, question);
		}

		outAMapInverseUnaryExp(node, question);

	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void inAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void outAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void caseAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapRangeUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAMapRangeUnaryExp(node, question);

	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void inAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void outAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void caseANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outANotUnaryExp(node, question);

	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void inANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void outANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void caseAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPowerSetUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAPowerSetUnaryExp(node, question);

	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void inAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void outAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void caseAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAReverseUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAReverseUnaryExp(node, question);

	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void inAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void outAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void caseATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATailUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outATailUnaryExp(node, question);

	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void inATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void outATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void caseAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnaryMinusUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAUnaryMinusUnaryExp(node, question);

	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void inAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void outAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void caseAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnaryPlusUnaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAUnaryPlusUnaryExp(node, question);

	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void inAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void outAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultInSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultOutSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void inSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void outSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void caseACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACompBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outACompBinaryExp(node, question);

	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void inACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void outACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void caseADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADomainResByBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outADomainResByBinaryExp(node, question);

	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void inADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void outADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void caseADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADomainResToBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outADomainResToBinaryExp(node, question);

	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void inADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void outADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void caseAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEqualsBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAEqualsBinaryExp(node, question);

	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void inAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void outAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void caseAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInSetBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAInSetBinaryExp(node, question);

	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void inAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void outAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void caseAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapUnionBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAMapUnionBinaryExp(node, question);

	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void inAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void outAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void caseANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotEqualBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outANotEqualBinaryExp(node, question);

	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void inANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void outANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void caseANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotInSetBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outANotInSetBinaryExp(node, question);

	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void inANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void outANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultInSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultOutSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void inSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void outSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void caseAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPlusPlusBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAPlusPlusBinaryExp(node, question);

	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void inAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void outAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void caseAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProperSubsetBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAProperSubsetBinaryExp(node, question);

	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void inAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void outAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void caseARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARangeResByBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outARangeResByBinaryExp(node, question);

	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void inARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void outARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void caseARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARangeResToBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outARangeResToBinaryExp(node, question);

	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void inARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void outARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void caseASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqConcatBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASeqConcatBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void inASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void outASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void caseASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetDifferenceBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASetDifferenceBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void inASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void outASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void caseASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetIntersectBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASetIntersectBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void inASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void outASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void caseASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetUnionBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASetUnionBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void inASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void outASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void caseAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStarStarBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAStarStarBinaryExp(node, question);

	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void inAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void outAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void caseASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubsetBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASubsetBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void inASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void outASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void caseAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAndBooleanBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAAndBooleanBinaryExp(node, question);

	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void inAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void outAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void caseAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEquivalentBooleanBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAEquivalentBooleanBinaryExp(node, question);

	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void inAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void outAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void caseAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImpliesBooleanBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAImpliesBooleanBinaryExp(node, question);

	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void inAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void outAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void caseAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOrBooleanBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAOrBooleanBinaryExp(node, question);

	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void inAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void outAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void caseADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADivNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outADivNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void inADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void outADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void caseADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADivideNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outADivideNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void inADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void outADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void caseAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAGreaterEqualNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAGreaterEqualNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void inAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void outAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void caseAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAGreaterNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAGreaterNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void inAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void outAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void caseALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALessEqualNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outALessEqualNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void inALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void outALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void caseALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALessNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outALessNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void inALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void outALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void caseAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAModNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void inAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void outAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void caseAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPlusNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAPlusNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void inAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void outAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void caseARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARemNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outARemNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void inARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void outARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void caseASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubtractNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outASubtractNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void inASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void outASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void caseATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATimesNumericBinaryExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outATimesNumericBinaryExp(node, question);

	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void inATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void outATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void caseAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapCompMapExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this, question);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outAMapCompMapExp(node, question);

	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void inAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		defaultInSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void outAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		defaultOutSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void caseAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapEnumMapExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<AMapletExp> copy = new ArrayList<AMapletExp>(node.getMembers());
			for( AMapletExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getDomTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getRngTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAMapEnumMapExp(node, question);

	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void inAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		defaultInSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void outAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		defaultOutSMapExp(node, question);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void caseASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqCompSeqExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this, question);
		}
		if(node.getSetBind() != null && !_visitedNodes.contains(node.getSetBind())) 
		{
			node.getSetBind().apply(this, question);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outASeqCompSeqExp(node, question);

	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void inASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		defaultInSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void outASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		defaultOutSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void caseASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqEnumSeqExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASeqEnumSeqExp(node, question);

	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void inASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		defaultInSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void outASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		defaultOutSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void caseASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetCompSetExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this, question);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this, question);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this, question);
		}

		outASetCompSetExp(node, question);

	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void inASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void outASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void caseASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetEnumSetExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASetEnumSetExp(node, question);

	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void inASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void outASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void caseASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetRangeSetExp(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this, question);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this, question);
		}
		if(node.getLast() != null && !_visitedNodes.contains(node.getLast())) 
		{
			node.getLast().apply(this, question);
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			node.getFtype().apply(this, question);
		}
		if(node.getLtype() != null && !_visitedNodes.contains(node.getLtype())) 
		{
			node.getLtype().apply(this, question);
		}

		outASetRangeSetExp(node, question);

	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void inASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void outASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultInPModifier(PModifier node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultOutPModifier(PModifier node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultPModifier(PModifier node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void inPModifier(PModifier node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void outPModifier(PModifier node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void caseARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordModifier(node, question);

		if(node.getTag() != null ) 
		{
			node.getTag().apply(this, question);
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			node.getValue().apply(this, question);
		}

		outARecordModifier(node, question);

	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void inARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		defaultInPModifier(node, question);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void outARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		defaultOutPModifier(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultInPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultOutPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void inPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void outPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void caseACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACaseAlternative(node, question);

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			node.getCexp().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}

		outACaseAlternative(node, question);

	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void inACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		defaultInPAlternative(node, question);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void outACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		defaultOutPAlternative(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultInPType(PType node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultOutPType(PType node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultPType(PType node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void inPType(PType node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void outPType(PType node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultInSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultOutSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		defaultPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void inSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void outSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void caseABracketType(ABracketType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABracketType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outABracketType(node, question);

	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void inABracketType(ABracketType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void outABracketType(ABracketType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void caseAClassType(AClassType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			node.getClassdef().apply(this, question);
		}

		outAClassType(node, question);

	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void inAClassType(AClassType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void outAClassType(AClassType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void caseAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}

		outAFunctionType(node, question);

	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void inAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void outAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultInSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultOutSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		defaultPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void inSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void outSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultInSMapType(SMapType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultOutSMapType(SMapType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultSMapType(SMapType node, Q question) throws AnalysisException
	{
		defaultPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void inSMapType(SMapType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void outSMapType(SMapType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void caseAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}

		outAOperationType(node, question);

	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void inAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void outAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void caseAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOptionalType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAOptionalType(node, question);

	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void inAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void outAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void caseAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAParameterType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outAParameterType(node, question);

	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void inAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void outAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void caseAProductType(AProductType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProductType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAProductType(node, question);

	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void inAProductType(AProductType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void outAProductType(AProductType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void caseAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuoteType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAQuoteType(node, question);

	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void inAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void outAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultInSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultOutSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		defaultPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void inSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void outSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void caseASetType(ASetType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getSetof() != null && !_visitedNodes.contains(node.getSetof())) 
		{
			node.getSetof().apply(this, question);
		}

		outASetType(node, question);

	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void inASetType(ASetType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void outASetType(ASetType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void caseAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUndefinedType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAUndefinedType(node, question);

	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void inAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void outAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void caseAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnionType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this, question);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this, question);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this, question);
		}
		if(node.getProdType() != null && !_visitedNodes.contains(node.getProdType())) 
		{
			node.getProdType().apply(this, question);
		}
		if(node.getFuncType() != null && !_visitedNodes.contains(node.getFuncType())) 
		{
			node.getFuncType().apply(this, question);
		}
		if(node.getOpType() != null && !_visitedNodes.contains(node.getOpType())) 
		{
			node.getOpType().apply(this, question);
		}
		if(node.getNumType() != null && !_visitedNodes.contains(node.getNumType())) 
		{
			node.getNumType().apply(this, question);
		}
		if(node.getRecType() != null && !_visitedNodes.contains(node.getRecType())) 
		{
			node.getRecType().apply(this, question);
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			node.getClassType().apply(this, question);
		}

		outAUnionType(node, question);

	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void inAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void outAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void caseAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnknownType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAUnknownType(node, question);

	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void inAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void outAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void caseAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnresolvedType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outAUnresolvedType(node, question);

	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void inAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void outAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void caseAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVoidReturnType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAVoidReturnType(node, question);

	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void inAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void outAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void caseAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVoidType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAVoidType(node, question);

	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void inAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		defaultInPType(node, question);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void outAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void caseASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqSeqType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			node.getSeqof().apply(this, question);
		}

		outASeqSeqType(node, question);

	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void inASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		defaultInSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void outASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		defaultOutSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void caseASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeq1SeqType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			node.getSeqof().apply(this, question);
		}

		outASeq1SeqType(node, question);

	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void inASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		defaultInSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void outASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		defaultOutSSeqType(node, question);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void caseAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInMapMapType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this, question);
		}

		outAInMapMapType(node, question);

	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void inAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		defaultInSMapType(node, question);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void outAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		defaultOutSMapType(node, question);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void caseAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapMapType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this, question);
		}

		outAMapMapType(node, question);

	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void inAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		defaultInSMapType(node, question);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void outAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		defaultOutSMapType(node, question);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void caseANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamedInvariantType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			node.getInvDef().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outANamedInvariantType(node, question);

	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void inANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		defaultInSInvariantType(node, question);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void outANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		defaultOutSInvariantType(node, question);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void caseARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordInvariantType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			node.getInvDef().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outARecordInvariantType(node, question);

	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void inARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		defaultInSInvariantType(node, question);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void outARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		defaultOutSInvariantType(node, question);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void caseABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outABooleanBasicType(node, question);

	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void inABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void outABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void caseACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outACharBasicType(node, question);

	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void inACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void outACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultInSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultOutSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		defaultSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void inSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void outSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void caseATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATokenBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outATokenBasicType(node, question);

	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void inATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void outATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void caseAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntNumericBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAIntNumericBasicType(node, question);

	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void inAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void outAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void caseANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANatOneNumericBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANatOneNumericBasicType(node, question);

	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void inANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void outANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void caseANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANatNumericBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANatNumericBasicType(node, question);

	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void inANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void outANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void caseARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARationalNumericBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outARationalNumericBasicType(node, question);

	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void inARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void outARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void caseARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealNumericBasicType(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outARealNumericBasicType(node, question);

	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void inARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void outARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultInPField(PField node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultOutPField(PField node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultPField(PField node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void inPField(PField node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void outPField(PField node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void caseAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldField(node, question);

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getTagname() != null ) 
		{
			node.getTagname().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAFieldField(node, question);

	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void inAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		defaultInPField(node, question);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void outAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		defaultOutPField(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultInPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultOutPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void inPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void outPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void caseAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAccessSpecifierAccessSpecifier(node, question);

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getStatic() != null && !_visitedNodes.contains(node.getStatic())) 
		{
			node.getStatic().apply(this, question);
		}
		if(node.getAsync() != null && !_visitedNodes.contains(node.getAsync())) 
		{
			node.getAsync().apply(this, question);
		}

		outAAccessSpecifierAccessSpecifier(node, question);

	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void inAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultInPAccessSpecifier(node, question);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void outAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		defaultOutPAccessSpecifier(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultInPAccess(PAccess node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultOutPAccess(PAccess node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultPAccess(PAccess node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void inPAccess(PAccess node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void outPAccess(PAccess node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void caseAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPublicAccess(node, question);


		outAPublicAccess(node, question);

	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void inAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void outAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void caseAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProtectedAccess(node, question);


		outAProtectedAccess(node, question);

	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void inAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void outAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void caseAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPrivateAccess(node, question);


		outAPrivateAccess(node, question);

	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void inAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void outAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultInPPattern(PPattern node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultOutPPattern(PPattern node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultPPattern(PPattern node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void inPPattern(PPattern node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void outPPattern(PPattern node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void caseABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outABooleanPattern(node, question);

	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void inABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void outABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void caseACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharacterPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outACharacterPattern(node, question);

	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void inACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void outACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void caseAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAConcatenationPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAConcatenationPattern(node, question);

	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void inAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void outAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void caseAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExpressionPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outAExpressionPattern(node, question);

	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void inAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void outAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void caseAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outAIdentifierPattern(node, question);

	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void inAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void outAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void caseAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIgnorePattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getAnyName() != null ) 
		{
			node.getAnyName().apply(this, question);
		}

		outAIgnorePattern(node, question);

	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void inAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void outAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void caseAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntegerPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAIntegerPattern(node, question);

	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void inAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void outAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void caseANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANilPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANilPattern(node, question);

	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void inANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void outANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void caseAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuotePattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAQuotePattern(node, question);

	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void inAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void outAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void caseARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outARealPattern(node, question);

	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void inARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void outARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void caseARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getTypename() != null ) 
		{
			node.getTypename().apply(this, question);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outARecordPattern(node, question);

	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void inARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void outARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void caseASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASeqPattern(node, question);

	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void inASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void outASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void caseASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASetPattern(node, question);

	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void inASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void outASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void caseAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStringPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this, question);
		}

		outAStringPattern(node, question);

	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void inAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void outAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void caseATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATuplePattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outATuplePattern(node, question);

	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void inATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void outATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void caseAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnionPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAUnionPattern(node, question);

	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void inAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void outAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void caseAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<AMapletPatternMaplet> copy = new ArrayList<AMapletPatternMaplet>(node.getMaplets());
			for( AMapletPatternMaplet e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAMapPattern(node, question);

	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void inAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void outAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void caseAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapUnionPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAMapUnionPattern(node, question);

	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void inAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void outAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void caseAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAObjectPattern(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClassname() != null ) 
		{
			node.getClassname().apply(this, question);
		}
		{
			List<ANamePatternPair> copy = new ArrayList<ANamePatternPair>(node.getFields());
			for( ANamePatternPair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAObjectPattern(node, question);

	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void inAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void outAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultInPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultOutPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void inPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void outPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void caseAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapletPatternMaplet(node, question);

		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this, question);
		}

		outAMapletPatternMaplet(node, question);

	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void inAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		defaultInPMaplet(node, question);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void outAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		defaultOutPMaplet(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultInPPair(PPair node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultOutPPair(PPair node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultPPair(PPair node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void inPPair(PPair node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void outPPair(PPair node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void caseAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPatternTypePair(node, question);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAPatternTypePair(node, question);

	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void inAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		defaultInPPair(node, question);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void outAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void caseAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPatternListTypePair(node, question);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAPatternListTypePair(node, question);

	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void inAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		defaultInPPair(node, question);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void outAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void caseANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamePatternPair(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}

		outANamePatternPair(node, question);

	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void inANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		defaultInPPair(node, question);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void outANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultInPBind(PBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultOutPBind(PBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultPBind(PBind node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void inPBind(PBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void outPBind(PBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void caseASetBind(ASetBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetBind(node, question);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this, question);
		}

		outASetBind(node, question);

	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void inASetBind(ASetBind node, Q question) throws AnalysisException
	{
		defaultInPBind(node, question);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void outASetBind(ASetBind node, Q question) throws AnalysisException
	{
		defaultOutPBind(node, question);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void caseATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeBind(node, question);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outATypeBind(node, question);

	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void inATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		defaultInPBind(node, question);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void outATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		defaultOutPBind(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultInPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultOutPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void inPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void outPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void caseASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetMultipleBind(node, question);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this, question);
		}

		outASetMultipleBind(node, question);

	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void inASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		defaultInPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void outASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		defaultOutPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void caseATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeMultipleBind(node, question);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outATypeMultipleBind(node, question);

	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void inATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		defaultInPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void outATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		defaultOutPMultipleBind(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultInPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultOutPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void inPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void outPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void caseADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADefPatternBind(node, question);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outADefPatternBind(node, question);

	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void inADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		defaultInPPatternBind(node, question);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void outADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		defaultOutPPatternBind(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultInPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultOutPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void inPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void outPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void caseAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAssignmentDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}

		outAAssignmentDefinition(node, question);

	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void inAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void outAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void caseAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInstanceVariableDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this, question);
		}

		outAInstanceVariableDefinition(node, question);

	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void inAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void outAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultInSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultOutSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void inSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void outSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void caseAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassInvariantDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outAClassInvariantDefinition(node, question);

	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void inAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void outAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void caseAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEqualsDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getTypebind() != null && !_visitedNodes.contains(node.getTypebind())) 
		{
			node.getTypebind().apply(this, question);
		}
		if(node.getSetbind() != null && !_visitedNodes.contains(node.getSetbind())) 
		{
			node.getSetbind().apply(this, question);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}
		if(node.getDefType() != null && !_visitedNodes.contains(node.getDefType())) 
		{
			node.getDefType().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAEqualsDefinition(node, question);

	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void inAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void outAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultInSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultOutSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void inSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void outSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void caseAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExternalDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this, question);
		}

		outAExternalDefinition(node, question);

	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void inAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void outAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultInSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultOutSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void inSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void outSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void caseAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImportedDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outAImportedDefinition(node, question);

	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void inAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void outAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void caseAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInheritedDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getSuperdef() != null && !_visitedNodes.contains(node.getSuperdef())) 
		{
			node.getSuperdef().apply(this, question);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this, question);
		}

		outAInheritedDefinition(node, question);

	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void inAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void outAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void caseALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALocalDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outALocalDefinition(node, question);

	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void inALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void outALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void caseAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMultiBindListDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAMultiBindListDefinition(node, question);

	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void inAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void outAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void caseAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMutexSyncDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOperations());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}

		outAMutexSyncDefinition(node, question);

	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void inAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void outAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void caseANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamedTraceDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANamedTraceDefinition(node, question);

	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void inANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void outANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void caseAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPerSyncDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		if(node.getGuard() != null && !_visitedNodes.contains(node.getGuard())) 
		{
			node.getGuard().apply(this, question);
		}

		outAPerSyncDefinition(node, question);

	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void inAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void outAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void caseARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARenamedDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outARenamedDefinition(node, question);

	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void inARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void outARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void caseAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStateDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			node.getInvPattern().apply(this, question);
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			node.getInvExpression().apply(this, question);
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			node.getInvdef().apply(this, question);
		}
		if(node.getInitPattern() != null && !_visitedNodes.contains(node.getInitPattern())) 
		{
			node.getInitPattern().apply(this, question);
		}
		if(node.getInitExpression() != null && !_visitedNodes.contains(node.getInitExpression())) 
		{
			node.getInitExpression().apply(this, question);
		}
		if(node.getInitdef() != null && !_visitedNodes.contains(node.getInitdef())) 
		{
			node.getInitdef().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getStateDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getRecordDefinition() != null && !_visitedNodes.contains(node.getRecordDefinition())) 
		{
			node.getRecordDefinition().apply(this, question);
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this, question);
		}

		outAStateDefinition(node, question);

	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void inAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void outAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void caseAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAThreadDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}
		if(node.getOperationName() != null ) 
		{
			node.getOperationName().apply(this, question);
		}
		if(node.getOperationDef() != null && !_visitedNodes.contains(node.getOperationDef())) 
		{
			node.getOperationDef().apply(this, question);
		}

		outAThreadDefinition(node, question);

	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void inAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void outAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void caseATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getInvType() != null && !_visitedNodes.contains(node.getInvType())) 
		{
			node.getInvType().apply(this, question);
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			node.getInvPattern().apply(this, question);
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			node.getInvExpression().apply(this, question);
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			node.getInvdef().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getComposeDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outATypeDefinition(node, question);

	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void inATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void outATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void caseAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUntypedDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAUntypedDefinition(node, question);

	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void inAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void outAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void caseAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}

		outAValueDefinition(node, question);

	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void inAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void outAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void caseAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExplicitFunctionDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this, question);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this, question);
		}
		if(node.getMeasure() != null ) 
		{
			node.getMeasure().apply(this, question);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this, question);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this, question);
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			node.getMeasureDef().apply(this, question);
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			node.getExpectedResult().apply(this, question);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this, question);
		}
		{
			List<List<PPattern>> copy = new ArrayList<List<PPattern>>(node.getParamPatternList());
			for( List<PPattern> list : copy) {
				for( PPattern e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this, question);
					}
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitionList());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAExplicitFunctionDefinition(node, question);

	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void inAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultInSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void outAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultOutSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void caseAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImplicitFunctionDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this, question);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this, question);
		}
		if(node.getMeasure() != null ) 
		{
			node.getMeasure().apply(this, question);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this, question);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this, question);
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			node.getMeasureDef().apply(this, question);
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			node.getExpectedResult().apply(this, question);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this, question);
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParamPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAImplicitFunctionDefinition(node, question);

	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void inAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultInSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void outAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		defaultOutSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void caseAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExplicitOperationDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this, question);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this, question);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this, question);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this, question);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this, question);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParameterPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAExplicitOperationDefinition(node, question);

	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void inAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		defaultInSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void outAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		defaultOutSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void caseAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImplicitOperationDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this, question);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this, question);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this, question);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this, question);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this, question);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this, question);
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParameterPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			node.getStateDefinition().apply(this, question);
		}

		outAImplicitOperationDefinition(node, question);

	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void inAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		defaultInSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void outAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		defaultOutSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultInPTerm(PTerm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultOutPTerm(PTerm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultPTerm(PTerm node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void inPTerm(PTerm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void outPTerm(PTerm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void caseATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATraceDefinitionTerm(node, question);

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getList());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outATraceDefinitionTerm(node, question);

	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void inATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		defaultInPTerm(node, question);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void outATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		defaultOutPTerm(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultInPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultOutPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void inPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void outPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void caseAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInstanceTraceDefinition(node, question);


		outAInstanceTraceDefinition(node, question);

	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void inAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void outAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void caseALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStBindingTraceDefinition(node, question);

		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		if(node.getStexp() != null && !_visitedNodes.contains(node.getStexp())) 
		{
			node.getStexp().apply(this, question);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outALetBeStBindingTraceDefinition(node, question);

	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void inALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void outALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void caseALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetDefBindingTraceDefinition(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}

		outALetDefBindingTraceDefinition(node, question);

	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void inALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void outALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void caseARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARepeatTraceDefinition(node, question);

		if(node.getCore() != null && !_visitedNodes.contains(node.getCore())) 
		{
			node.getCore().apply(this, question);
		}

		outARepeatTraceDefinition(node, question);

	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void inARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void outARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultInPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultOutPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void inPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void outPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void caseAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyExpressionTraceCoreDefinition(node, question);

		if(node.getCallStatement() != null && !_visitedNodes.contains(node.getCallStatement())) 
		{
			node.getCallStatement().apply(this, question);
		}

		outAApplyExpressionTraceCoreDefinition(node, question);

	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void inAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void outAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void caseABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABracketedExpressionTraceCoreDefinition(node, question);

		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outABracketedExpressionTraceCoreDefinition(node, question);

	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void inABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void outABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void caseAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAConcurrentExpressionTraceCoreDefinition(node, question);

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getDefs());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAConcurrentExpressionTraceCoreDefinition(node, question);

	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void inAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void outAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void caseABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABusClassDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this, question);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this, question);
		}
		if(node.getInstance() != null && !_visitedNodes.contains(node.getInstance())) 
		{
			node.getInstance().apply(this, question);
		}

		outABusClassDefinition(node, question);

	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void inABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void outABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void caseACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACpuClassDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this, question);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this, question);
		}

		outACpuClassDefinition(node, question);

	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void inACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void outACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void caseASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASystemClassDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this, question);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this, question);
		}

		outASystemClassDefinition(node, question);

	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void inASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void outASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void caseAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassClassDefinition(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this, question);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this, question);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this, question);
		}

		outAClassClassDefinition(node, question);

	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void inAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void outAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultInPModules(PModules node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultOutPModules(PModules node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultPModules(PModules node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void inPModules(PModules node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void outPModules(PModules node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void caseAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleModules(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getImports() != null && !_visitedNodes.contains(node.getImports())) 
		{
			node.getImports().apply(this, question);
		}
		if(node.getExports() != null && !_visitedNodes.contains(node.getExports())) 
		{
			node.getExports().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getImportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getExportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAModuleModules(node, question);

	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void inAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		defaultInPModules(node, question);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void outAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		defaultOutPModules(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultInPImports(PImports node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultOutPImports(PImports node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultPImports(PImports node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void inPImports(PImports node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void outPImports(PImports node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void caseAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleImports(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<AFromModuleImports> copy = new ArrayList<AFromModuleImports>(node.getImports());
			for( AFromModuleImports e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAModuleImports(node, question);

	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void inAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		defaultInPImports(node, question);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void outAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		defaultOutPImports(node, question);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void caseAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFromModuleImports(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<List<PImport>> copy = new ArrayList<List<PImport>>(node.getSignatures());
			for( List<PImport> list : copy) {
				for( PImport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this, question);
					}
				}
			}
		}

		outAFromModuleImports(node, question);

	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void inAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		defaultInPImports(node, question);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void outAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		defaultOutPImports(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultInPImport(PImport node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultOutPImport(PImport node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultPImport(PImport node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void inPImport(PImport node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void outPImport(PImport node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void caseAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAllImport(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}

		outAAllImport(node, question);

	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void inAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		defaultInPImport(node, question);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void outAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void caseATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeImport(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outATypeImport(node, question);

	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void inATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		defaultInPImport(node, question);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void outATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultInSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		defaultInPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultOutSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		defaultPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void inSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		defaultInPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void outSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void caseAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueValueImport(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this, question);
		}

		outAValueValueImport(node, question);

	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void inAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void outAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void caseAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionValueImport(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}

		outAFunctionValueImport(node, question);

	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void inAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void outAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void caseAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationValueImport(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this, question);
		}

		outAOperationValueImport(node, question);

	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void inAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void outAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultInPExports(PExports node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultOutPExports(PExports node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultPExports(PExports node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void inPExports(PExports node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void outPExports(PExports node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void caseAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleExports(node, question);

		{
			List<List<PExport>> copy = new ArrayList<List<PExport>>(node.getExports());
			for( List<PExport> list : copy) {
				for( PExport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this, question);
					}
				}
			}
		}

		outAModuleExports(node, question);

	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void inAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		defaultInPExports(node, question);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void outAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		defaultOutPExports(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultInPExport(PExport node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultOutPExport(PExport node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultPExport(PExport node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void inPExport(PExport node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void outPExport(PExport node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void caseAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAllExport(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAAllExport(node, question);

	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void inAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void outAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void caseAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionExport(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this, question);
		}

		outAFunctionExport(node, question);

	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void inAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void outAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void caseAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationExport(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this, question);
		}

		outAOperationExport(node, question);

	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void inAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void outAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void caseATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeExport(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outATypeExport(node, question);

	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void inATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		defaultInPExport(node, question);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void outATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void caseAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueExport(node, question);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this, question);
		}

		outAValueExport(node, question);

	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void inAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void outAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultInPStm(PStm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultOutPStm(PStm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultPStm(PStm node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void inPStm(PStm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void outPStm(PStm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void caseAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAlwaysStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getAlways() != null && !_visitedNodes.contains(node.getAlways())) 
		{
			node.getAlways().apply(this, question);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}

		outAAlwaysStm(node, question);

	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void inAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void outAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void caseAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAssignmentStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getTarget() != null && !_visitedNodes.contains(node.getTarget())) 
		{
			node.getTarget().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		if(node.getTargetType() != null && !_visitedNodes.contains(node.getTargetType())) 
		{
			node.getTargetType().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this, question);
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			node.getStateDefinition().apply(this, question);
		}

		outAAssignmentStm(node, question);

	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void inAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void outAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void caseAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAtomicStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<AAssignmentStm> copy = new ArrayList<AAssignmentStm>(node.getAssignments());
			for( AAssignmentStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getStatedef() != null && !_visitedNodes.contains(node.getStatedef())) 
		{
			node.getStatedef().apply(this, question);
		}

		outAAtomicStm(node, question);

	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void inAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void outAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void caseACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACallObjectStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getDesignator() != null && !_visitedNodes.contains(node.getDesignator())) 
		{
			node.getDesignator().apply(this, question);
		}
		if(node.getClassname() != null ) 
		{
			node.getClassname().apply(this, question);
		}
		if(node.getFieldname() != null ) 
		{
			node.getFieldname().apply(this, question);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outACallObjectStm(node, question);

	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void inACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void outACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void caseACallStm(ACallStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACallStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getRootdef() != null && !_visitedNodes.contains(node.getRootdef())) 
		{
			node.getRootdef().apply(this, question);
		}

		outACallStm(node, question);

	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void inACallStm(ACallStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void outACallStm(ACallStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void caseACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACasesStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		{
			List<ACaseAlternativeStm> copy = new ArrayList<ACaseAlternativeStm>(node.getCases());
			for( ACaseAlternativeStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			node.getOthers().apply(this, question);
		}

		outACasesStm(node, question);

	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void inACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void outACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void caseAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassInvariantStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getInvDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAClassInvariantStm(node, question);

	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void inAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void outAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void caseACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACyclesStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getCycles() != null && !_visitedNodes.contains(node.getCycles())) 
		{
			node.getCycles().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outACyclesStm(node, question);

	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void inACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void outACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void caseADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADurationStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getDuration() != null && !_visitedNodes.contains(node.getDuration())) 
		{
			node.getDuration().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outADurationStm(node, question);

	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void inADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void outADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void caseAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElseIfStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			node.getElseIf().apply(this, question);
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			node.getThenStm().apply(this, question);
		}

		outAElseIfStm(node, question);

	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void inAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void outAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void caseAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAErrorStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAErrorStm(node, question);

	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void inAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void outAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void caseAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExitStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this, question);
		}

		outAExitStm(node, question);

	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void inAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void outAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void caseAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForAllStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outAForAllStm(node, question);

	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void inAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void outAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void caseAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForIndexStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getVar() != null ) 
		{
			node.getVar().apply(this, question);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this, question);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this, question);
		}
		if(node.getBy() != null && !_visitedNodes.contains(node.getBy())) 
		{
			node.getBy().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outAForIndexStm(node, question);

	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void inAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void outAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void caseAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForPatternBindStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this, question);
		}

		outAForPatternBindStm(node, question);

	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void inAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void outAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void caseAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIfStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getIfExp() != null && !_visitedNodes.contains(node.getIfExp())) 
		{
			node.getIfExp().apply(this, question);
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			node.getThenStm().apply(this, question);
		}
		{
			List<AElseIfStm> copy = new ArrayList<AElseIfStm>(node.getElseIf());
			for( AElseIfStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getElseStm() != null && !_visitedNodes.contains(node.getElseStm())) 
		{
			node.getElseStm().apply(this, question);
		}

		outAIfStm(node, question);

	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void inAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void outAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void caseALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this, question);
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			node.getSuchThat().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this, question);
		}

		outALetBeStStm(node, question);

	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void inALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void outALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void caseALetStm(ALetStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outALetStm(node, question);

	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void inALetStm(ALetStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void outALetStm(ALetStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void caseANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotYetSpecifiedStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANotYetSpecifiedStm(node, question);

	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void inANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void outANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void caseAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAReturnStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outAReturnStm(node, question);

	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void inAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void outAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultInSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultOutSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void inSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void outSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void caseASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASkipStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outASkipStm(node, question);

	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void inASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void outASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void caseASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASpecificationStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this, question);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this, question);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASpecificationStm(node, question);

	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void inASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void outASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void caseAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStartStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			node.getObj().apply(this, question);
		}

		outAStartStm(node, question);

	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void inAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void outAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void caseAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStopStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			node.getObj().apply(this, question);
		}

		outAStopStm(node, question);

	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void inAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void outAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void caseASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubclassResponsibilityStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outASubclassResponsibilityStm(node, question);

	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void inASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void outASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void caseATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATixeStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<ATixeStmtAlternative> copy = new ArrayList<ATixeStmtAlternative>(node.getTraps());
			for( ATixeStmtAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}

		outATixeStm(node, question);

	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void inATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void outATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void caseATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATrapStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this, question);
		}
		if(node.getWith() != null && !_visitedNodes.contains(node.getWith())) 
		{
			node.getWith().apply(this, question);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this, question);
		}

		outATrapStm(node, question);

	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void inATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void outATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void caseAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAWhileStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}

		outAWhileStm(node, question);

	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void inAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void outAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void caseAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPeriodicStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAPeriodicStm(node, question);

	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void inAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void outAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void caseASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASporadicStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outASporadicStm(node, question);

	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void inASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void outASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void caseABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABlockSimpleBlockStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		{
			List<AAssignmentDefinition> copy = new ArrayList<AAssignmentDefinition>(node.getAssignmentDefs());
			for( AAssignmentDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outABlockSimpleBlockStm(node, question);

	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void inABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultInSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void outABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultOutSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void caseANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANonDeterministicSimpleBlockStm(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outANonDeterministicSimpleBlockStm(node, question);

	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void inANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultInSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void outANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		defaultOutSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultInPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultOutPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void inPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void outPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void caseAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldStateDesignator(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this, question);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this, question);
		}
		if(node.getObjectfield() != null ) 
		{
			node.getObjectfield().apply(this, question);
		}

		outAFieldStateDesignator(node, question);

	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void inAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void outAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void caseAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierStateDesignator(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}

		outAIdentifierStateDesignator(node, question);

	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void inAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void outAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void caseAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapSeqStateDesignator(node, question);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}
		if(node.getMapseq() != null && !_visitedNodes.contains(node.getMapseq())) 
		{
			node.getMapseq().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this, question);
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this, question);
		}

		outAMapSeqStateDesignator(node, question);

	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void inAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void outAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultInPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultOutPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void inPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void outPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void caseAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyObjectDesignator(node, question);

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this, question);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}

		outAApplyObjectDesignator(node, question);

	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void inAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void outAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void caseAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldObjectDesignator(node, question);

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this, question);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this, question);
		}
		if(node.getFieldName() != null ) 
		{
			node.getFieldName().apply(this, question);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this, question);
		}

		outAFieldObjectDesignator(node, question);

	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void inAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void outAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void caseAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierObjectDesignator(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outAIdentifierObjectDesignator(node, question);

	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void inAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void outAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void caseANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANewObjectDesignator(node, question);

		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this, question);
		}

		outANewObjectDesignator(node, question);

	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void inANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void outANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void caseASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASelfObjectDesignator(node, question);

		if(node.getSelf() != null ) 
		{
			node.getSelf().apply(this, question);
		}

		outASelfObjectDesignator(node, question);

	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void inASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void outASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultInPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultOutPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void inPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void outPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void caseACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACaseAlternativeStm(node, question);

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			node.getCexp().apply(this, question);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this, question);
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this, question);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this, question);
				}
			}
		}
		if(node.getCtype() != null && !_visitedNodes.contains(node.getCtype())) 
		{
			node.getCtype().apply(this, question);
		}

		outACaseAlternativeStm(node, question);

	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void inACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		defaultInPAlternativeStm(node, question);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void outACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		defaultOutPAlternativeStm(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultInPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultOutPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void inPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void outPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void caseATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATixeStmtAlternative(node, question);

		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this, question);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this, question);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this, question);
		}

		outATixeStmtAlternative(node, question);

	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void inATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		defaultInPStmtAlternative(node, question);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void outATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		defaultOutPStmtAlternative(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultInPClause(PClause node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultOutPClause(PClause node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultPClause(PClause node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void inPClause(PClause node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void outPClause(PClause node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void caseAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExternalClause(node, question);

		if(node.getMode() != null ) 
		{
			node.getMode().apply(this, question);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getIdentifiers());
			for( ILexNameToken e : copy) 
			{
				e.apply(this, question);
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this, question);
		}

		outAExternalClause(node, question);

	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void inAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		defaultInPClause(node, question);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void outAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		defaultOutPClause(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultInPCase(PCase node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultOutPCase(PCase node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultPCase(PCase node, Q question) throws AnalysisException
	{
		defaultINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void inPCase(PCase node, Q question) throws AnalysisException
	{
		defaultInINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void outPCase(PCase node, Q question) throws AnalysisException
	{
		defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void caseAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAErrorCase(node, question);

		if(node.getName() != null ) 
		{
			node.getName().apply(this, question);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this, question);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this, question);
		}

		outAErrorCase(node, question);

	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void inAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		defaultInPCase(node, question);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void outAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		defaultOutPCase(node, question);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultOutINode(INode node, Q question) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultInINode(INode node, Q question) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultINode(INode node, Q question) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultOutIToken(IToken node, Q question) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultInIToken(IToken node, Q question) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultIToken(IToken node, Q question) throws AnalysisException
	{
		//nothing to do
	}



}
