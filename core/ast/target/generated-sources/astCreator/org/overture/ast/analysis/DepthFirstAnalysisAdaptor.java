/*******************************************************************************
* Copyright (c) 2009, 2011 Overture Team and others.
*
* Overture is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Overture is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Overture.  If not, see <http://www.gnu.org/licenses/>.
*
* The Overture Tool web-site: http://overturetool.org/
*******************************************************************************/

/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overture.ast.analysis;


import org.overture.ast.intf.lex.ILexIdentifierToken;
import org.overture.ast.modules.AOperationValueImport;
import org.overture.ast.expressions.ACasesExp;
import org.overture.ast.expressions.AUnaryPlusUnaryExp;
import org.overture.ast.expressions.ALetDefExp;
import org.overture.ast.expressions.PModifier;
import org.overture.ast.definitions.ARenamedDefinition;
import org.overture.ast.statements.AAssignmentStm;
import org.overture.ast.statements.AFieldObjectDesignator;
import org.overture.ast.expressions.AIsOfBaseClassExp;
import java.lang.Integer;
import org.overture.ast.definitions.AInstanceVariableDefinition;
import org.overture.ast.expressions.AUndefinedExp;
import org.overture.ast.expressions.ASubtractNumericBinaryExp;
import org.overture.ast.patterns.PPattern;
import org.overture.ast.definitions.PAccess;
import org.overture.ast.definitions.traces.PTraceCoreDefinition;
import java.lang.Long;
import org.overture.ast.expressions.ALetBeStExp;
import org.overture.ast.expressions.AIotaExp;
import org.overture.ast.expressions.AElementsUnaryExp;
import org.overture.ast.types.ASetType;
import org.overture.ast.definitions.ATypeDefinition;
import org.overture.ast.statements.PStmtAlternative;
import org.overture.ast.types.SBasicType;
import org.overture.ast.expressions.SBinaryExp;
import org.overture.ast.definitions.traces.AConcurrentExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AMapInverseUnaryExp;
import org.overture.ast.expressions.AMapUnionBinaryExp;
import org.overture.ast.types.AUnresolvedType;
import org.overture.ast.types.ARealNumericBasicType;
import org.overture.ast.patterns.AObjectPattern;
import org.overture.ast.statements.ACyclesStm;
import org.overture.ast.expressions.AExists1Exp;
import org.overture.ast.expressions.ATupleExp;
import org.overture.ast.patterns.AIntegerPattern;
import org.overture.ast.node.tokens.TStatic;
import org.overture.ast.expressions.ABooleanConstExp;
import org.overture.ast.patterns.ATypeBind;
import org.overture.ast.expressions.SMapExp;
import org.overture.ast.expressions.PExp;
import org.overture.ast.statements.ANonDeterministicSimpleBlockStm;
import org.overture.ast.expressions.AAbsoluteUnaryExp;
import org.overture.ast.statements.AApplyObjectDesignator;
import org.overture.ast.expressions.AIsExp;
import org.overture.ast.types.AOptionalType;
import org.overture.ast.types.AUnionType;
import org.overture.ast.definitions.APrivateAccess;
import org.overture.ast.definitions.traces.ALetBeStBindingTraceDefinition;
import org.overture.ast.modules.PModules;
import org.overture.ast.definitions.AImplicitFunctionDefinition;
import org.overture.ast.types.AVoidType;
import org.overture.ast.patterns.ATuplePattern;
import org.overture.ast.statements.ACallStm;
import org.overture.ast.statements.ASelfObjectDesignator;
import org.overture.ast.typechecker.ClassDefinitionSettings;
import org.overture.ast.statements.AFieldStateDesignator;
import org.overture.ast.types.AVoidReturnType;
import org.overture.ast.patterns.AStringPattern;
import org.overture.ast.definitions.APublicAccess;
import org.overture.ast.expressions.ADomainResByBinaryExp;
import org.overture.ast.patterns.AMapletPatternMaplet;
import org.overture.ast.expressions.ACardinalityUnaryExp;
import org.overture.ast.types.ABooleanBasicType;
import org.overture.ast.definitions.traces.AInstanceTraceDefinition;
import org.overture.ast.statements.ASubclassResponsibilityStm;
import org.overture.ast.expressions.SSeqExp;
import org.overture.ast.expressions.ASetEnumSetExp;
import org.overture.ast.patterns.PMultipleBind;
import org.overture.ast.expressions.ADefExp;
import org.overture.ast.types.AFunctionType;
import org.overture.ast.expressions.AProperSubsetBinaryExp;
import org.overture.ast.types.AUnknownType;
import org.overture.ast.modules.AModuleExports;
import org.overture.ast.expressions.ATimeExp;
import org.overture.ast.definitions.traces.AApplyExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AImpliesBooleanBinaryExp;
import org.overture.ast.statements.ACaseAlternativeStm;
import org.overture.ast.patterns.ANamePatternPair;
import org.overture.ast.definitions.AStateDefinition;
import org.overture.ast.patterns.ASetBind;
import org.overture.ast.types.SSeqType;
import org.overture.ast.statements.AForAllStm;
import org.overture.ast.expressions.AGreaterNumericBinaryExp;
import org.overture.ast.expressions.ASetCompSetExp;
import org.overture.ast.patterns.AUnionPattern;
import org.overture.ast.expressions.AHeadUnaryExp;
import org.overture.ast.types.AUndefinedType;
import org.overture.ast.expressions.AFieldExp;
import org.overture.ast.patterns.ARealPattern;
import org.overture.ast.definitions.APerSyncDefinition;
import org.overture.ast.definitions.ABusClassDefinition;
import org.overture.ast.analysis.intf.IAnalysis;
import org.overture.ast.statements.ACasesStm;
import org.overture.ast.node.IToken;
import org.overture.ast.expressions.AMapRangeUnaryExp;
import org.overture.ast.statements.AIdentifierStateDesignator;
import org.overture.ast.intf.lex.ILexToken;
import org.overture.ast.expressions.AFloorUnaryExp;
import org.overture.ast.definitions.AExplicitOperationDefinition;
import org.overture.ast.statements.AMapSeqStateDesignator;
import org.overture.ast.patterns.APatternListTypePair;
import org.overture.ast.patterns.AMapPattern;
import org.overture.ast.expressions.ASubsetBinaryExp;
import org.overture.ast.statements.AReturnStm;
import org.overture.ast.modules.SValueImport;
import org.overture.ast.expressions.AStarStarBinaryExp;
import org.overture.ast.types.PAccessSpecifier;
import org.overture.ast.modules.AFunctionValueImport;
import org.overture.ast.statements.AElseIfStm;
import org.overture.ast.modules.AOperationExport;
import org.overture.ast.types.ANatOneNumericBasicType;
import org.overture.ast.expressions.SBooleanBinaryExp;
import org.overture.ast.intf.lex.ILexStringToken;
import org.overture.ast.expressions.ADistIntersectUnaryExp;
import org.overture.ast.statements.SSimpleBlockStm;
import org.overture.ast.patterns.ARecordPattern;
import org.overture.ast.expressions.APlusNumericBinaryExp;
import org.overture.ast.modules.AValueValueImport;
import org.overture.ast.types.ANamedInvariantType;
import org.overture.ast.expressions.ACaseAlternative;
import org.overture.ast.types.ARecordInvariantType;
import org.overture.ast.types.ASeqSeqType;
import org.overture.ast.patterns.PMaplet;
import org.overture.ast.expressions.ASameClassExp;
import org.overture.ast.expressions.ASetIntersectBinaryExp;
import org.overture.ast.patterns.ABooleanPattern;
import org.overture.ast.expressions.AForAllExp;
import org.overture.ast.definitions.traces.ATraceDefinitionTerm;
import org.overture.ast.expressions.ASelfExp;
import org.overture.ast.statements.AForPatternBindStm;
import org.overture.ast.modules.PImports;
import org.overture.ast.statements.PObjectDesignator;
import org.overture.ast.expressions.ASubseqExp;
import org.overture.ast.types.AMapMapType;
import org.overture.ast.statements.ACallObjectStm;
import org.overture.ast.expressions.SNumericBinaryExp;
import org.overture.ast.definitions.PDefinition;
import org.overture.ast.expressions.ASeqConcatBinaryExp;
import org.overture.ast.statements.AAlwaysStm;
import org.overture.ast.expressions.APostOpExp;
import org.overture.ast.statements.PClause;
import org.overture.ast.types.ASeq1SeqType;
import org.overture.ast.definitions.ANamedTraceDefinition;
import org.overture.ast.expressions.ALessEqualNumericBinaryExp;
import org.overture.ast.statements.AAtomicStm;
import org.overture.ast.expressions.ARangeResToBinaryExp;
import org.overture.ast.expressions.ASetRangeSetExp;
import org.overture.ast.statements.ABlockSimpleBlockStm;
import org.overture.ast.definitions.SClassDefinition;
import org.overture.ast.types.ARationalNumericBasicType;
import org.overture.ast.statements.ATixeStmtAlternative;
import org.overture.ast.expressions.AFuncInstatiationExp;
import org.overture.ast.types.AProductType;
import org.overture.ast.statements.PCase;
import org.overture.ast.typechecker.Pass;
import org.overture.ast.expressions.AGreaterEqualNumericBinaryExp;
import org.overture.ast.types.AAccessSpecifierAccessSpecifier;
import org.overture.ast.statements.AExternalClause;
import java.lang.Boolean;
import java.util.LinkedList;
import org.overture.ast.definitions.AValueDefinition;
import org.overture.ast.definitions.traces.ABracketedExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AExistsExp;
import org.overture.ast.expressions.AThreadIdExp;
import org.overture.ast.expressions.ACompBinaryExp;
import org.overture.ast.expressions.ARealLiteralExp;
import org.overture.ast.statements.ATixeStm;
import org.overture.ast.definitions.traces.PTerm;
import org.overture.ast.intf.lex.ILexQuoteToken;
import org.overture.ast.expressions.ANotEqualBinaryExp;
import org.overture.ast.expressions.AElseIfExp;
import org.overture.ast.expressions.ASameBaseClassExp;
import org.overture.ast.types.PField;
import org.overture.ast.expressions.APowerSetUnaryExp;
import org.overture.ast.types.PType;
import org.overture.ast.patterns.AIgnorePattern;
import org.overture.ast.statements.AWhileStm;
import org.overture.ast.statements.AIfStm;
import org.overture.ast.statements.APeriodicStm;
import org.overture.ast.patterns.AMapUnionPattern;
import org.overture.ast.statements.ALetBeStStm;
import org.overture.ast.modules.AModuleImports;
import org.overture.ast.expressions.AIntLiteralExp;
import org.overture.ast.expressions.ATimesNumericBinaryExp;
import org.overture.ast.expressions.AMapEnumMapExp;
import org.overture.ast.expressions.AIfExp;
import org.overture.ast.patterns.ADefPatternBind;
import org.overture.ast.statements.ANewObjectDesignator;
import org.overture.ast.statements.AStartStm;
import org.overture.ast.statements.ANotYetSpecifiedStm;
import org.overture.ast.statements.AClassInvariantStm;
import org.overture.ast.expressions.AMkBasicExp;
import org.overture.ast.expressions.APreOpExp;
import org.overture.ast.modules.PExport;
import org.overture.ast.modules.ATypeExport;
import org.overture.ast.expressions.ADistMergeUnaryExp;
import org.overture.ast.definitions.AMutexSyncDefinition;
import org.overture.ast.definitions.SFunctionDefinition;
import org.overture.ast.definitions.AInheritedDefinition;
import java.util.Set;
import org.overture.ast.modules.AFunctionExport;
import org.overture.ast.patterns.AConcatenationPattern;
import org.overture.ast.expressions.ALenUnaryExp;
import org.overture.ast.expressions.AApplyExp;
import org.overture.ast.expressions.AFieldNumberExp;
import org.overture.ast.patterns.ASetMultipleBind;
import org.overture.ast.modules.AAllImport;
import org.overture.ast.modules.PExports;
import org.overture.ast.expressions.ANewExp;
import org.overture.ast.definitions.AMultiBindListDefinition;
import org.overture.ast.expressions.ADivideNumericBinaryExp;
import org.overture.ast.expressions.AVariableExp;
import org.overture.ast.expressions.ADomainResToBinaryExp;
import org.overture.ast.statements.ADurationStm;
import org.overture.ast.expressions.ASubclassResponsibilityExp;
import org.overture.ast.definitions.AUntypedDefinition;
import org.overture.ast.expressions.ASetDifferenceBinaryExp;
import org.overture.ast.expressions.AIsOfClassExp;
import org.overture.ast.expressions.ADivNumericBinaryExp;
import org.overture.ast.definitions.AImplicitOperationDefinition;
import org.overture.ast.patterns.AExpressionPattern;
import org.overture.ast.intf.lex.ILexIntegerToken;
import java.util.ArrayList;
import org.overture.ast.types.AFieldField;
import org.overture.ast.types.ATokenBasicType;
import org.overture.ast.expressions.AModNumericBinaryExp;
import java.lang.String;
import org.overture.ast.expressions.ANilExp;
import org.overture.ast.definitions.AClassClassDefinition;
import org.overture.ast.node.tokens.TAsync;
import org.overture.ast.expressions.ARangeResByBinaryExp;
import org.overture.ast.types.ABracketType;
import org.overture.ast.statements.AStopStm;
import org.overture.ast.expressions.ASeqCompSeqExp;
import org.overture.ast.expressions.AOrBooleanBinaryExp;
import org.overture.ast.definitions.AClassInvariantDefinition;
import org.overture.ast.expressions.AMkTypeExp;
import org.overture.ast.statements.AIdentifierObjectDesignator;
import org.overture.ast.expressions.AMapletExp;
import org.overture.ast.expressions.APreExp;
import org.overture.ast.expressions.AMapDomainUnaryExp;
import org.overture.ast.types.AInMapMapType;
import org.overture.ast.expressions.ASeqEnumSeqExp;
import org.overture.ast.definitions.ASystemClassDefinition;
import org.overture.ast.intf.lex.ILexLocation;
import org.overture.ast.expressions.AAndBooleanBinaryExp;
import org.overture.ast.types.AQuoteType;
import org.overture.ast.expressions.AQuoteLiteralExp;
import org.overture.ast.statements.AErrorStm;
import org.overture.ast.expressions.SSetExp;
import org.overture.ast.patterns.PBind;
import org.overture.ast.types.AOperationType;
import org.overture.ast.util.ClonableString;
import org.overture.ast.util.ClonableFile;
import org.overture.ast.expressions.ADistConcatUnaryExp;
import org.overture.ast.expressions.ANotInSetBinaryExp;
import org.overture.ast.types.SInvariantType;
import org.overture.ast.expressions.APlusPlusBinaryExp;
import org.overture.ast.expressions.AEquivalentBooleanBinaryExp;
import org.overture.ast.definitions.ALocalDefinition;
import org.overture.ast.modules.AAllExport;
import org.overture.ast.expressions.AIndicesUnaryExp;
import org.overture.ast.types.AIntNumericBasicType;
import org.overture.ast.definitions.AThreadDefinition;
import org.overture.ast.intf.lex.ILexNameToken;
import org.overture.ast.statements.ALetStm;
import org.overture.ast.types.AParameterType;
import org.overture.ast.node.INode;
import org.overture.ast.patterns.PPair;
import org.overture.ast.statements.ASporadicStm;
import org.overture.ast.statements.ATrapStm;
import org.overture.ast.intf.lex.ILexRealToken;
import org.overture.ast.definitions.ACpuClassDefinition;
import org.overture.ast.statements.AForIndexStm;
import org.overture.ast.patterns.ASeqPattern;
import org.overture.ast.modules.ATypeImport;
import org.overture.ast.types.SMapType;
import org.overture.ast.patterns.ATypeMultipleBind;
import org.overture.ast.definitions.AAssignmentDefinition;
import org.overture.ast.definitions.AImportedDefinition;
import org.overture.ast.intf.lex.ILexBooleanToken;
import org.overture.ast.expressions.ACharLiteralExp;
import org.overture.ast.expressions.ANarrowExp;
import org.overture.ast.analysis.AnalysisException;
import java.util.List;
import org.overture.ast.expressions.ANotUnaryExp;
import org.overture.ast.definitions.AProtectedAccess;
import org.overture.ast.definitions.SOperationDefinition;
import org.overture.ast.typechecker.NameScope;
import org.overture.ast.definitions.AExternalDefinition;
import org.overture.ast.expressions.AMuExp;
import org.overture.ast.expressions.SUnaryExp;
import org.overture.ast.expressions.AUnaryMinusUnaryExp;
import org.overture.ast.types.AClassType;
import org.overture.ast.statements.AExitStm;
import org.overture.ast.expressions.AReverseUnaryExp;
import org.overture.ast.statements.PStm;
import org.overture.ast.expressions.ASetUnionBinaryExp;
import org.overture.ast.expressions.ALambdaExp;
import org.overture.ast.modules.PImport;
import org.overture.ast.types.ANatNumericBasicType;
import org.overture.ast.definitions.traces.ARepeatTraceDefinition;
import org.overture.ast.expressions.ARemNumericBinaryExp;
import org.overture.ast.patterns.AIdentifierPattern;
import org.overture.ast.expressions.AHistoryExp;
import org.overture.ast.expressions.ALessNumericBinaryExp;
import org.overture.ast.patterns.ACharacterPattern;
import org.overture.ast.expressions.AStringLiteralExp;
import org.overture.ast.expressions.AEqualsBinaryExp;
import org.overture.ast.expressions.AMapCompMapExp;
import org.overture.ast.intf.lex.ILexCharacterToken;
import org.overture.ast.expressions.ATailUnaryExp;
import org.overture.ast.statements.ASkipStm;
import org.overture.ast.patterns.AQuotePattern;
import org.overture.ast.statements.PStateDesignator;
import org.overture.ast.statements.ASpecificationStm;
import org.overture.ast.expressions.ANotYetSpecifiedExp;
import org.overture.ast.definitions.traces.PTraceDefinition;
import org.overture.ast.modules.AModuleModules;
import org.overture.ast.types.SNumericBasicType;
import org.overture.ast.patterns.ASetPattern;
import org.overture.ast.definitions.AEqualsDefinition;
import org.overture.ast.types.ACharBasicType;
import org.overture.ast.modules.AFromModuleImports;
import org.overture.ast.statements.PAlternativeStm;
import org.overture.ast.definitions.traces.ALetDefBindingTraceDefinition;
import org.overture.ast.expressions.ADistUnionUnaryExp;
import org.overture.ast.expressions.AStateInitExp;
import org.overture.ast.patterns.ANilPattern;
import org.overture.ast.modules.AValueExport;
import org.overture.ast.expressions.ARecordModifier;
import org.overture.ast.expressions.AInSetBinaryExp;
import org.overture.ast.patterns.PPatternBind;
import org.overture.ast.statements.AErrorCase;
import org.overture.ast.definitions.AExplicitFunctionDefinition;
import org.overture.ast.patterns.APatternTypePair;
import org.overture.ast.expressions.PAlternative;


/**
* Generated file by AST Creator
* @author Kenneth Lausdahl
*
*/
@SuppressWarnings({"all"})
public abstract class DepthFirstAnalysisAdaptor implements IAnalysis
{
	private static final long serialVersionUID = 1L;

	protected Set<INode> _visitedNodes = new java.util.HashSet<INode>();
	final protected IAnalysis THIS;

	/**
	* Creates a new {@code DepthFirstAnalysisAdaptor} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param visitedNodes_ the {@link Set} node for the {@code visitedNodes} child of this {@link DepthFirstAnalysisAdaptor} node
	* @param THIS_ the {@link IAnalysis} <b>graph</a> node for the {@code THIS} child of this {@link DepthFirstAnalysisAdaptor} node.
	*  <i>The parent of this {@code THIS } will not be changed by adding it to this node.</i>
	*/
	public DepthFirstAnalysisAdaptor(Set<INode> visitedNodes_, IAnalysis THIS_)
	{
		super();
		this.setVisitedNodes(visitedNodes_);
		this.THIS = THIS_;

	}


	/**
	 * Creates a new {@link DepthFirstAnalysisAdaptor} node with no children.
	 */
	public DepthFirstAnalysisAdaptor()
	{
		this.THIS=this;

	}


	/**
	 * Sets the {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptor} node.
	 * @param value the new {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptor} node
	*/
	public void setVisitedNodes(Set<INode> value)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexToken(ILexToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexToken(node);


		outILexToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexToken(ILexToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexToken(ILexToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexNameToken(ILexNameToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexNameToken(node);


		outILexNameToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexNameToken(ILexNameToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexNameToken(ILexNameToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexIdentifierToken(ILexIdentifierToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexIdentifierToken(node);


		outILexIdentifierToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexIdentifierToken(ILexIdentifierToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexIdentifierToken(ILexIdentifierToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexBooleanToken(ILexBooleanToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexBooleanToken(node);


		outILexBooleanToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexBooleanToken(ILexBooleanToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexBooleanToken(ILexBooleanToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexCharacterToken(ILexCharacterToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexCharacterToken(node);


		outILexCharacterToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexCharacterToken(ILexCharacterToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexCharacterToken(ILexCharacterToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexIntegerToken(ILexIntegerToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexIntegerToken(node);


		outILexIntegerToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexIntegerToken(ILexIntegerToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexIntegerToken(ILexIntegerToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexQuoteToken(ILexQuoteToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexQuoteToken(node);


		outILexQuoteToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexQuoteToken(ILexQuoteToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexQuoteToken(ILexQuoteToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexRealToken(ILexRealToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexRealToken(node);


		outILexRealToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexRealToken(ILexRealToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexRealToken(ILexRealToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexStringToken(ILexStringToken node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inILexStringToken(node);


		outILexStringToken(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexStringToken(ILexStringToken node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexStringToken(ILexStringToken node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseILexLocation(ILexLocation node) throws AnalysisException
	{
		inILexLocation(node);


		outILexLocation(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inILexLocation(ILexLocation node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outILexLocation(ILexLocation node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClonableFile(ClonableFile node) throws AnalysisException
	{
		inClonableFile(node);


		outClonableFile(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClonableFile(ClonableFile node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClonableFile(ClonableFile node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClonableString(ClonableString node) throws AnalysisException
	{
		inClonableString(node);


		outClonableString(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClonableString(ClonableString node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClonableString(ClonableString node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseClassDefinitionSettings(ClassDefinitionSettings node) throws AnalysisException
	{
		inClassDefinitionSettings(node);


		outClassDefinitionSettings(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inClassDefinitionSettings(ClassDefinitionSettings node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outClassDefinitionSettings(ClassDefinitionSettings node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseNameScope(NameScope node) throws AnalysisException
	{
		inNameScope(node);


		outNameScope(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inNameScope(NameScope node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outNameScope(NameScope node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void casePass(Pass node) throws AnalysisException
	{
		inPass(node);


		outPass(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inPass(Pass node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outPass(Pass node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseBoolean(Boolean node) throws AnalysisException
	{
		inBoolean(node);


		outBoolean(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inBoolean(Boolean node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outBoolean(Boolean node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseInteger(Integer node) throws AnalysisException
	{
		inInteger(node);


		outInteger(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inInteger(Integer node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outInteger(Integer node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseString(String node) throws AnalysisException
	{
		inString(node);


		outString(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inString(String node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outString(String node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseLong(Long node) throws AnalysisException
	{
		inLong(node);


		outLong(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inLong(Long node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outLong(Long node) throws AnalysisException
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseTStatic(TStatic node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inTStatic(node);


		outTStatic(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inTStatic(TStatic node) throws AnalysisException
	{
		defaultInIToken(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outTStatic(TStatic node) throws AnalysisException
	{
		defaultOutIToken(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseTAsync(TAsync node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inTAsync(node);


		outTAsync(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inTAsync(TAsync node) throws AnalysisException
	{
		defaultInIToken(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outTAsync(TAsync node) throws AnalysisException
	{
		defaultOutIToken(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultInPExp(PExp node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultOutPExp(PExp node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultPExp(PExp node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void inPExp(PExp node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void outPExp(PExp node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void caseAApplyExp(AApplyExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getRoot() != null && !_visitedNodes.contains(node.getRoot())) 
		{
			node.getRoot().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgtypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getRecursive() != null && !_visitedNodes.contains(node.getRecursive())) 
		{
			node.getRecursive().apply(this);
		}

		outAApplyExp(node);

	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void inAApplyExp(AApplyExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public void outAApplyExp(AApplyExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void caseANarrowExp(ANarrowExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANarrowExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this);
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			node.getBasicType().apply(this);
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			node.getTypedef().apply(this);
		}

		outANarrowExp(node);

	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void inANarrowExp(ANarrowExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public void outANarrowExp(ANarrowExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultInSUnaryExp(SUnaryExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultOutSUnaryExp(SUnaryExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void defaultSUnaryExp(SUnaryExp node) throws AnalysisException
	{
		defaultPExp(node);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void inSUnaryExp(SUnaryExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public void outSUnaryExp(SUnaryExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultInSBinaryExp(SBinaryExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultOutSBinaryExp(SBinaryExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void defaultSBinaryExp(SBinaryExp node) throws AnalysisException
	{
		defaultPExp(node);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void inSBinaryExp(SBinaryExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public void outSBinaryExp(SBinaryExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void caseABooleanConstExp(ABooleanConstExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanConstExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outABooleanConstExp(node);

	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void inABooleanConstExp(ABooleanConstExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public void outABooleanConstExp(ABooleanConstExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void caseACasesExp(ACasesExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACasesExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		{
			List<ACaseAlternative> copy = new ArrayList<ACaseAlternative>(node.getCases());
			for( ACaseAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			node.getOthers().apply(this);
		}

		outACasesExp(node);

	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void inACasesExp(ACasesExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public void outACasesExp(ACasesExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void caseACharLiteralExp(ACharLiteralExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharLiteralExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outACharLiteralExp(node);

	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void inACharLiteralExp(ACharLiteralExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public void outACharLiteralExp(ACharLiteralExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void caseAElseIfExp(AElseIfExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElseIfExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			node.getElseIf().apply(this);
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			node.getThen().apply(this);
		}

		outAElseIfExp(node);

	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void inAElseIfExp(AElseIfExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public void outAElseIfExp(AElseIfExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void caseAExists1Exp(AExists1Exp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExists1Exp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outAExists1Exp(node);

	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void inAExists1Exp(AExists1Exp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public void outAExists1Exp(AExists1Exp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void caseAExistsExp(AExistsExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExistsExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outAExistsExp(node);

	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void inAExistsExp(AExistsExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public void outAExistsExp(AExistsExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void caseAFieldExp(AFieldExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this);
		}
		if(node.getMemberName() != null ) 
		{
			node.getMemberName().apply(this);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this);
		}

		outAFieldExp(node);

	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void inAFieldExp(AFieldExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public void outAFieldExp(AFieldExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void caseAFieldNumberExp(AFieldNumberExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldNumberExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTuple() != null && !_visitedNodes.contains(node.getTuple())) 
		{
			node.getTuple().apply(this);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this);
		}

		outAFieldNumberExp(node);

	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void inAFieldNumberExp(AFieldNumberExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public void outAFieldNumberExp(AFieldNumberExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void caseAForAllExp(AForAllExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForAllExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outAForAllExp(node);

	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void inAForAllExp(AForAllExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public void outAForAllExp(AForAllExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void caseAFuncInstatiationExp(AFuncInstatiationExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFuncInstatiationExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			node.getFunction().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getActualTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExpdef() != null && !_visitedNodes.contains(node.getExpdef())) 
		{
			node.getExpdef().apply(this);
		}
		if(node.getImpdef() != null && !_visitedNodes.contains(node.getImpdef())) 
		{
			node.getImpdef().apply(this);
		}

		outAFuncInstatiationExp(node);

	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void inAFuncInstatiationExp(AFuncInstatiationExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public void outAFuncInstatiationExp(AFuncInstatiationExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void caseAHistoryExp(AHistoryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAHistoryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getHop() != null ) 
		{
			node.getHop().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOpnames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}

		outAHistoryExp(node);

	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void inAHistoryExp(AHistoryExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public void outAHistoryExp(AHistoryExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void caseAIfExp(AIfExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIfExp(node);
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this);
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			node.getThen().apply(this);
		}
		{
			List<AElseIfExp> copy = new ArrayList<AElseIfExp>(node.getElseList());
			for( AElseIfExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getElse() != null && !_visitedNodes.contains(node.getElse())) 
		{
			node.getElse().apply(this);
		}

		outAIfExp(node);

	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void inAIfExp(AIfExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public void outAIfExp(AIfExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void caseAIntLiteralExp(AIntLiteralExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntLiteralExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAIntLiteralExp(node);

	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void inAIntLiteralExp(AIntLiteralExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public void outAIntLiteralExp(AIntLiteralExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void caseAIotaExp(AIotaExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIotaExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outAIotaExp(node);

	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void inAIotaExp(AIotaExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public void outAIotaExp(AIotaExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void caseAIsExp(AIsExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this);
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			node.getBasicType().apply(this);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this);
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			node.getTypedef().apply(this);
		}

		outAIsExp(node);

	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void inAIsExp(AIsExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public void outAIsExp(AIsExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void caseAIsOfBaseClassExp(AIsOfBaseClassExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsOfBaseClassExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBaseClass() != null ) 
		{
			node.getBaseClass().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAIsOfBaseClassExp(node);

	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void inAIsOfBaseClassExp(AIsOfBaseClassExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public void outAIsOfBaseClassExp(AIsOfBaseClassExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void caseAIsOfClassExp(AIsOfClassExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIsOfClassExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this);
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			node.getClassType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAIsOfClassExp(node);

	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void inAIsOfClassExp(AIsOfClassExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public void outAIsOfClassExp(AIsOfClassExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void caseALambdaExp(ALambdaExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALambdaExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ATypeBind> copy = new ArrayList<ATypeBind>(node.getBindList());
			for( ATypeBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParamPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getFunctionType() != null && !_visitedNodes.contains(node.getFunctionType())) 
		{
			node.getFunctionType().apply(this);
		}

		outALambdaExp(node);

	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void inALambdaExp(ALambdaExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public void outALambdaExp(ALambdaExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void caseALetBeStExp(ALetBeStExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			node.getSuchThat().apply(this);
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			node.getValue().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outALetBeStExp(node);

	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void inALetBeStExp(ALetBeStExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public void outALetBeStExp(ALetBeStExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void caseALetDefExp(ALetDefExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetDefExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outALetDefExp(node);

	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void inALetDefExp(ALetDefExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public void outALetDefExp(ALetDefExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void caseADefExp(ADefExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADefExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outADefExp(node);

	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void inADefExp(ADefExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public void outADefExp(ADefExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultInSMapExp(SMapExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultOutSMapExp(SMapExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void defaultSMapExp(SMapExp node) throws AnalysisException
	{
		defaultPExp(node);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void inSMapExp(SMapExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public void outSMapExp(SMapExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void caseAMapletExp(AMapletExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapletExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAMapletExp(node);

	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void inAMapletExp(AMapletExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public void outAMapletExp(AMapletExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void caseAMkBasicExp(AMkBasicExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMkBasicExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getArg() != null && !_visitedNodes.contains(node.getArg())) 
		{
			node.getArg().apply(this);
		}

		outAMkBasicExp(node);

	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void inAMkBasicExp(AMkBasicExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public void outAMkBasicExp(AMkBasicExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void caseAMkTypeExp(AMkTypeExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMkTypeExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTypeName() != null ) 
		{
			node.getTypeName().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAMkTypeExp(node);

	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void inAMkTypeExp(AMkTypeExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public void outAMkTypeExp(AMkTypeExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void caseAMuExp(AMuExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMuExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getRecord() != null && !_visitedNodes.contains(node.getRecord())) 
		{
			node.getRecord().apply(this);
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this);
		}
		{
			List<ARecordModifier> copy = new ArrayList<ARecordModifier>(node.getModifiers());
			for( ARecordModifier e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getModTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAMuExp(node);

	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void inAMuExp(AMuExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public void outAMuExp(AMuExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void caseANewExp(ANewExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANewExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			node.getClassdef().apply(this);
		}
		if(node.getCtorDefinition() != null && !_visitedNodes.contains(node.getCtorDefinition())) 
		{
			node.getCtorDefinition().apply(this);
		}

		outANewExp(node);

	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void inANewExp(ANewExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public void outANewExp(ANewExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void caseANilExp(ANilExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANilExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outANilExp(node);

	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void inANilExp(ANilExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public void outANilExp(ANilExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void caseANotYetSpecifiedExp(ANotYetSpecifiedExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotYetSpecifiedExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outANotYetSpecifiedExp(node);

	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void inANotYetSpecifiedExp(ANotYetSpecifiedExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public void outANotYetSpecifiedExp(ANotYetSpecifiedExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void caseAPostOpExp(APostOpExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPostOpExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		if(node.getPreexpression() != null && !_visitedNodes.contains(node.getPreexpression())) 
		{
			node.getPreexpression().apply(this);
		}
		if(node.getPostexpression() != null && !_visitedNodes.contains(node.getPostexpression())) 
		{
			node.getPostexpression().apply(this);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}

		outAPostOpExp(node);

	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void inAPostOpExp(APostOpExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public void outAPostOpExp(APostOpExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void caseAPreExp(APreExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPreExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			node.getFunction().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAPreExp(node);

	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void inAPreExp(APreExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public void outAPreExp(APreExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void caseAPreOpExp(APreOpExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPreOpExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}

		outAPreOpExp(node);

	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void inAPreOpExp(APreOpExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public void outAPreOpExp(APreOpExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void caseAQuoteLiteralExp(AQuoteLiteralExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuoteLiteralExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAQuoteLiteralExp(node);

	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void inAQuoteLiteralExp(AQuoteLiteralExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public void outAQuoteLiteralExp(AQuoteLiteralExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void caseARealLiteralExp(ARealLiteralExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealLiteralExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outARealLiteralExp(node);

	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void inARealLiteralExp(ARealLiteralExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public void outARealLiteralExp(ARealLiteralExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void caseASameBaseClassExp(ASameBaseClassExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASameBaseClassExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASameBaseClassExp(node);

	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void inASameBaseClassExp(ASameBaseClassExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public void outASameBaseClassExp(ASameBaseClassExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void caseASameClassExp(ASameClassExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASameClassExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASameClassExp(node);

	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void inASameClassExp(ASameClassExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public void outASameClassExp(ASameClassExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void caseASelfExp(ASelfExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASelfExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outASelfExp(node);

	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void inASelfExp(ASelfExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public void outASelfExp(ASelfExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultInSSeqExp(SSeqExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultOutSSeqExp(SSeqExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void defaultSSeqExp(SSeqExp node) throws AnalysisException
	{
		defaultPExp(node);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void inSSeqExp(SSeqExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public void outSSeqExp(SSeqExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultInSSetExp(SSetExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultOutSSetExp(SSetExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void defaultSSetExp(SSetExp node) throws AnalysisException
	{
		defaultPExp(node);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void inSSetExp(SSetExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public void outSSetExp(SSetExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void caseAStateInitExp(AStateInitExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStateInitExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}

		outAStateInitExp(node);

	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void inAStateInitExp(AStateInitExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public void outAStateInitExp(AStateInitExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void caseAStringLiteralExp(AStringLiteralExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStringLiteralExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAStringLiteralExp(node);

	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void inAStringLiteralExp(AStringLiteralExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public void outAStringLiteralExp(AStringLiteralExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void caseASubclassResponsibilityExp(ASubclassResponsibilityExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubclassResponsibilityExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outASubclassResponsibilityExp(node);

	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void inASubclassResponsibilityExp(ASubclassResponsibilityExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public void outASubclassResponsibilityExp(ASubclassResponsibilityExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void caseASubseqExp(ASubseqExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubseqExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getSeq() != null && !_visitedNodes.contains(node.getSeq())) 
		{
			node.getSeq().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this);
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			node.getFtype().apply(this);
		}
		if(node.getTtype() != null && !_visitedNodes.contains(node.getTtype())) 
		{
			node.getTtype().apply(this);
		}

		outASubseqExp(node);

	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void inASubseqExp(ASubseqExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public void outASubseqExp(ASubseqExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void caseAThreadIdExp(AThreadIdExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAThreadIdExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAThreadIdExp(node);

	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void inAThreadIdExp(AThreadIdExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public void outAThreadIdExp(AThreadIdExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void caseATimeExp(ATimeExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATimeExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outATimeExp(node);

	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void inATimeExp(ATimeExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public void outATimeExp(ATimeExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void caseATupleExp(ATupleExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATupleExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outATupleExp(node);

	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void inATupleExp(ATupleExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public void outATupleExp(ATupleExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void caseAUndefinedExp(AUndefinedExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUndefinedExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAUndefinedExp(node);

	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void inAUndefinedExp(AUndefinedExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public void outAUndefinedExp(AUndefinedExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void caseAVariableExp(AVariableExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVariableExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getVardef() != null && !_visitedNodes.contains(node.getVardef())) 
		{
			node.getVardef().apply(this);
		}

		outAVariableExp(node);

	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void inAVariableExp(AVariableExp node) throws AnalysisException
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public void outAVariableExp(AVariableExp node) throws AnalysisException
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void caseAAbsoluteUnaryExp(AAbsoluteUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAbsoluteUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAAbsoluteUnaryExp(node);

	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void inAAbsoluteUnaryExp(AAbsoluteUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public void outAAbsoluteUnaryExp(AAbsoluteUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void caseACardinalityUnaryExp(ACardinalityUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACardinalityUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outACardinalityUnaryExp(node);

	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void inACardinalityUnaryExp(ACardinalityUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public void outACardinalityUnaryExp(ACardinalityUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void caseADistConcatUnaryExp(ADistConcatUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistConcatUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outADistConcatUnaryExp(node);

	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void inADistConcatUnaryExp(ADistConcatUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public void outADistConcatUnaryExp(ADistConcatUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void caseADistIntersectUnaryExp(ADistIntersectUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistIntersectUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outADistIntersectUnaryExp(node);

	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void inADistIntersectUnaryExp(ADistIntersectUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public void outADistIntersectUnaryExp(ADistIntersectUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void caseADistMergeUnaryExp(ADistMergeUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistMergeUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outADistMergeUnaryExp(node);

	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void inADistMergeUnaryExp(ADistMergeUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public void outADistMergeUnaryExp(ADistMergeUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void caseADistUnionUnaryExp(ADistUnionUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADistUnionUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outADistUnionUnaryExp(node);

	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void inADistUnionUnaryExp(ADistUnionUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public void outADistUnionUnaryExp(ADistUnionUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void caseAElementsUnaryExp(AElementsUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElementsUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAElementsUnaryExp(node);

	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void inAElementsUnaryExp(AElementsUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public void outAElementsUnaryExp(AElementsUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void caseAFloorUnaryExp(AFloorUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFloorUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAFloorUnaryExp(node);

	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void inAFloorUnaryExp(AFloorUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public void outAFloorUnaryExp(AFloorUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void caseAHeadUnaryExp(AHeadUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAHeadUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAHeadUnaryExp(node);

	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void inAHeadUnaryExp(AHeadUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public void outAHeadUnaryExp(AHeadUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void caseAIndicesUnaryExp(AIndicesUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIndicesUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAIndicesUnaryExp(node);

	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void inAIndicesUnaryExp(AIndicesUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public void outAIndicesUnaryExp(AIndicesUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void caseALenUnaryExp(ALenUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALenUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outALenUnaryExp(node);

	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void inALenUnaryExp(ALenUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public void outALenUnaryExp(ALenUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void caseAMapDomainUnaryExp(AMapDomainUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapDomainUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAMapDomainUnaryExp(node);

	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void inAMapDomainUnaryExp(AMapDomainUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public void outAMapDomainUnaryExp(AMapDomainUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void caseAMapInverseUnaryExp(AMapInverseUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapInverseUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this);
		}

		outAMapInverseUnaryExp(node);

	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void inAMapInverseUnaryExp(AMapInverseUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public void outAMapInverseUnaryExp(AMapInverseUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void caseAMapRangeUnaryExp(AMapRangeUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapRangeUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAMapRangeUnaryExp(node);

	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void inAMapRangeUnaryExp(AMapRangeUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public void outAMapRangeUnaryExp(AMapRangeUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void caseANotUnaryExp(ANotUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outANotUnaryExp(node);

	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void inANotUnaryExp(ANotUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public void outANotUnaryExp(ANotUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void caseAPowerSetUnaryExp(APowerSetUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPowerSetUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAPowerSetUnaryExp(node);

	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void inAPowerSetUnaryExp(APowerSetUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public void outAPowerSetUnaryExp(APowerSetUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void caseAReverseUnaryExp(AReverseUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAReverseUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAReverseUnaryExp(node);

	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void inAReverseUnaryExp(AReverseUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public void outAReverseUnaryExp(AReverseUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void caseATailUnaryExp(ATailUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATailUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outATailUnaryExp(node);

	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void inATailUnaryExp(ATailUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public void outATailUnaryExp(ATailUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void caseAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnaryMinusUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAUnaryMinusUnaryExp(node);

	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void inAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public void outAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void caseAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnaryPlusUnaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAUnaryPlusUnaryExp(node);

	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void inAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node) throws AnalysisException
	{
		defaultInSUnaryExp(node);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public void outAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node) throws AnalysisException
	{
		defaultOutSUnaryExp(node);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultInSBooleanBinaryExp(SBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultOutSBooleanBinaryExp(SBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void defaultSBooleanBinaryExp(SBooleanBinaryExp node) throws AnalysisException
	{
		defaultSBinaryExp(node);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void inSBooleanBinaryExp(SBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public void outSBooleanBinaryExp(SBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void caseACompBinaryExp(ACompBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACompBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outACompBinaryExp(node);

	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void inACompBinaryExp(ACompBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public void outACompBinaryExp(ACompBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void caseADomainResByBinaryExp(ADomainResByBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADomainResByBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outADomainResByBinaryExp(node);

	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void inADomainResByBinaryExp(ADomainResByBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public void outADomainResByBinaryExp(ADomainResByBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void caseADomainResToBinaryExp(ADomainResToBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADomainResToBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outADomainResToBinaryExp(node);

	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void inADomainResToBinaryExp(ADomainResToBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public void outADomainResToBinaryExp(ADomainResToBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void caseAEqualsBinaryExp(AEqualsBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEqualsBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAEqualsBinaryExp(node);

	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void inAEqualsBinaryExp(AEqualsBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public void outAEqualsBinaryExp(AEqualsBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void caseAInSetBinaryExp(AInSetBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInSetBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAInSetBinaryExp(node);

	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void inAInSetBinaryExp(AInSetBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public void outAInSetBinaryExp(AInSetBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void caseAMapUnionBinaryExp(AMapUnionBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapUnionBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAMapUnionBinaryExp(node);

	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void inAMapUnionBinaryExp(AMapUnionBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public void outAMapUnionBinaryExp(AMapUnionBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void caseANotEqualBinaryExp(ANotEqualBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotEqualBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outANotEqualBinaryExp(node);

	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void inANotEqualBinaryExp(ANotEqualBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public void outANotEqualBinaryExp(ANotEqualBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void caseANotInSetBinaryExp(ANotInSetBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotInSetBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outANotInSetBinaryExp(node);

	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void inANotInSetBinaryExp(ANotInSetBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public void outANotInSetBinaryExp(ANotInSetBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultInSNumericBinaryExp(SNumericBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultOutSNumericBinaryExp(SNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void defaultSNumericBinaryExp(SNumericBinaryExp node) throws AnalysisException
	{
		defaultSBinaryExp(node);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void inSNumericBinaryExp(SNumericBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public void outSNumericBinaryExp(SNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void caseAPlusPlusBinaryExp(APlusPlusBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPlusPlusBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAPlusPlusBinaryExp(node);

	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void inAPlusPlusBinaryExp(APlusPlusBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public void outAPlusPlusBinaryExp(APlusPlusBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void caseAProperSubsetBinaryExp(AProperSubsetBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProperSubsetBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAProperSubsetBinaryExp(node);

	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void inAProperSubsetBinaryExp(AProperSubsetBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public void outAProperSubsetBinaryExp(AProperSubsetBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void caseARangeResByBinaryExp(ARangeResByBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARangeResByBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outARangeResByBinaryExp(node);

	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void inARangeResByBinaryExp(ARangeResByBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public void outARangeResByBinaryExp(ARangeResByBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void caseARangeResToBinaryExp(ARangeResToBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARangeResToBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outARangeResToBinaryExp(node);

	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void inARangeResToBinaryExp(ARangeResToBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public void outARangeResToBinaryExp(ARangeResToBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void caseASeqConcatBinaryExp(ASeqConcatBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqConcatBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASeqConcatBinaryExp(node);

	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void inASeqConcatBinaryExp(ASeqConcatBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public void outASeqConcatBinaryExp(ASeqConcatBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void caseASetDifferenceBinaryExp(ASetDifferenceBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetDifferenceBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASetDifferenceBinaryExp(node);

	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void inASetDifferenceBinaryExp(ASetDifferenceBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public void outASetDifferenceBinaryExp(ASetDifferenceBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void caseASetIntersectBinaryExp(ASetIntersectBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetIntersectBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASetIntersectBinaryExp(node);

	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void inASetIntersectBinaryExp(ASetIntersectBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public void outASetIntersectBinaryExp(ASetIntersectBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void caseASetUnionBinaryExp(ASetUnionBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetUnionBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASetUnionBinaryExp(node);

	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void inASetUnionBinaryExp(ASetUnionBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public void outASetUnionBinaryExp(ASetUnionBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void caseAStarStarBinaryExp(AStarStarBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStarStarBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAStarStarBinaryExp(node);

	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void inAStarStarBinaryExp(AStarStarBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public void outAStarStarBinaryExp(AStarStarBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void caseASubsetBinaryExp(ASubsetBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubsetBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASubsetBinaryExp(node);

	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void inASubsetBinaryExp(ASubsetBinaryExp node) throws AnalysisException
	{
		defaultInSBinaryExp(node);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public void outASubsetBinaryExp(ASubsetBinaryExp node) throws AnalysisException
	{
		defaultOutSBinaryExp(node);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void caseAAndBooleanBinaryExp(AAndBooleanBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAndBooleanBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAAndBooleanBinaryExp(node);

	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void inAAndBooleanBinaryExp(AAndBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public void outAAndBooleanBinaryExp(AAndBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void caseAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEquivalentBooleanBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAEquivalentBooleanBinaryExp(node);

	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void inAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public void outAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void caseAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImpliesBooleanBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAImpliesBooleanBinaryExp(node);

	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void inAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public void outAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void caseAOrBooleanBinaryExp(AOrBooleanBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOrBooleanBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAOrBooleanBinaryExp(node);

	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void inAOrBooleanBinaryExp(AOrBooleanBinaryExp node) throws AnalysisException
	{
		defaultInSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public void outAOrBooleanBinaryExp(AOrBooleanBinaryExp node) throws AnalysisException
	{
		defaultOutSBooleanBinaryExp(node);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void caseADivNumericBinaryExp(ADivNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADivNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outADivNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void inADivNumericBinaryExp(ADivNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public void outADivNumericBinaryExp(ADivNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void caseADivideNumericBinaryExp(ADivideNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADivideNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outADivideNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void inADivideNumericBinaryExp(ADivideNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public void outADivideNumericBinaryExp(ADivideNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void caseAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAGreaterEqualNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAGreaterEqualNumericBinaryExp(node);

	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void inAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public void outAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void caseAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAGreaterNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAGreaterNumericBinaryExp(node);

	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void inAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public void outAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void caseALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALessEqualNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outALessEqualNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void inALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public void outALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void caseALessNumericBinaryExp(ALessNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALessNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outALessNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void inALessNumericBinaryExp(ALessNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public void outALessNumericBinaryExp(ALessNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void caseAModNumericBinaryExp(AModNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAModNumericBinaryExp(node);

	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void inAModNumericBinaryExp(AModNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public void outAModNumericBinaryExp(AModNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void caseAPlusNumericBinaryExp(APlusNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPlusNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAPlusNumericBinaryExp(node);

	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void inAPlusNumericBinaryExp(APlusNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public void outAPlusNumericBinaryExp(APlusNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void caseARemNumericBinaryExp(ARemNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARemNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outARemNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void inARemNumericBinaryExp(ARemNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public void outARemNumericBinaryExp(ARemNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void caseASubtractNumericBinaryExp(ASubtractNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubtractNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outASubtractNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void inASubtractNumericBinaryExp(ASubtractNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public void outASubtractNumericBinaryExp(ASubtractNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void caseATimesNumericBinaryExp(ATimesNumericBinaryExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATimesNumericBinaryExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getOp() != null ) 
		{
			node.getOp().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outATimesNumericBinaryExp(node);

	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void inATimesNumericBinaryExp(ATimesNumericBinaryExp node) throws AnalysisException
	{
		defaultInSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public void outATimesNumericBinaryExp(ATimesNumericBinaryExp node) throws AnalysisException
	{
		defaultOutSNumericBinaryExp(node);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void caseAMapCompMapExp(AMapCompMapExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapCompMapExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outAMapCompMapExp(node);

	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void inAMapCompMapExp(AMapCompMapExp node) throws AnalysisException
	{
		defaultInSMapExp(node);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public void outAMapCompMapExp(AMapCompMapExp node) throws AnalysisException
	{
		defaultOutSMapExp(node);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void caseAMapEnumMapExp(AMapEnumMapExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapEnumMapExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<AMapletExp> copy = new ArrayList<AMapletExp>(node.getMembers());
			for( AMapletExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getDomTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getRngTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAMapEnumMapExp(node);

	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void inAMapEnumMapExp(AMapEnumMapExp node) throws AnalysisException
	{
		defaultInSMapExp(node);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public void outAMapEnumMapExp(AMapEnumMapExp node) throws AnalysisException
	{
		defaultOutSMapExp(node);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void caseASeqCompSeqExp(ASeqCompSeqExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqCompSeqExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this);
		}
		if(node.getSetBind() != null && !_visitedNodes.contains(node.getSetBind())) 
		{
			node.getSetBind().apply(this);
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outASeqCompSeqExp(node);

	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void inASeqCompSeqExp(ASeqCompSeqExp node) throws AnalysisException
	{
		defaultInSSeqExp(node);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public void outASeqCompSeqExp(ASeqCompSeqExp node) throws AnalysisException
	{
		defaultOutSSeqExp(node);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void caseASeqEnumSeqExp(ASeqEnumSeqExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqEnumSeqExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASeqEnumSeqExp(node);

	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void inASeqEnumSeqExp(ASeqEnumSeqExp node) throws AnalysisException
	{
		defaultInSSeqExp(node);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public void outASeqEnumSeqExp(ASeqEnumSeqExp node) throws AnalysisException
	{
		defaultOutSSeqExp(node);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void caseASetCompSetExp(ASetCompSetExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetCompSetExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			node.getPredicate().apply(this);
		}

		outASetCompSetExp(node);

	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void inASetCompSetExp(ASetCompSetExp node) throws AnalysisException
	{
		defaultInSSetExp(node);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public void outASetCompSetExp(ASetCompSetExp node) throws AnalysisException
	{
		defaultOutSSetExp(node);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void caseASetEnumSetExp(ASetEnumSetExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetEnumSetExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASetEnumSetExp(node);

	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void inASetEnumSetExp(ASetEnumSetExp node) throws AnalysisException
	{
		defaultInSSetExp(node);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public void outASetEnumSetExp(ASetEnumSetExp node) throws AnalysisException
	{
		defaultOutSSetExp(node);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void caseASetRangeSetExp(ASetRangeSetExp node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetRangeSetExp(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this);
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			node.getFirst().apply(this);
		}
		if(node.getLast() != null && !_visitedNodes.contains(node.getLast())) 
		{
			node.getLast().apply(this);
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			node.getFtype().apply(this);
		}
		if(node.getLtype() != null && !_visitedNodes.contains(node.getLtype())) 
		{
			node.getLtype().apply(this);
		}

		outASetRangeSetExp(node);

	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void inASetRangeSetExp(ASetRangeSetExp node) throws AnalysisException
	{
		defaultInSSetExp(node);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public void outASetRangeSetExp(ASetRangeSetExp node) throws AnalysisException
	{
		defaultOutSSetExp(node);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultInPModifier(PModifier node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultOutPModifier(PModifier node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void defaultPModifier(PModifier node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void inPModifier(PModifier node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public void outPModifier(PModifier node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void caseARecordModifier(ARecordModifier node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordModifier(node);

		if(node.getTag() != null ) 
		{
			node.getTag().apply(this);
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			node.getValue().apply(this);
		}

		outARecordModifier(node);

	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void inARecordModifier(ARecordModifier node) throws AnalysisException
	{
		defaultInPModifier(node);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public void outARecordModifier(ARecordModifier node) throws AnalysisException
	{
		defaultOutPModifier(node);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultInPAlternative(PAlternative node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultOutPAlternative(PAlternative node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void defaultPAlternative(PAlternative node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void inPAlternative(PAlternative node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public void outPAlternative(PAlternative node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void caseACaseAlternative(ACaseAlternative node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACaseAlternative(node);

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			node.getCexp().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}

		outACaseAlternative(node);

	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void inACaseAlternative(ACaseAlternative node) throws AnalysisException
	{
		defaultInPAlternative(node);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public void outACaseAlternative(ACaseAlternative node) throws AnalysisException
	{
		defaultOutPAlternative(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultInPType(PType node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultOutPType(PType node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultPType(PType node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void inPType(PType node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void outPType(PType node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultInSBasicType(SBasicType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultOutSBasicType(SBasicType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void defaultSBasicType(SBasicType node) throws AnalysisException
	{
		defaultPType(node);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void inSBasicType(SBasicType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public void outSBasicType(SBasicType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void caseABracketType(ABracketType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABracketType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outABracketType(node);

	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void inABracketType(ABracketType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public void outABracketType(ABracketType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void caseAClassType(AClassType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			node.getClassdef().apply(this);
		}

		outAClassType(node);

	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void inAClassType(AClassType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public void outAClassType(AClassType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void caseAFunctionType(AFunctionType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}

		outAFunctionType(node);

	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void inAFunctionType(AFunctionType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public void outAFunctionType(AFunctionType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultInSInvariantType(SInvariantType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultOutSInvariantType(SInvariantType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void defaultSInvariantType(SInvariantType node) throws AnalysisException
	{
		defaultPType(node);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void inSInvariantType(SInvariantType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public void outSInvariantType(SInvariantType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultInSMapType(SMapType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultOutSMapType(SMapType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void defaultSMapType(SMapType node) throws AnalysisException
	{
		defaultPType(node);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void inSMapType(SMapType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public void outSMapType(SMapType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void caseAOperationType(AOperationType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}

		outAOperationType(node);

	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void inAOperationType(AOperationType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public void outAOperationType(AOperationType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void caseAOptionalType(AOptionalType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOptionalType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAOptionalType(node);

	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void inAOptionalType(AOptionalType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public void outAOptionalType(AOptionalType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void caseAParameterType(AParameterType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAParameterType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outAParameterType(node);

	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void inAParameterType(AParameterType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public void outAParameterType(AParameterType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void caseAProductType(AProductType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProductType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAProductType(node);

	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void inAProductType(AProductType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public void outAProductType(AProductType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void caseAQuoteType(AQuoteType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuoteType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAQuoteType(node);

	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void inAQuoteType(AQuoteType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public void outAQuoteType(AQuoteType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultInSSeqType(SSeqType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultOutSSeqType(SSeqType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void defaultSSeqType(SSeqType node) throws AnalysisException
	{
		defaultPType(node);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void inSSeqType(SSeqType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public void outSSeqType(SSeqType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void caseASetType(ASetType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getSetof() != null && !_visitedNodes.contains(node.getSetof())) 
		{
			node.getSetof().apply(this);
		}

		outASetType(node);

	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void inASetType(ASetType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public void outASetType(ASetType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void caseAUndefinedType(AUndefinedType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUndefinedType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAUndefinedType(node);

	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void inAUndefinedType(AUndefinedType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public void outAUndefinedType(AUndefinedType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void caseAUnionType(AUnionType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnionType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this);
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			node.getSetType().apply(this);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this);
		}
		if(node.getProdType() != null && !_visitedNodes.contains(node.getProdType())) 
		{
			node.getProdType().apply(this);
		}
		if(node.getFuncType() != null && !_visitedNodes.contains(node.getFuncType())) 
		{
			node.getFuncType().apply(this);
		}
		if(node.getOpType() != null && !_visitedNodes.contains(node.getOpType())) 
		{
			node.getOpType().apply(this);
		}
		if(node.getNumType() != null && !_visitedNodes.contains(node.getNumType())) 
		{
			node.getNumType().apply(this);
		}
		if(node.getRecType() != null && !_visitedNodes.contains(node.getRecType())) 
		{
			node.getRecType().apply(this);
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			node.getClassType().apply(this);
		}

		outAUnionType(node);

	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void inAUnionType(AUnionType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public void outAUnionType(AUnionType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void caseAUnknownType(AUnknownType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnknownType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAUnknownType(node);

	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void inAUnknownType(AUnknownType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public void outAUnknownType(AUnknownType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void caseAUnresolvedType(AUnresolvedType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnresolvedType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outAUnresolvedType(node);

	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void inAUnresolvedType(AUnresolvedType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public void outAUnresolvedType(AUnresolvedType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void caseAVoidReturnType(AVoidReturnType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVoidReturnType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAVoidReturnType(node);

	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void inAVoidReturnType(AVoidReturnType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public void outAVoidReturnType(AVoidReturnType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void caseAVoidType(AVoidType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAVoidType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAVoidType(node);

	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void inAVoidType(AVoidType node) throws AnalysisException
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public void outAVoidType(AVoidType node) throws AnalysisException
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void caseASeqSeqType(ASeqSeqType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqSeqType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			node.getSeqof().apply(this);
		}

		outASeqSeqType(node);

	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void inASeqSeqType(ASeqSeqType node) throws AnalysisException
	{
		defaultInSSeqType(node);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public void outASeqSeqType(ASeqSeqType node) throws AnalysisException
	{
		defaultOutSSeqType(node);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void caseASeq1SeqType(ASeq1SeqType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeq1SeqType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			node.getSeqof().apply(this);
		}

		outASeq1SeqType(node);

	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void inASeq1SeqType(ASeq1SeqType node) throws AnalysisException
	{
		defaultInSSeqType(node);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public void outASeq1SeqType(ASeq1SeqType node) throws AnalysisException
	{
		defaultOutSSeqType(node);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void caseAInMapMapType(AInMapMapType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInMapMapType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this);
		}

		outAInMapMapType(node);

	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void inAInMapMapType(AInMapMapType node) throws AnalysisException
	{
		defaultInSMapType(node);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public void outAInMapMapType(AInMapMapType node) throws AnalysisException
	{
		defaultOutSMapType(node);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void caseAMapMapType(AMapMapType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapMapType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this);
		}

		outAMapMapType(node);

	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void inAMapMapType(AMapMapType node) throws AnalysisException
	{
		defaultInSMapType(node);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public void outAMapMapType(AMapMapType node) throws AnalysisException
	{
		defaultOutSMapType(node);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void caseANamedInvariantType(ANamedInvariantType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamedInvariantType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			node.getInvDef().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outANamedInvariantType(node);

	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void inANamedInvariantType(ANamedInvariantType node) throws AnalysisException
	{
		defaultInSInvariantType(node);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public void outANamedInvariantType(ANamedInvariantType node) throws AnalysisException
	{
		defaultOutSInvariantType(node);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void caseARecordInvariantType(ARecordInvariantType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordInvariantType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			node.getInvDef().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outARecordInvariantType(node);

	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void inARecordInvariantType(ARecordInvariantType node) throws AnalysisException
	{
		defaultInSInvariantType(node);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public void outARecordInvariantType(ARecordInvariantType node) throws AnalysisException
	{
		defaultOutSInvariantType(node);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void caseABooleanBasicType(ABooleanBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outABooleanBasicType(node);

	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void inABooleanBasicType(ABooleanBasicType node) throws AnalysisException
	{
		defaultInSBasicType(node);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public void outABooleanBasicType(ABooleanBasicType node) throws AnalysisException
	{
		defaultOutSBasicType(node);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void caseACharBasicType(ACharBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outACharBasicType(node);

	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void inACharBasicType(ACharBasicType node) throws AnalysisException
	{
		defaultInSBasicType(node);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public void outACharBasicType(ACharBasicType node) throws AnalysisException
	{
		defaultOutSBasicType(node);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultInSNumericBasicType(SNumericBasicType node) throws AnalysisException
	{
		defaultInSBasicType(node);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultOutSNumericBasicType(SNumericBasicType node) throws AnalysisException
	{
		defaultOutSBasicType(node);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void defaultSNumericBasicType(SNumericBasicType node) throws AnalysisException
	{
		defaultSBasicType(node);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void inSNumericBasicType(SNumericBasicType node) throws AnalysisException
	{
		defaultInSBasicType(node);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public void outSNumericBasicType(SNumericBasicType node) throws AnalysisException
	{
		defaultOutSBasicType(node);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void caseATokenBasicType(ATokenBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATokenBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outATokenBasicType(node);

	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void inATokenBasicType(ATokenBasicType node) throws AnalysisException
	{
		defaultInSBasicType(node);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public void outATokenBasicType(ATokenBasicType node) throws AnalysisException
	{
		defaultOutSBasicType(node);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void caseAIntNumericBasicType(AIntNumericBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntNumericBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAIntNumericBasicType(node);

	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void inAIntNumericBasicType(AIntNumericBasicType node) throws AnalysisException
	{
		defaultInSNumericBasicType(node);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public void outAIntNumericBasicType(AIntNumericBasicType node) throws AnalysisException
	{
		defaultOutSNumericBasicType(node);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void caseANatOneNumericBasicType(ANatOneNumericBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANatOneNumericBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANatOneNumericBasicType(node);

	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void inANatOneNumericBasicType(ANatOneNumericBasicType node) throws AnalysisException
	{
		defaultInSNumericBasicType(node);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public void outANatOneNumericBasicType(ANatOneNumericBasicType node) throws AnalysisException
	{
		defaultOutSNumericBasicType(node);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void caseANatNumericBasicType(ANatNumericBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANatNumericBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANatNumericBasicType(node);

	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void inANatNumericBasicType(ANatNumericBasicType node) throws AnalysisException
	{
		defaultInSNumericBasicType(node);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public void outANatNumericBasicType(ANatNumericBasicType node) throws AnalysisException
	{
		defaultOutSNumericBasicType(node);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void caseARationalNumericBasicType(ARationalNumericBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARationalNumericBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outARationalNumericBasicType(node);

	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void inARationalNumericBasicType(ARationalNumericBasicType node) throws AnalysisException
	{
		defaultInSNumericBasicType(node);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public void outARationalNumericBasicType(ARationalNumericBasicType node) throws AnalysisException
	{
		defaultOutSNumericBasicType(node);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void caseARealNumericBasicType(ARealNumericBasicType node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealNumericBasicType(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outARealNumericBasicType(node);

	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void inARealNumericBasicType(ARealNumericBasicType node) throws AnalysisException
	{
		defaultInSNumericBasicType(node);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public void outARealNumericBasicType(ARealNumericBasicType node) throws AnalysisException
	{
		defaultOutSNumericBasicType(node);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultInPField(PField node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultOutPField(PField node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void defaultPField(PField node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void inPField(PField node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public void outPField(PField node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void caseAFieldField(AFieldField node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldField(node);

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getTagname() != null ) 
		{
			node.getTagname().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAFieldField(node);

	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void inAFieldField(AFieldField node) throws AnalysisException
	{
		defaultInPField(node);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public void outAFieldField(AFieldField node) throws AnalysisException
	{
		defaultOutPField(node);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultInPAccessSpecifier(PAccessSpecifier node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultOutPAccessSpecifier(PAccessSpecifier node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void defaultPAccessSpecifier(PAccessSpecifier node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void inPAccessSpecifier(PAccessSpecifier node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public void outPAccessSpecifier(PAccessSpecifier node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void caseAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAccessSpecifierAccessSpecifier(node);

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getStatic() != null && !_visitedNodes.contains(node.getStatic())) 
		{
			node.getStatic().apply(this);
		}
		if(node.getAsync() != null && !_visitedNodes.contains(node.getAsync())) 
		{
			node.getAsync().apply(this);
		}

		outAAccessSpecifierAccessSpecifier(node);

	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void inAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node) throws AnalysisException
	{
		defaultInPAccessSpecifier(node);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public void outAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node) throws AnalysisException
	{
		defaultOutPAccessSpecifier(node);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultInPAccess(PAccess node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultOutPAccess(PAccess node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void defaultPAccess(PAccess node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void inPAccess(PAccess node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public void outPAccess(PAccess node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void caseAPublicAccess(APublicAccess node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPublicAccess(node);


		outAPublicAccess(node);

	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void inAPublicAccess(APublicAccess node) throws AnalysisException
	{
		defaultInPAccess(node);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public void outAPublicAccess(APublicAccess node) throws AnalysisException
	{
		defaultOutPAccess(node);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void caseAProtectedAccess(AProtectedAccess node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAProtectedAccess(node);


		outAProtectedAccess(node);

	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void inAProtectedAccess(AProtectedAccess node) throws AnalysisException
	{
		defaultInPAccess(node);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public void outAProtectedAccess(AProtectedAccess node) throws AnalysisException
	{
		defaultOutPAccess(node);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void caseAPrivateAccess(APrivateAccess node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPrivateAccess(node);


		outAPrivateAccess(node);

	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void inAPrivateAccess(APrivateAccess node) throws AnalysisException
	{
		defaultInPAccess(node);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public void outAPrivateAccess(APrivateAccess node) throws AnalysisException
	{
		defaultOutPAccess(node);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultInPPattern(PPattern node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultOutPPattern(PPattern node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void defaultPPattern(PPattern node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void inPPattern(PPattern node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public void outPPattern(PPattern node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void caseABooleanPattern(ABooleanPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABooleanPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outABooleanPattern(node);

	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void inABooleanPattern(ABooleanPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public void outABooleanPattern(ABooleanPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void caseACharacterPattern(ACharacterPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACharacterPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outACharacterPattern(node);

	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void inACharacterPattern(ACharacterPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public void outACharacterPattern(ACharacterPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void caseAConcatenationPattern(AConcatenationPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAConcatenationPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAConcatenationPattern(node);

	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void inAConcatenationPattern(AConcatenationPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public void outAConcatenationPattern(AConcatenationPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void caseAExpressionPattern(AExpressionPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExpressionPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outAExpressionPattern(node);

	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void inAExpressionPattern(AExpressionPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public void outAExpressionPattern(AExpressionPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void caseAIdentifierPattern(AIdentifierPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outAIdentifierPattern(node);

	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void inAIdentifierPattern(AIdentifierPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public void outAIdentifierPattern(AIdentifierPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void caseAIgnorePattern(AIgnorePattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIgnorePattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getAnyName() != null ) 
		{
			node.getAnyName().apply(this);
		}

		outAIgnorePattern(node);

	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void inAIgnorePattern(AIgnorePattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public void outAIgnorePattern(AIgnorePattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void caseAIntegerPattern(AIntegerPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIntegerPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAIntegerPattern(node);

	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void inAIntegerPattern(AIntegerPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public void outAIntegerPattern(AIntegerPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void caseANilPattern(ANilPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANilPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANilPattern(node);

	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void inANilPattern(ANilPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public void outANilPattern(ANilPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void caseAQuotePattern(AQuotePattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAQuotePattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAQuotePattern(node);

	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void inAQuotePattern(AQuotePattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public void outAQuotePattern(AQuotePattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void caseARealPattern(ARealPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARealPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outARealPattern(node);

	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void inARealPattern(ARealPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public void outARealPattern(ARealPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void caseARecordPattern(ARecordPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARecordPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getTypename() != null ) 
		{
			node.getTypename().apply(this);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outARecordPattern(node);

	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void inARecordPattern(ARecordPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public void outARecordPattern(ARecordPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void caseASeqPattern(ASeqPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASeqPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASeqPattern(node);

	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void inASeqPattern(ASeqPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public void outASeqPattern(ASeqPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void caseASetPattern(ASetPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASetPattern(node);

	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void inASetPattern(ASetPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public void outASetPattern(ASetPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void caseAStringPattern(AStringPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStringPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getValue() != null ) 
		{
			node.getValue().apply(this);
		}

		outAStringPattern(node);

	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void inAStringPattern(AStringPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public void outAStringPattern(AStringPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void caseATuplePattern(ATuplePattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATuplePattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outATuplePattern(node);

	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void inATuplePattern(ATuplePattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public void outATuplePattern(ATuplePattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void caseAUnionPattern(AUnionPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUnionPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAUnionPattern(node);

	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void inAUnionPattern(AUnionPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public void outAUnionPattern(AUnionPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void caseAMapPattern(AMapPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<AMapletPatternMaplet> copy = new ArrayList<AMapletPatternMaplet>(node.getMaplets());
			for( AMapletPatternMaplet e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAMapPattern(node);

	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void inAMapPattern(AMapPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public void outAMapPattern(AMapPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void caseAMapUnionPattern(AMapUnionPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapUnionPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAMapUnionPattern(node);

	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void inAMapUnionPattern(AMapUnionPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public void outAMapUnionPattern(AMapUnionPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void caseAObjectPattern(AObjectPattern node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAObjectPattern(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClassname() != null ) 
		{
			node.getClassname().apply(this);
		}
		{
			List<ANamePatternPair> copy = new ArrayList<ANamePatternPair>(node.getFields());
			for( ANamePatternPair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAObjectPattern(node);

	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void inAObjectPattern(AObjectPattern node) throws AnalysisException
	{
		defaultInPPattern(node);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public void outAObjectPattern(AObjectPattern node) throws AnalysisException
	{
		defaultOutPPattern(node);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultInPMaplet(PMaplet node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultOutPMaplet(PMaplet node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void defaultPMaplet(PMaplet node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void inPMaplet(PMaplet node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public void outPMaplet(PMaplet node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void caseAMapletPatternMaplet(AMapletPatternMaplet node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapletPatternMaplet(node);

		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this);
		}

		outAMapletPatternMaplet(node);

	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void inAMapletPatternMaplet(AMapletPatternMaplet node) throws AnalysisException
	{
		defaultInPMaplet(node);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public void outAMapletPatternMaplet(AMapletPatternMaplet node) throws AnalysisException
	{
		defaultOutPMaplet(node);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultInPPair(PPair node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultOutPPair(PPair node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void defaultPPair(PPair node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void inPPair(PPair node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public void outPPair(PPair node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void caseAPatternTypePair(APatternTypePair node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPatternTypePair(node);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAPatternTypePair(node);

	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void inAPatternTypePair(APatternTypePair node) throws AnalysisException
	{
		defaultInPPair(node);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public void outAPatternTypePair(APatternTypePair node) throws AnalysisException
	{
		defaultOutPPair(node);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void caseAPatternListTypePair(APatternListTypePair node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPatternListTypePair(node);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAPatternListTypePair(node);

	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void inAPatternListTypePair(APatternListTypePair node) throws AnalysisException
	{
		defaultInPPair(node);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public void outAPatternListTypePair(APatternListTypePair node) throws AnalysisException
	{
		defaultOutPPair(node);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void caseANamePatternPair(ANamePatternPair node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamePatternPair(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}

		outANamePatternPair(node);

	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void inANamePatternPair(ANamePatternPair node) throws AnalysisException
	{
		defaultInPPair(node);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public void outANamePatternPair(ANamePatternPair node) throws AnalysisException
	{
		defaultOutPPair(node);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultInPBind(PBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultOutPBind(PBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void defaultPBind(PBind node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void inPBind(PBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public void outPBind(PBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void caseASetBind(ASetBind node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetBind(node);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this);
		}

		outASetBind(node);

	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void inASetBind(ASetBind node) throws AnalysisException
	{
		defaultInPBind(node);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public void outASetBind(ASetBind node) throws AnalysisException
	{
		defaultOutPBind(node);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void caseATypeBind(ATypeBind node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeBind(node);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outATypeBind(node);

	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void inATypeBind(ATypeBind node) throws AnalysisException
	{
		defaultInPBind(node);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public void outATypeBind(ATypeBind node) throws AnalysisException
	{
		defaultOutPBind(node);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultInPMultipleBind(PMultipleBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultOutPMultipleBind(PMultipleBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void defaultPMultipleBind(PMultipleBind node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void inPMultipleBind(PMultipleBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public void outPMultipleBind(PMultipleBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void caseASetMultipleBind(ASetMultipleBind node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASetMultipleBind(node);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this);
		}

		outASetMultipleBind(node);

	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void inASetMultipleBind(ASetMultipleBind node) throws AnalysisException
	{
		defaultInPMultipleBind(node);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public void outASetMultipleBind(ASetMultipleBind node) throws AnalysisException
	{
		defaultOutPMultipleBind(node);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void caseATypeMultipleBind(ATypeMultipleBind node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeMultipleBind(node);

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outATypeMultipleBind(node);

	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void inATypeMultipleBind(ATypeMultipleBind node) throws AnalysisException
	{
		defaultInPMultipleBind(node);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public void outATypeMultipleBind(ATypeMultipleBind node) throws AnalysisException
	{
		defaultOutPMultipleBind(node);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultInPPatternBind(PPatternBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultOutPPatternBind(PPatternBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void defaultPPatternBind(PPatternBind node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void inPPatternBind(PPatternBind node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public void outPPatternBind(PPatternBind node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void caseADefPatternBind(ADefPatternBind node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADefPatternBind(node);

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outADefPatternBind(node);

	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void inADefPatternBind(ADefPatternBind node) throws AnalysisException
	{
		defaultInPPatternBind(node);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public void outADefPatternBind(ADefPatternBind node) throws AnalysisException
	{
		defaultOutPPatternBind(node);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultInPDefinition(PDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultOutPDefinition(PDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void defaultPDefinition(PDefinition node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void inPDefinition(PDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public void outPDefinition(PDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void caseAAssignmentDefinition(AAssignmentDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAssignmentDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}

		outAAssignmentDefinition(node);

	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void inAAssignmentDefinition(AAssignmentDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public void outAAssignmentDefinition(AAssignmentDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void caseAInstanceVariableDefinition(AInstanceVariableDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInstanceVariableDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this);
		}

		outAInstanceVariableDefinition(node);

	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void inAInstanceVariableDefinition(AInstanceVariableDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public void outAInstanceVariableDefinition(AInstanceVariableDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultInSClassDefinition(SClassDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultOutSClassDefinition(SClassDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void defaultSClassDefinition(SClassDefinition node) throws AnalysisException
	{
		defaultPDefinition(node);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void inSClassDefinition(SClassDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public void outSClassDefinition(SClassDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void caseAClassInvariantDefinition(AClassInvariantDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassInvariantDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outAClassInvariantDefinition(node);

	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void inAClassInvariantDefinition(AClassInvariantDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public void outAClassInvariantDefinition(AClassInvariantDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void caseAEqualsDefinition(AEqualsDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAEqualsDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getTypebind() != null && !_visitedNodes.contains(node.getTypebind())) 
		{
			node.getTypebind().apply(this);
		}
		if(node.getSetbind() != null && !_visitedNodes.contains(node.getSetbind())) 
		{
			node.getSetbind().apply(this);
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			node.getTest().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}
		if(node.getDefType() != null && !_visitedNodes.contains(node.getDefType())) 
		{
			node.getDefType().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAEqualsDefinition(node);

	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void inAEqualsDefinition(AEqualsDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public void outAEqualsDefinition(AEqualsDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultInSFunctionDefinition(SFunctionDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultOutSFunctionDefinition(SFunctionDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void defaultSFunctionDefinition(SFunctionDefinition node) throws AnalysisException
	{
		defaultPDefinition(node);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void inSFunctionDefinition(SFunctionDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public void outSFunctionDefinition(SFunctionDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void caseAExternalDefinition(AExternalDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExternalDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this);
		}

		outAExternalDefinition(node);

	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void inAExternalDefinition(AExternalDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public void outAExternalDefinition(AExternalDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultInSOperationDefinition(SOperationDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultOutSOperationDefinition(SOperationDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void defaultSOperationDefinition(SOperationDefinition node) throws AnalysisException
	{
		defaultPDefinition(node);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void inSOperationDefinition(SOperationDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public void outSOperationDefinition(SOperationDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void caseAImportedDefinition(AImportedDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImportedDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outAImportedDefinition(node);

	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void inAImportedDefinition(AImportedDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public void outAImportedDefinition(AImportedDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void caseAInheritedDefinition(AInheritedDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInheritedDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getSuperdef() != null && !_visitedNodes.contains(node.getSuperdef())) 
		{
			node.getSuperdef().apply(this);
		}
		if(node.getOldname() != null ) 
		{
			node.getOldname().apply(this);
		}

		outAInheritedDefinition(node);

	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void inAInheritedDefinition(AInheritedDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public void outAInheritedDefinition(AInheritedDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void caseALocalDefinition(ALocalDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALocalDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outALocalDefinition(node);

	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void inALocalDefinition(ALocalDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public void outALocalDefinition(ALocalDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void caseAMultiBindListDefinition(AMultiBindListDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMultiBindListDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAMultiBindListDefinition(node);

	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void inAMultiBindListDefinition(AMultiBindListDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public void outAMultiBindListDefinition(AMultiBindListDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void caseAMutexSyncDefinition(AMutexSyncDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMutexSyncDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOperations());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}

		outAMutexSyncDefinition(node);

	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void inAMutexSyncDefinition(AMutexSyncDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public void outAMutexSyncDefinition(AMutexSyncDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void caseANamedTraceDefinition(ANamedTraceDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANamedTraceDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANamedTraceDefinition(node);

	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void inANamedTraceDefinition(ANamedTraceDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public void outANamedTraceDefinition(ANamedTraceDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void caseAPerSyncDefinition(APerSyncDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPerSyncDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		if(node.getGuard() != null && !_visitedNodes.contains(node.getGuard())) 
		{
			node.getGuard().apply(this);
		}

		outAPerSyncDefinition(node);

	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void inAPerSyncDefinition(APerSyncDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public void outAPerSyncDefinition(APerSyncDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void caseARenamedDefinition(ARenamedDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARenamedDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outARenamedDefinition(node);

	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void inARenamedDefinition(ARenamedDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public void outARenamedDefinition(ARenamedDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void caseAStateDefinition(AStateDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStateDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			node.getInvPattern().apply(this);
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			node.getInvExpression().apply(this);
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			node.getInvdef().apply(this);
		}
		if(node.getInitPattern() != null && !_visitedNodes.contains(node.getInitPattern())) 
		{
			node.getInitPattern().apply(this);
		}
		if(node.getInitExpression() != null && !_visitedNodes.contains(node.getInitExpression())) 
		{
			node.getInitExpression().apply(this);
		}
		if(node.getInitdef() != null && !_visitedNodes.contains(node.getInitdef())) 
		{
			node.getInitdef().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getStateDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getRecordDefinition() != null && !_visitedNodes.contains(node.getRecordDefinition())) 
		{
			node.getRecordDefinition().apply(this);
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			node.getRecordType().apply(this);
		}

		outAStateDefinition(node);

	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void inAStateDefinition(AStateDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public void outAStateDefinition(AStateDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void caseAThreadDefinition(AThreadDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAThreadDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}
		if(node.getOperationName() != null ) 
		{
			node.getOperationName().apply(this);
		}
		if(node.getOperationDef() != null && !_visitedNodes.contains(node.getOperationDef())) 
		{
			node.getOperationDef().apply(this);
		}

		outAThreadDefinition(node);

	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void inAThreadDefinition(AThreadDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public void outAThreadDefinition(AThreadDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void caseATypeDefinition(ATypeDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getInvType() != null && !_visitedNodes.contains(node.getInvType())) 
		{
			node.getInvType().apply(this);
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			node.getInvPattern().apply(this);
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			node.getInvExpression().apply(this);
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			node.getInvdef().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getComposeDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outATypeDefinition(node);

	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void inATypeDefinition(ATypeDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public void outATypeDefinition(ATypeDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void caseAUntypedDefinition(AUntypedDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAUntypedDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAUntypedDefinition(node);

	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void inAUntypedDefinition(AUntypedDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public void outAUntypedDefinition(AUntypedDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void caseAValueDefinition(AValueDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}

		outAValueDefinition(node);

	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void inAValueDefinition(AValueDefinition node) throws AnalysisException
	{
		defaultInPDefinition(node);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public void outAValueDefinition(AValueDefinition node) throws AnalysisException
	{
		defaultOutPDefinition(node);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void caseAExplicitFunctionDefinition(AExplicitFunctionDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExplicitFunctionDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this);
		}
		if(node.getMeasure() != null ) 
		{
			node.getMeasure().apply(this);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this);
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			node.getMeasureDef().apply(this);
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			node.getExpectedResult().apply(this);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this);
		}
		{
			List<List<PPattern>> copy = new ArrayList<List<PPattern>>(node.getParamPatternList());
			for( List<PPattern> list : copy) {
				for( PPattern e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this);
					}
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitionList());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAExplicitFunctionDefinition(node);

	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void inAExplicitFunctionDefinition(AExplicitFunctionDefinition node) throws AnalysisException
	{
		defaultInSFunctionDefinition(node);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public void outAExplicitFunctionDefinition(AExplicitFunctionDefinition node) throws AnalysisException
	{
		defaultOutSFunctionDefinition(node);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void caseAImplicitFunctionDefinition(AImplicitFunctionDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImplicitFunctionDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this);
		}
		if(node.getMeasure() != null ) 
		{
			node.getMeasure().apply(this);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this);
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			node.getMeasureDef().apply(this);
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			node.getExpectedResult().apply(this);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this);
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParamPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAImplicitFunctionDefinition(node);

	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void inAImplicitFunctionDefinition(AImplicitFunctionDefinition node) throws AnalysisException
	{
		defaultInSFunctionDefinition(node);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public void outAImplicitFunctionDefinition(AImplicitFunctionDefinition node) throws AnalysisException
	{
		defaultOutSFunctionDefinition(node);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void caseAExplicitOperationDefinition(AExplicitOperationDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExplicitOperationDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this);
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParameterPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAExplicitOperationDefinition(node);

	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void inAExplicitOperationDefinition(AExplicitOperationDefinition node) throws AnalysisException
	{
		defaultInSOperationDefinition(node);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public void outAExplicitOperationDefinition(AExplicitOperationDefinition node) throws AnalysisException
	{
		defaultOutSOperationDefinition(node);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void caseAImplicitOperationDefinition(AImplicitOperationDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAImplicitOperationDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this);
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			node.getPredef().apply(this);
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			node.getPostdef().apply(this);
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			node.getState().apply(this);
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			node.getActualResult().apply(this);
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParameterPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			node.getStateDefinition().apply(this);
		}

		outAImplicitOperationDefinition(node);

	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void inAImplicitOperationDefinition(AImplicitOperationDefinition node) throws AnalysisException
	{
		defaultInSOperationDefinition(node);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public void outAImplicitOperationDefinition(AImplicitOperationDefinition node) throws AnalysisException
	{
		defaultOutSOperationDefinition(node);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultInPTerm(PTerm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultOutPTerm(PTerm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void defaultPTerm(PTerm node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void inPTerm(PTerm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public void outPTerm(PTerm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void caseATraceDefinitionTerm(ATraceDefinitionTerm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATraceDefinitionTerm(node);

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getList());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outATraceDefinitionTerm(node);

	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void inATraceDefinitionTerm(ATraceDefinitionTerm node) throws AnalysisException
	{
		defaultInPTerm(node);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public void outATraceDefinitionTerm(ATraceDefinitionTerm node) throws AnalysisException
	{
		defaultOutPTerm(node);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultInPTraceDefinition(PTraceDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultOutPTraceDefinition(PTraceDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void defaultPTraceDefinition(PTraceDefinition node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void inPTraceDefinition(PTraceDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public void outPTraceDefinition(PTraceDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void caseAInstanceTraceDefinition(AInstanceTraceDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAInstanceTraceDefinition(node);


		outAInstanceTraceDefinition(node);

	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void inAInstanceTraceDefinition(AInstanceTraceDefinition node) throws AnalysisException
	{
		defaultInPTraceDefinition(node);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public void outAInstanceTraceDefinition(AInstanceTraceDefinition node) throws AnalysisException
	{
		defaultOutPTraceDefinition(node);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void caseALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStBindingTraceDefinition(node);

		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		if(node.getStexp() != null && !_visitedNodes.contains(node.getStexp())) 
		{
			node.getStexp().apply(this);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outALetBeStBindingTraceDefinition(node);

	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void inALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node) throws AnalysisException
	{
		defaultInPTraceDefinition(node);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public void outALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node) throws AnalysisException
	{
		defaultOutPTraceDefinition(node);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void caseALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetDefBindingTraceDefinition(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}

		outALetDefBindingTraceDefinition(node);

	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void inALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node) throws AnalysisException
	{
		defaultInPTraceDefinition(node);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public void outALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node) throws AnalysisException
	{
		defaultOutPTraceDefinition(node);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void caseARepeatTraceDefinition(ARepeatTraceDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inARepeatTraceDefinition(node);

		if(node.getCore() != null && !_visitedNodes.contains(node.getCore())) 
		{
			node.getCore().apply(this);
		}

		outARepeatTraceDefinition(node);

	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void inARepeatTraceDefinition(ARepeatTraceDefinition node) throws AnalysisException
	{
		defaultInPTraceDefinition(node);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public void outARepeatTraceDefinition(ARepeatTraceDefinition node) throws AnalysisException
	{
		defaultOutPTraceDefinition(node);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultInPTraceCoreDefinition(PTraceCoreDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultOutPTraceCoreDefinition(PTraceCoreDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void defaultPTraceCoreDefinition(PTraceCoreDefinition node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void inPTraceCoreDefinition(PTraceCoreDefinition node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public void outPTraceCoreDefinition(PTraceCoreDefinition node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void caseAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyExpressionTraceCoreDefinition(node);

		if(node.getCallStatement() != null && !_visitedNodes.contains(node.getCallStatement())) 
		{
			node.getCallStatement().apply(this);
		}

		outAApplyExpressionTraceCoreDefinition(node);

	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void inAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public void outAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void caseABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABracketedExpressionTraceCoreDefinition(node);

		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outABracketedExpressionTraceCoreDefinition(node);

	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void inABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public void outABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void caseAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAConcurrentExpressionTraceCoreDefinition(node);

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getDefs());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAConcurrentExpressionTraceCoreDefinition(node);

	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void inAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultInPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public void outAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node) throws AnalysisException
	{
		defaultOutPTraceCoreDefinition(node);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void caseABusClassDefinition(ABusClassDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABusClassDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this);
		}
		if(node.getInstance() != null && !_visitedNodes.contains(node.getInstance())) 
		{
			node.getInstance().apply(this);
		}

		outABusClassDefinition(node);

	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void inABusClassDefinition(ABusClassDefinition node) throws AnalysisException
	{
		defaultInSClassDefinition(node);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public void outABusClassDefinition(ABusClassDefinition node) throws AnalysisException
	{
		defaultOutSClassDefinition(node);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void caseACpuClassDefinition(ACpuClassDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACpuClassDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this);
		}

		outACpuClassDefinition(node);

	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void inACpuClassDefinition(ACpuClassDefinition node) throws AnalysisException
	{
		defaultInSClassDefinition(node);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public void outACpuClassDefinition(ACpuClassDefinition node) throws AnalysisException
	{
		defaultOutSClassDefinition(node);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void caseASystemClassDefinition(ASystemClassDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASystemClassDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this);
		}

		outASystemClassDefinition(node);

	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void inASystemClassDefinition(ASystemClassDefinition node) throws AnalysisException
	{
		defaultInSClassDefinition(node);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public void outASystemClassDefinition(ASystemClassDefinition node) throws AnalysisException
	{
		defaultOutSClassDefinition(node);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void caseAClassClassDefinition(AClassClassDefinition node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassClassDefinition(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			node.getAccess().apply(this);
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			node.getClasstype().apply(this);
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			node.getInvariant().apply(this);
		}

		outAClassClassDefinition(node);

	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void inAClassClassDefinition(AClassClassDefinition node) throws AnalysisException
	{
		defaultInSClassDefinition(node);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public void outAClassClassDefinition(AClassClassDefinition node) throws AnalysisException
	{
		defaultOutSClassDefinition(node);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultInPModules(PModules node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultOutPModules(PModules node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void defaultPModules(PModules node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void inPModules(PModules node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public void outPModules(PModules node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void caseAModuleModules(AModuleModules node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleModules(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getImports() != null && !_visitedNodes.contains(node.getImports())) 
		{
			node.getImports().apply(this);
		}
		if(node.getExports() != null && !_visitedNodes.contains(node.getExports())) 
		{
			node.getExports().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getImportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getExportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAModuleModules(node);

	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void inAModuleModules(AModuleModules node) throws AnalysisException
	{
		defaultInPModules(node);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public void outAModuleModules(AModuleModules node) throws AnalysisException
	{
		defaultOutPModules(node);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultInPImports(PImports node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultOutPImports(PImports node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void defaultPImports(PImports node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void inPImports(PImports node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public void outPImports(PImports node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void caseAModuleImports(AModuleImports node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleImports(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<AFromModuleImports> copy = new ArrayList<AFromModuleImports>(node.getImports());
			for( AFromModuleImports e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAModuleImports(node);

	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void inAModuleImports(AModuleImports node) throws AnalysisException
	{
		defaultInPImports(node);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public void outAModuleImports(AModuleImports node) throws AnalysisException
	{
		defaultOutPImports(node);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void caseAFromModuleImports(AFromModuleImports node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFromModuleImports(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<List<PImport>> copy = new ArrayList<List<PImport>>(node.getSignatures());
			for( List<PImport> list : copy) {
				for( PImport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this);
					}
				}
			}
		}

		outAFromModuleImports(node);

	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void inAFromModuleImports(AFromModuleImports node) throws AnalysisException
	{
		defaultInPImports(node);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public void outAFromModuleImports(AFromModuleImports node) throws AnalysisException
	{
		defaultOutPImports(node);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultInPImport(PImport node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultOutPImport(PImport node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void defaultPImport(PImport node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void inPImport(PImport node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public void outPImport(PImport node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void caseAAllImport(AAllImport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAllImport(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}

		outAAllImport(node);

	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void inAAllImport(AAllImport node) throws AnalysisException
	{
		defaultInPImport(node);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public void outAAllImport(AAllImport node) throws AnalysisException
	{
		defaultOutPImport(node);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void caseATypeImport(ATypeImport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeImport(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outATypeImport(node);

	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void inATypeImport(ATypeImport node) throws AnalysisException
	{
		defaultInPImport(node);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public void outATypeImport(ATypeImport node) throws AnalysisException
	{
		defaultOutPImport(node);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultInSValueImport(SValueImport node) throws AnalysisException
	{
		defaultInPImport(node);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultOutSValueImport(SValueImport node) throws AnalysisException
	{
		defaultOutPImport(node);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void defaultSValueImport(SValueImport node) throws AnalysisException
	{
		defaultPImport(node);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void inSValueImport(SValueImport node) throws AnalysisException
	{
		defaultInPImport(node);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public void outSValueImport(SValueImport node) throws AnalysisException
	{
		defaultOutPImport(node);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void caseAValueValueImport(AValueValueImport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueValueImport(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this);
		}

		outAValueValueImport(node);

	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void inAValueValueImport(AValueValueImport node) throws AnalysisException
	{
		defaultInSValueImport(node);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public void outAValueValueImport(AValueValueImport node) throws AnalysisException
	{
		defaultOutSValueImport(node);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void caseAFunctionValueImport(AFunctionValueImport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionValueImport(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}

		outAFunctionValueImport(node);

	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void inAFunctionValueImport(AFunctionValueImport node) throws AnalysisException
	{
		defaultInSValueImport(node);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public void outAFunctionValueImport(AFunctionValueImport node) throws AnalysisException
	{
		defaultOutSValueImport(node);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void caseAOperationValueImport(AOperationValueImport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationValueImport(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getRenamed() != null ) 
		{
			node.getRenamed().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			node.getImportType().apply(this);
		}

		outAOperationValueImport(node);

	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void inAOperationValueImport(AOperationValueImport node) throws AnalysisException
	{
		defaultInSValueImport(node);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public void outAOperationValueImport(AOperationValueImport node) throws AnalysisException
	{
		defaultOutSValueImport(node);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultInPExports(PExports node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultOutPExports(PExports node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void defaultPExports(PExports node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void inPExports(PExports node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public void outPExports(PExports node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void caseAModuleExports(AModuleExports node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAModuleExports(node);

		{
			List<List<PExport>> copy = new ArrayList<List<PExport>>(node.getExports());
			for( List<PExport> list : copy) {
				for( PExport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						e.apply(this);
					}
				}
			}
		}

		outAModuleExports(node);

	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void inAModuleExports(AModuleExports node) throws AnalysisException
	{
		defaultInPExports(node);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public void outAModuleExports(AModuleExports node) throws AnalysisException
	{
		defaultOutPExports(node);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultInPExport(PExport node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultOutPExport(PExport node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void defaultPExport(PExport node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void inPExport(PExport node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public void outPExport(PExport node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void caseAAllExport(AAllExport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAllExport(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAAllExport(node);

	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void inAAllExport(AAllExport node) throws AnalysisException
	{
		defaultInPExport(node);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public void outAAllExport(AAllExport node) throws AnalysisException
	{
		defaultOutPExport(node);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void caseAFunctionExport(AFunctionExport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFunctionExport(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this);
		}

		outAFunctionExport(node);

	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void inAFunctionExport(AFunctionExport node) throws AnalysisException
	{
		defaultInPExport(node);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public void outAFunctionExport(AFunctionExport node) throws AnalysisException
	{
		defaultOutPExport(node);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void caseAOperationExport(AOperationExport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAOperationExport(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this);
		}

		outAOperationExport(node);

	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void inAOperationExport(AOperationExport node) throws AnalysisException
	{
		defaultInPExport(node);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public void outAOperationExport(AOperationExport node) throws AnalysisException
	{
		defaultOutPExport(node);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void caseATypeExport(ATypeExport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATypeExport(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outATypeExport(node);

	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void inATypeExport(ATypeExport node) throws AnalysisException
	{
		defaultInPExport(node);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public void outATypeExport(ATypeExport node) throws AnalysisException
	{
		defaultOutPExport(node);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void caseAValueExport(AValueExport node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAValueExport(node);

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			node.getExportType().apply(this);
		}

		outAValueExport(node);

	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void inAValueExport(AValueExport node) throws AnalysisException
	{
		defaultInPExport(node);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public void outAValueExport(AValueExport node) throws AnalysisException
	{
		defaultOutPExport(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultInPStm(PStm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultOutPStm(PStm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultPStm(PStm node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void inPStm(PStm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void outPStm(PStm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void caseAAlwaysStm(AAlwaysStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAlwaysStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getAlways() != null && !_visitedNodes.contains(node.getAlways())) 
		{
			node.getAlways().apply(this);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}

		outAAlwaysStm(node);

	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void inAAlwaysStm(AAlwaysStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public void outAAlwaysStm(AAlwaysStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void caseAAssignmentStm(AAssignmentStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAssignmentStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getTarget() != null && !_visitedNodes.contains(node.getTarget())) 
		{
			node.getTarget().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		if(node.getTargetType() != null && !_visitedNodes.contains(node.getTargetType())) 
		{
			node.getTargetType().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			node.getClassDefinition().apply(this);
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			node.getStateDefinition().apply(this);
		}

		outAAssignmentStm(node);

	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void inAAssignmentStm(AAssignmentStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public void outAAssignmentStm(AAssignmentStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void caseAAtomicStm(AAtomicStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAAtomicStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<AAssignmentStm> copy = new ArrayList<AAssignmentStm>(node.getAssignments());
			for( AAssignmentStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getStatedef() != null && !_visitedNodes.contains(node.getStatedef())) 
		{
			node.getStatedef().apply(this);
		}

		outAAtomicStm(node);

	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void inAAtomicStm(AAtomicStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public void outAAtomicStm(AAtomicStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void caseACallObjectStm(ACallObjectStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACallObjectStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getDesignator() != null && !_visitedNodes.contains(node.getDesignator())) 
		{
			node.getDesignator().apply(this);
		}
		if(node.getClassname() != null ) 
		{
			node.getClassname().apply(this);
		}
		if(node.getFieldname() != null ) 
		{
			node.getFieldname().apply(this);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outACallObjectStm(node);

	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void inACallObjectStm(ACallObjectStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public void outACallObjectStm(ACallObjectStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void caseACallStm(ACallStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACallStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getRootdef() != null && !_visitedNodes.contains(node.getRootdef())) 
		{
			node.getRootdef().apply(this);
		}

		outACallStm(node);

	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void inACallStm(ACallStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public void outACallStm(ACallStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void caseACasesStm(ACasesStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACasesStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		{
			List<ACaseAlternativeStm> copy = new ArrayList<ACaseAlternativeStm>(node.getCases());
			for( ACaseAlternativeStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			node.getOthers().apply(this);
		}

		outACasesStm(node);

	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void inACasesStm(ACasesStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public void outACasesStm(ACasesStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void caseAClassInvariantStm(AClassInvariantStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAClassInvariantStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getInvDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAClassInvariantStm(node);

	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void inAClassInvariantStm(AClassInvariantStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public void outAClassInvariantStm(AClassInvariantStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void caseACyclesStm(ACyclesStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACyclesStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getCycles() != null && !_visitedNodes.contains(node.getCycles())) 
		{
			node.getCycles().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outACyclesStm(node);

	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void inACyclesStm(ACyclesStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public void outACyclesStm(ACyclesStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void caseADurationStm(ADurationStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inADurationStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getDuration() != null && !_visitedNodes.contains(node.getDuration())) 
		{
			node.getDuration().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outADurationStm(node);

	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void inADurationStm(ADurationStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public void outADurationStm(ADurationStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void caseAElseIfStm(AElseIfStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAElseIfStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			node.getElseIf().apply(this);
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			node.getThenStm().apply(this);
		}

		outAElseIfStm(node);

	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void inAElseIfStm(AElseIfStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public void outAElseIfStm(AElseIfStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void caseAErrorStm(AErrorStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAErrorStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAErrorStm(node);

	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void inAErrorStm(AErrorStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public void outAErrorStm(AErrorStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void caseAExitStm(AExitStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExitStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			node.getExpType().apply(this);
		}

		outAExitStm(node);

	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void inAExitStm(AExitStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public void outAExitStm(AExitStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void caseAForAllStm(AForAllStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForAllStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			node.getSet().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outAForAllStm(node);

	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void inAForAllStm(AForAllStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public void outAForAllStm(AForAllStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void caseAForIndexStm(AForIndexStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForIndexStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getVar() != null ) 
		{
			node.getVar().apply(this);
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			node.getFrom().apply(this);
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			node.getTo().apply(this);
		}
		if(node.getBy() != null && !_visitedNodes.contains(node.getBy())) 
		{
			node.getBy().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outAForIndexStm(node);

	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void inAForIndexStm(AForIndexStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public void outAForIndexStm(AForIndexStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void caseAForPatternBindStm(AForPatternBindStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAForPatternBindStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this);
		}

		outAForPatternBindStm(node);

	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void inAForPatternBindStm(AForPatternBindStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public void outAForPatternBindStm(AForPatternBindStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void caseAIfStm(AIfStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIfStm(node);
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getIfExp() != null && !_visitedNodes.contains(node.getIfExp())) 
		{
			node.getIfExp().apply(this);
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			node.getThenStm().apply(this);
		}
		{
			List<AElseIfStm> copy = new ArrayList<AElseIfStm>(node.getElseIf());
			for( AElseIfStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getElseStm() != null && !_visitedNodes.contains(node.getElseStm())) 
		{
			node.getElseStm().apply(this);
		}

		outAIfStm(node);

	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void inAIfStm(AIfStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public void outAIfStm(AIfStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void caseALetBeStStm(ALetBeStStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetBeStStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			node.getBind().apply(this);
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			node.getSuchThat().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			node.getDef().apply(this);
		}

		outALetBeStStm(node);

	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void inALetBeStStm(ALetBeStStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public void outALetBeStStm(ALetBeStStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void caseALetStm(ALetStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inALetStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outALetStm(node);

	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void inALetStm(ALetStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public void outALetStm(ALetStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void caseANotYetSpecifiedStm(ANotYetSpecifiedStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANotYetSpecifiedStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANotYetSpecifiedStm(node);

	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void inANotYetSpecifiedStm(ANotYetSpecifiedStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public void outANotYetSpecifiedStm(ANotYetSpecifiedStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void caseAReturnStm(AReturnStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAReturnStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outAReturnStm(node);

	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void inAReturnStm(AReturnStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public void outAReturnStm(AReturnStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultInSSimpleBlockStm(SSimpleBlockStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultOutSSimpleBlockStm(SSimpleBlockStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void defaultSSimpleBlockStm(SSimpleBlockStm node) throws AnalysisException
	{
		defaultPStm(node);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void inSSimpleBlockStm(SSimpleBlockStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public void outSSimpleBlockStm(SSimpleBlockStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void caseASkipStm(ASkipStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASkipStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outASkipStm(node);

	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void inASkipStm(ASkipStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public void outASkipStm(ASkipStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void caseASpecificationStm(ASpecificationStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASpecificationStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			node.getPrecondition().apply(this);
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			node.getPostcondition().apply(this);
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASpecificationStm(node);

	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void inASpecificationStm(ASpecificationStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public void outASpecificationStm(ASpecificationStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void caseAStartStm(AStartStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStartStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			node.getObj().apply(this);
		}

		outAStartStm(node);

	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void inAStartStm(AStartStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public void outAStartStm(AStartStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void caseAStopStm(AStopStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAStopStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			node.getObj().apply(this);
		}

		outAStopStm(node);

	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void inAStopStm(AStopStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public void outAStopStm(AStopStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void caseASubclassResponsibilityStm(ASubclassResponsibilityStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASubclassResponsibilityStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outASubclassResponsibilityStm(node);

	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void inASubclassResponsibilityStm(ASubclassResponsibilityStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public void outASubclassResponsibilityStm(ASubclassResponsibilityStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void caseATixeStm(ATixeStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATixeStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<ATixeStmtAlternative> copy = new ArrayList<ATixeStmtAlternative>(node.getTraps());
			for( ATixeStmtAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}

		outATixeStm(node);

	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void inATixeStm(ATixeStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public void outATixeStm(ATixeStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void caseATrapStm(ATrapStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATrapStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this);
		}
		if(node.getWith() != null && !_visitedNodes.contains(node.getWith())) 
		{
			node.getWith().apply(this);
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			node.getBody().apply(this);
		}

		outATrapStm(node);

	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void inATrapStm(ATrapStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public void outATrapStm(ATrapStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void caseAWhileStm(AWhileStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAWhileStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}

		outAWhileStm(node);

	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void inAWhileStm(AWhileStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public void outAWhileStm(AWhileStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void caseAPeriodicStm(APeriodicStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAPeriodicStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAPeriodicStm(node);

	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void inAPeriodicStm(APeriodicStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public void outAPeriodicStm(APeriodicStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void caseASporadicStm(ASporadicStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASporadicStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getOpname() != null ) 
		{
			node.getOpname().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outASporadicStm(node);

	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void inASporadicStm(ASporadicStm node) throws AnalysisException
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public void outASporadicStm(ASporadicStm node) throws AnalysisException
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void caseABlockSimpleBlockStm(ABlockSimpleBlockStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inABlockSimpleBlockStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		{
			List<AAssignmentDefinition> copy = new ArrayList<AAssignmentDefinition>(node.getAssignmentDefs());
			for( AAssignmentDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outABlockSimpleBlockStm(node);

	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void inABlockSimpleBlockStm(ABlockSimpleBlockStm node) throws AnalysisException
	{
		defaultInSSimpleBlockStm(node);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public void outABlockSimpleBlockStm(ABlockSimpleBlockStm node) throws AnalysisException
	{
		defaultOutSSimpleBlockStm(node);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void caseANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANonDeterministicSimpleBlockStm(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outANonDeterministicSimpleBlockStm(node);

	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void inANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node) throws AnalysisException
	{
		defaultInSSimpleBlockStm(node);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public void outANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node) throws AnalysisException
	{
		defaultOutSSimpleBlockStm(node);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultInPStateDesignator(PStateDesignator node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultOutPStateDesignator(PStateDesignator node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void defaultPStateDesignator(PStateDesignator node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void inPStateDesignator(PStateDesignator node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public void outPStateDesignator(PStateDesignator node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void caseAFieldStateDesignator(AFieldStateDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldStateDesignator(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this);
		}
		if(node.getObjectfield() != null ) 
		{
			node.getObjectfield().apply(this);
		}

		outAFieldStateDesignator(node);

	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void inAFieldStateDesignator(AFieldStateDesignator node) throws AnalysisException
	{
		defaultInPStateDesignator(node);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public void outAFieldStateDesignator(AFieldStateDesignator node) throws AnalysisException
	{
		defaultOutPStateDesignator(node);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void caseAIdentifierStateDesignator(AIdentifierStateDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierStateDesignator(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}

		outAIdentifierStateDesignator(node);

	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void inAIdentifierStateDesignator(AIdentifierStateDesignator node) throws AnalysisException
	{
		defaultInPStateDesignator(node);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public void outAIdentifierStateDesignator(AIdentifierStateDesignator node) throws AnalysisException
	{
		defaultOutPStateDesignator(node);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void caseAMapSeqStateDesignator(AMapSeqStateDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAMapSeqStateDesignator(node);

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}
		if(node.getMapseq() != null && !_visitedNodes.contains(node.getMapseq())) 
		{
			node.getMapseq().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			node.getMapType().apply(this);
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			node.getSeqType().apply(this);
		}

		outAMapSeqStateDesignator(node);

	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void inAMapSeqStateDesignator(AMapSeqStateDesignator node) throws AnalysisException
	{
		defaultInPStateDesignator(node);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public void outAMapSeqStateDesignator(AMapSeqStateDesignator node) throws AnalysisException
	{
		defaultOutPStateDesignator(node);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultInPObjectDesignator(PObjectDesignator node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultOutPObjectDesignator(PObjectDesignator node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void defaultPObjectDesignator(PObjectDesignator node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void inPObjectDesignator(PObjectDesignator node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public void outPObjectDesignator(PObjectDesignator node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void caseAApplyObjectDesignator(AApplyObjectDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAApplyObjectDesignator(node);

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this);
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}

		outAApplyObjectDesignator(node);

	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void inAApplyObjectDesignator(AApplyObjectDesignator node) throws AnalysisException
	{
		defaultInPObjectDesignator(node);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public void outAApplyObjectDesignator(AApplyObjectDesignator node) throws AnalysisException
	{
		defaultOutPObjectDesignator(node);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void caseAFieldObjectDesignator(AFieldObjectDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAFieldObjectDesignator(node);

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			node.getObject().apply(this);
		}
		if(node.getClassName() != null ) 
		{
			node.getClassName().apply(this);
		}
		if(node.getFieldName() != null ) 
		{
			node.getFieldName().apply(this);
		}
		if(node.getField() != null ) 
		{
			node.getField().apply(this);
		}

		outAFieldObjectDesignator(node);

	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void inAFieldObjectDesignator(AFieldObjectDesignator node) throws AnalysisException
	{
		defaultInPObjectDesignator(node);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public void outAFieldObjectDesignator(AFieldObjectDesignator node) throws AnalysisException
	{
		defaultOutPObjectDesignator(node);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void caseAIdentifierObjectDesignator(AIdentifierObjectDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAIdentifierObjectDesignator(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outAIdentifierObjectDesignator(node);

	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void inAIdentifierObjectDesignator(AIdentifierObjectDesignator node) throws AnalysisException
	{
		defaultInPObjectDesignator(node);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public void outAIdentifierObjectDesignator(AIdentifierObjectDesignator node) throws AnalysisException
	{
		defaultOutPObjectDesignator(node);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void caseANewObjectDesignator(ANewObjectDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inANewObjectDesignator(node);

		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			node.getExpression().apply(this);
		}

		outANewObjectDesignator(node);

	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void inANewObjectDesignator(ANewObjectDesignator node) throws AnalysisException
	{
		defaultInPObjectDesignator(node);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public void outANewObjectDesignator(ANewObjectDesignator node) throws AnalysisException
	{
		defaultOutPObjectDesignator(node);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void caseASelfObjectDesignator(ASelfObjectDesignator node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inASelfObjectDesignator(node);

		if(node.getSelf() != null ) 
		{
			node.getSelf().apply(this);
		}

		outASelfObjectDesignator(node);

	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void inASelfObjectDesignator(ASelfObjectDesignator node) throws AnalysisException
	{
		defaultInPObjectDesignator(node);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public void outASelfObjectDesignator(ASelfObjectDesignator node) throws AnalysisException
	{
		defaultOutPObjectDesignator(node);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultInPAlternativeStm(PAlternativeStm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultOutPAlternativeStm(PAlternativeStm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void defaultPAlternativeStm(PAlternativeStm node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void inPAlternativeStm(PAlternativeStm node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public void outPAlternativeStm(PAlternativeStm node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void caseACaseAlternativeStm(ACaseAlternativeStm node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inACaseAlternativeStm(node);

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			node.getCexp().apply(this);
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			node.getPattern().apply(this);
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			node.getResult().apply(this);
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					e.apply(this);
				}
			}
		}
		if(node.getCtype() != null && !_visitedNodes.contains(node.getCtype())) 
		{
			node.getCtype().apply(this);
		}

		outACaseAlternativeStm(node);

	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void inACaseAlternativeStm(ACaseAlternativeStm node) throws AnalysisException
	{
		defaultInPAlternativeStm(node);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public void outACaseAlternativeStm(ACaseAlternativeStm node) throws AnalysisException
	{
		defaultOutPAlternativeStm(node);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultInPStmtAlternative(PStmtAlternative node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultOutPStmtAlternative(PStmtAlternative node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void defaultPStmtAlternative(PStmtAlternative node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void inPStmtAlternative(PStmtAlternative node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public void outPStmtAlternative(PStmtAlternative node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void caseATixeStmtAlternative(ATixeStmtAlternative node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inATixeStmtAlternative(node);

		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			node.getPatternBind().apply(this);
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			node.getStatement().apply(this);
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			node.getExp().apply(this);
		}

		outATixeStmtAlternative(node);

	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void inATixeStmtAlternative(ATixeStmtAlternative node) throws AnalysisException
	{
		defaultInPStmtAlternative(node);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public void outATixeStmtAlternative(ATixeStmtAlternative node) throws AnalysisException
	{
		defaultOutPStmtAlternative(node);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultInPClause(PClause node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultOutPClause(PClause node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void defaultPClause(PClause node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void inPClause(PClause node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public void outPClause(PClause node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void caseAExternalClause(AExternalClause node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAExternalClause(node);

		if(node.getMode() != null ) 
		{
			node.getMode().apply(this);
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getIdentifiers());
			for( ILexNameToken e : copy) 
			{
				e.apply(this);
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			node.getType().apply(this);
		}

		outAExternalClause(node);

	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void inAExternalClause(AExternalClause node) throws AnalysisException
	{
		defaultInPClause(node);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public void outAExternalClause(AExternalClause node) throws AnalysisException
	{
		defaultOutPClause(node);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultInPCase(PCase node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultOutPCase(PCase node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void defaultPCase(PCase node) throws AnalysisException
	{
		defaultINode(node);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void inPCase(PCase node) throws AnalysisException
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public void outPCase(PCase node) throws AnalysisException
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void caseAErrorCase(AErrorCase node) throws AnalysisException
	{
		_visitedNodes.add(node);
		inAErrorCase(node);

		if(node.getName() != null ) 
		{
			node.getName().apply(this);
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			node.getLeft().apply(this);
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			node.getRight().apply(this);
		}

		outAErrorCase(node);

	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void inAErrorCase(AErrorCase node) throws AnalysisException
	{
		defaultInPCase(node);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public void outAErrorCase(AErrorCase node) throws AnalysisException
	{
		defaultOutPCase(node);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultOutINode(INode node) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultInINode(INode node) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultINode(INode node) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultOutIToken(IToken node) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultInIToken(IToken node) throws AnalysisException
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultIToken(IToken node) throws AnalysisException
	{
		//nothing to do
	}



}
