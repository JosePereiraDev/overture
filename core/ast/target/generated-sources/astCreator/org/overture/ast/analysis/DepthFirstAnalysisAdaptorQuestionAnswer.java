/*******************************************************************************
* Copyright (c) 2009, 2011 Overture Team and others.
*
* Overture is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Overture is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Overture.  If not, see <http://www.gnu.org/licenses/>.
*
* The Overture Tool web-site: http://overturetool.org/
*******************************************************************************/

/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overture.ast.analysis;


import org.overture.ast.intf.lex.ILexIdentifierToken;
import org.overture.ast.modules.AOperationValueImport;
import org.overture.ast.expressions.ACasesExp;
import org.overture.ast.expressions.AUnaryPlusUnaryExp;
import org.overture.ast.expressions.ALetDefExp;
import org.overture.ast.expressions.PModifier;
import org.overture.ast.definitions.ARenamedDefinition;
import org.overture.ast.statements.AAssignmentStm;
import org.overture.ast.statements.AFieldObjectDesignator;
import org.overture.ast.expressions.AIsOfBaseClassExp;
import java.lang.Integer;
import org.overture.ast.definitions.AInstanceVariableDefinition;
import org.overture.ast.expressions.AUndefinedExp;
import org.overture.ast.expressions.ASubtractNumericBinaryExp;
import org.overture.ast.patterns.PPattern;
import org.overture.ast.definitions.PAccess;
import org.overture.ast.definitions.traces.PTraceCoreDefinition;
import java.lang.Long;
import org.overture.ast.expressions.ALetBeStExp;
import org.overture.ast.expressions.AIotaExp;
import org.overture.ast.expressions.AElementsUnaryExp;
import org.overture.ast.types.ASetType;
import org.overture.ast.definitions.ATypeDefinition;
import org.overture.ast.statements.PStmtAlternative;
import org.overture.ast.types.SBasicType;
import org.overture.ast.expressions.SBinaryExp;
import org.overture.ast.definitions.traces.AConcurrentExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AMapInverseUnaryExp;
import org.overture.ast.expressions.AMapUnionBinaryExp;
import org.overture.ast.types.AUnresolvedType;
import org.overture.ast.types.ARealNumericBasicType;
import org.overture.ast.patterns.AObjectPattern;
import org.overture.ast.statements.ACyclesStm;
import org.overture.ast.expressions.AExists1Exp;
import org.overture.ast.expressions.ATupleExp;
import org.overture.ast.patterns.AIntegerPattern;
import org.overture.ast.node.tokens.TStatic;
import org.overture.ast.expressions.ABooleanConstExp;
import org.overture.ast.patterns.ATypeBind;
import org.overture.ast.expressions.SMapExp;
import org.overture.ast.expressions.PExp;
import org.overture.ast.statements.ANonDeterministicSimpleBlockStm;
import org.overture.ast.expressions.AAbsoluteUnaryExp;
import org.overture.ast.statements.AApplyObjectDesignator;
import org.overture.ast.expressions.AIsExp;
import org.overture.ast.types.AOptionalType;
import org.overture.ast.types.AUnionType;
import org.overture.ast.definitions.APrivateAccess;
import org.overture.ast.definitions.traces.ALetBeStBindingTraceDefinition;
import org.overture.ast.modules.PModules;
import org.overture.ast.definitions.AImplicitFunctionDefinition;
import org.overture.ast.types.AVoidType;
import org.overture.ast.patterns.ATuplePattern;
import org.overture.ast.statements.ACallStm;
import org.overture.ast.statements.ASelfObjectDesignator;
import org.overture.ast.typechecker.ClassDefinitionSettings;
import org.overture.ast.statements.AFieldStateDesignator;
import org.overture.ast.types.AVoidReturnType;
import org.overture.ast.patterns.AStringPattern;
import org.overture.ast.definitions.APublicAccess;
import org.overture.ast.expressions.ADomainResByBinaryExp;
import org.overture.ast.patterns.AMapletPatternMaplet;
import org.overture.ast.expressions.ACardinalityUnaryExp;
import org.overture.ast.types.ABooleanBasicType;
import org.overture.ast.definitions.traces.AInstanceTraceDefinition;
import org.overture.ast.statements.ASubclassResponsibilityStm;
import org.overture.ast.analysis.intf.IQuestionAnswer;
import org.overture.ast.expressions.SSeqExp;
import org.overture.ast.expressions.ASetEnumSetExp;
import org.overture.ast.patterns.PMultipleBind;
import org.overture.ast.expressions.ADefExp;
import org.overture.ast.types.AFunctionType;
import org.overture.ast.expressions.AProperSubsetBinaryExp;
import org.overture.ast.types.AUnknownType;
import org.overture.ast.modules.AModuleExports;
import org.overture.ast.expressions.ATimeExp;
import org.overture.ast.definitions.traces.AApplyExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AImpliesBooleanBinaryExp;
import org.overture.ast.statements.ACaseAlternativeStm;
import org.overture.ast.patterns.ANamePatternPair;
import org.overture.ast.definitions.AStateDefinition;
import org.overture.ast.patterns.ASetBind;
import org.overture.ast.types.SSeqType;
import org.overture.ast.statements.AForAllStm;
import org.overture.ast.expressions.AGreaterNumericBinaryExp;
import org.overture.ast.expressions.ASetCompSetExp;
import org.overture.ast.patterns.AUnionPattern;
import org.overture.ast.expressions.AHeadUnaryExp;
import org.overture.ast.types.AUndefinedType;
import org.overture.ast.expressions.AFieldExp;
import org.overture.ast.patterns.ARealPattern;
import org.overture.ast.definitions.APerSyncDefinition;
import org.overture.ast.definitions.ABusClassDefinition;
import org.overture.ast.analysis.intf.IAnalysis;
import org.overture.ast.statements.ACasesStm;
import org.overture.ast.node.IToken;
import org.overture.ast.expressions.AMapRangeUnaryExp;
import org.overture.ast.statements.AIdentifierStateDesignator;
import org.overture.ast.intf.lex.ILexToken;
import org.overture.ast.expressions.AFloorUnaryExp;
import org.overture.ast.definitions.AExplicitOperationDefinition;
import org.overture.ast.statements.AMapSeqStateDesignator;
import org.overture.ast.patterns.APatternListTypePair;
import org.overture.ast.patterns.AMapPattern;
import org.overture.ast.expressions.ASubsetBinaryExp;
import org.overture.ast.statements.AReturnStm;
import org.overture.ast.modules.SValueImport;
import org.overture.ast.expressions.AStarStarBinaryExp;
import org.overture.ast.types.PAccessSpecifier;
import org.overture.ast.modules.AFunctionValueImport;
import org.overture.ast.statements.AElseIfStm;
import org.overture.ast.modules.AOperationExport;
import org.overture.ast.types.ANatOneNumericBasicType;
import org.overture.ast.expressions.SBooleanBinaryExp;
import org.overture.ast.intf.lex.ILexStringToken;
import org.overture.ast.expressions.ADistIntersectUnaryExp;
import org.overture.ast.statements.SSimpleBlockStm;
import org.overture.ast.patterns.ARecordPattern;
import org.overture.ast.expressions.APlusNumericBinaryExp;
import org.overture.ast.modules.AValueValueImport;
import org.overture.ast.types.ANamedInvariantType;
import org.overture.ast.expressions.ACaseAlternative;
import org.overture.ast.types.ARecordInvariantType;
import org.overture.ast.types.ASeqSeqType;
import org.overture.ast.patterns.PMaplet;
import org.overture.ast.expressions.ASameClassExp;
import org.overture.ast.expressions.ASetIntersectBinaryExp;
import org.overture.ast.patterns.ABooleanPattern;
import org.overture.ast.expressions.AForAllExp;
import org.overture.ast.definitions.traces.ATraceDefinitionTerm;
import org.overture.ast.expressions.ASelfExp;
import org.overture.ast.statements.AForPatternBindStm;
import org.overture.ast.modules.PImports;
import org.overture.ast.statements.PObjectDesignator;
import org.overture.ast.expressions.ASubseqExp;
import org.overture.ast.types.AMapMapType;
import org.overture.ast.statements.ACallObjectStm;
import org.overture.ast.expressions.SNumericBinaryExp;
import org.overture.ast.definitions.PDefinition;
import org.overture.ast.expressions.ASeqConcatBinaryExp;
import org.overture.ast.statements.AAlwaysStm;
import org.overture.ast.expressions.APostOpExp;
import org.overture.ast.statements.PClause;
import org.overture.ast.types.ASeq1SeqType;
import org.overture.ast.definitions.ANamedTraceDefinition;
import org.overture.ast.expressions.ALessEqualNumericBinaryExp;
import org.overture.ast.statements.AAtomicStm;
import org.overture.ast.expressions.ARangeResToBinaryExp;
import org.overture.ast.expressions.ASetRangeSetExp;
import org.overture.ast.statements.ABlockSimpleBlockStm;
import org.overture.ast.definitions.SClassDefinition;
import org.overture.ast.types.ARationalNumericBasicType;
import org.overture.ast.statements.ATixeStmtAlternative;
import org.overture.ast.expressions.AFuncInstatiationExp;
import org.overture.ast.types.AProductType;
import org.overture.ast.statements.PCase;
import org.overture.ast.typechecker.Pass;
import org.overture.ast.expressions.AGreaterEqualNumericBinaryExp;
import org.overture.ast.types.AAccessSpecifierAccessSpecifier;
import org.overture.ast.statements.AExternalClause;
import java.lang.Boolean;
import java.util.LinkedList;
import org.overture.ast.definitions.AValueDefinition;
import org.overture.ast.definitions.traces.ABracketedExpressionTraceCoreDefinition;
import org.overture.ast.expressions.AExistsExp;
import org.overture.ast.expressions.AThreadIdExp;
import org.overture.ast.expressions.ACompBinaryExp;
import org.overture.ast.expressions.ARealLiteralExp;
import org.overture.ast.statements.ATixeStm;
import org.overture.ast.definitions.traces.PTerm;
import org.overture.ast.intf.lex.ILexQuoteToken;
import org.overture.ast.expressions.ANotEqualBinaryExp;
import org.overture.ast.expressions.AElseIfExp;
import org.overture.ast.expressions.ASameBaseClassExp;
import org.overture.ast.types.PField;
import org.overture.ast.expressions.APowerSetUnaryExp;
import org.overture.ast.types.PType;
import org.overture.ast.patterns.AIgnorePattern;
import org.overture.ast.statements.AWhileStm;
import org.overture.ast.statements.AIfStm;
import org.overture.ast.statements.APeriodicStm;
import org.overture.ast.patterns.AMapUnionPattern;
import org.overture.ast.statements.ALetBeStStm;
import org.overture.ast.modules.AModuleImports;
import org.overture.ast.expressions.AIntLiteralExp;
import org.overture.ast.expressions.ATimesNumericBinaryExp;
import org.overture.ast.expressions.AMapEnumMapExp;
import org.overture.ast.expressions.AIfExp;
import org.overture.ast.patterns.ADefPatternBind;
import org.overture.ast.statements.ANewObjectDesignator;
import org.overture.ast.statements.AStartStm;
import org.overture.ast.statements.ANotYetSpecifiedStm;
import org.overture.ast.statements.AClassInvariantStm;
import org.overture.ast.expressions.AMkBasicExp;
import org.overture.ast.expressions.APreOpExp;
import org.overture.ast.modules.PExport;
import org.overture.ast.modules.ATypeExport;
import org.overture.ast.expressions.ADistMergeUnaryExp;
import org.overture.ast.definitions.AMutexSyncDefinition;
import org.overture.ast.definitions.SFunctionDefinition;
import org.overture.ast.definitions.AInheritedDefinition;
import java.util.Set;
import org.overture.ast.modules.AFunctionExport;
import org.overture.ast.patterns.AConcatenationPattern;
import org.overture.ast.expressions.ALenUnaryExp;
import org.overture.ast.expressions.AApplyExp;
import org.overture.ast.expressions.AFieldNumberExp;
import org.overture.ast.patterns.ASetMultipleBind;
import org.overture.ast.modules.AAllImport;
import org.overture.ast.modules.PExports;
import org.overture.ast.expressions.ANewExp;
import org.overture.ast.definitions.AMultiBindListDefinition;
import org.overture.ast.expressions.ADivideNumericBinaryExp;
import org.overture.ast.expressions.AVariableExp;
import org.overture.ast.expressions.ADomainResToBinaryExp;
import org.overture.ast.statements.ADurationStm;
import org.overture.ast.expressions.ASubclassResponsibilityExp;
import org.overture.ast.definitions.AUntypedDefinition;
import org.overture.ast.expressions.ASetDifferenceBinaryExp;
import org.overture.ast.expressions.AIsOfClassExp;
import org.overture.ast.expressions.ADivNumericBinaryExp;
import org.overture.ast.definitions.AImplicitOperationDefinition;
import org.overture.ast.patterns.AExpressionPattern;
import org.overture.ast.intf.lex.ILexIntegerToken;
import java.util.ArrayList;
import org.overture.ast.types.AFieldField;
import org.overture.ast.types.ATokenBasicType;
import org.overture.ast.expressions.AModNumericBinaryExp;
import java.lang.String;
import org.overture.ast.expressions.ANilExp;
import org.overture.ast.definitions.AClassClassDefinition;
import org.overture.ast.node.tokens.TAsync;
import org.overture.ast.expressions.ARangeResByBinaryExp;
import org.overture.ast.types.ABracketType;
import org.overture.ast.statements.AStopStm;
import org.overture.ast.expressions.ASeqCompSeqExp;
import org.overture.ast.expressions.AOrBooleanBinaryExp;
import org.overture.ast.definitions.AClassInvariantDefinition;
import org.overture.ast.expressions.AMkTypeExp;
import org.overture.ast.statements.AIdentifierObjectDesignator;
import org.overture.ast.expressions.AMapletExp;
import org.overture.ast.expressions.APreExp;
import org.overture.ast.expressions.AMapDomainUnaryExp;
import org.overture.ast.types.AInMapMapType;
import org.overture.ast.expressions.ASeqEnumSeqExp;
import org.overture.ast.definitions.ASystemClassDefinition;
import org.overture.ast.intf.lex.ILexLocation;
import org.overture.ast.expressions.AAndBooleanBinaryExp;
import org.overture.ast.types.AQuoteType;
import org.overture.ast.expressions.AQuoteLiteralExp;
import org.overture.ast.statements.AErrorStm;
import org.overture.ast.expressions.SSetExp;
import org.overture.ast.patterns.PBind;
import org.overture.ast.types.AOperationType;
import org.overture.ast.util.ClonableString;
import org.overture.ast.util.ClonableFile;
import org.overture.ast.expressions.ADistConcatUnaryExp;
import org.overture.ast.expressions.ANotInSetBinaryExp;
import org.overture.ast.types.SInvariantType;
import org.overture.ast.expressions.APlusPlusBinaryExp;
import org.overture.ast.expressions.AEquivalentBooleanBinaryExp;
import org.overture.ast.definitions.ALocalDefinition;
import org.overture.ast.modules.AAllExport;
import org.overture.ast.expressions.AIndicesUnaryExp;
import org.overture.ast.types.AIntNumericBasicType;
import org.overture.ast.definitions.AThreadDefinition;
import org.overture.ast.intf.lex.ILexNameToken;
import org.overture.ast.statements.ALetStm;
import org.overture.ast.types.AParameterType;
import org.overture.ast.node.INode;
import org.overture.ast.patterns.PPair;
import org.overture.ast.statements.ASporadicStm;
import org.overture.ast.statements.ATrapStm;
import org.overture.ast.intf.lex.ILexRealToken;
import org.overture.ast.definitions.ACpuClassDefinition;
import org.overture.ast.statements.AForIndexStm;
import org.overture.ast.patterns.ASeqPattern;
import org.overture.ast.modules.ATypeImport;
import org.overture.ast.types.SMapType;
import org.overture.ast.patterns.ATypeMultipleBind;
import org.overture.ast.definitions.AAssignmentDefinition;
import org.overture.ast.definitions.AImportedDefinition;
import org.overture.ast.intf.lex.ILexBooleanToken;
import org.overture.ast.expressions.ACharLiteralExp;
import org.overture.ast.expressions.ANarrowExp;
import org.overture.ast.analysis.AnalysisException;
import java.util.List;
import org.overture.ast.expressions.ANotUnaryExp;
import org.overture.ast.definitions.AProtectedAccess;
import org.overture.ast.definitions.SOperationDefinition;
import org.overture.ast.typechecker.NameScope;
import org.overture.ast.definitions.AExternalDefinition;
import org.overture.ast.expressions.AMuExp;
import org.overture.ast.expressions.SUnaryExp;
import org.overture.ast.expressions.AUnaryMinusUnaryExp;
import org.overture.ast.types.AClassType;
import org.overture.ast.statements.AExitStm;
import org.overture.ast.expressions.AReverseUnaryExp;
import org.overture.ast.statements.PStm;
import org.overture.ast.expressions.ASetUnionBinaryExp;
import org.overture.ast.expressions.ALambdaExp;
import org.overture.ast.modules.PImport;
import org.overture.ast.types.ANatNumericBasicType;
import org.overture.ast.definitions.traces.ARepeatTraceDefinition;
import org.overture.ast.expressions.ARemNumericBinaryExp;
import org.overture.ast.patterns.AIdentifierPattern;
import org.overture.ast.expressions.AHistoryExp;
import org.overture.ast.expressions.ALessNumericBinaryExp;
import org.overture.ast.patterns.ACharacterPattern;
import org.overture.ast.expressions.AStringLiteralExp;
import org.overture.ast.expressions.AEqualsBinaryExp;
import org.overture.ast.expressions.AMapCompMapExp;
import org.overture.ast.intf.lex.ILexCharacterToken;
import org.overture.ast.expressions.ATailUnaryExp;
import org.overture.ast.statements.ASkipStm;
import org.overture.ast.patterns.AQuotePattern;
import org.overture.ast.statements.PStateDesignator;
import org.overture.ast.statements.ASpecificationStm;
import org.overture.ast.expressions.ANotYetSpecifiedExp;
import org.overture.ast.definitions.traces.PTraceDefinition;
import org.overture.ast.modules.AModuleModules;
import org.overture.ast.types.SNumericBasicType;
import org.overture.ast.patterns.ASetPattern;
import org.overture.ast.definitions.AEqualsDefinition;
import org.overture.ast.types.ACharBasicType;
import org.overture.ast.modules.AFromModuleImports;
import org.overture.ast.statements.PAlternativeStm;
import org.overture.ast.definitions.traces.ALetDefBindingTraceDefinition;
import org.overture.ast.expressions.ADistUnionUnaryExp;
import org.overture.ast.expressions.AStateInitExp;
import org.overture.ast.patterns.ANilPattern;
import org.overture.ast.modules.AValueExport;
import org.overture.ast.expressions.ARecordModifier;
import org.overture.ast.expressions.AInSetBinaryExp;
import org.overture.ast.patterns.PPatternBind;
import org.overture.ast.statements.AErrorCase;
import org.overture.ast.definitions.AExplicitFunctionDefinition;
import org.overture.ast.patterns.APatternTypePair;
import org.overture.ast.expressions.PAlternative;


/**
* Generated file by AST Creator
* @author Kenneth Lausdahl
*
*/
@SuppressWarnings({"all"})
public abstract class DepthFirstAnalysisAdaptorQuestionAnswer<Q, A> implements IQuestionAnswer<Q, A>
{
	private static final long serialVersionUID = 1L;

	protected Set<INode> _visitedNodes = new java.util.HashSet<INode>();
	final protected IQuestionAnswer<Q, A> THIS;

	/**
	* Creates a new {@code DepthFirstAnalysisAdaptorQuestionAnswer} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param visitedNodes_ the {@link Set} node for the {@code visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestionAnswer} node
	* @param THIS_ the {@link IQuestionAnswer} <b>graph</a> node for the {@code THIS} child of this {@link DepthFirstAnalysisAdaptorQuestionAnswer} node.
	*  <i>The parent of this {@code THIS } will not be changed by adding it to this node.</i>
	*/
	public DepthFirstAnalysisAdaptorQuestionAnswer(Set<INode> visitedNodes_, IQuestionAnswer<Q, A> THIS_)
	{
		super();
		this.setVisitedNodes(visitedNodes_);
		this.THIS = THIS_;

	}


	/**
	 * Creates a new {@link DepthFirstAnalysisAdaptorQuestionAnswer} node with no children.
	 */
	public DepthFirstAnalysisAdaptorQuestionAnswer()
	{
		this.THIS=this;

	}


	/**
	 * Sets the {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestionAnswer} node.
	 * @param value the new {@code _visitedNodes} child of this {@link DepthFirstAnalysisAdaptorQuestionAnswer} node
	*/
	public void setVisitedNodes(Set<INode> value)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexToken(ILexToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexToken(node, question));


		mergeReturns(retVal,outILexToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexToken(ILexToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexToken(ILexToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexNameToken(node, question));


		mergeReturns(retVal,outILexNameToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexNameToken(ILexNameToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexIdentifierToken(node, question));


		mergeReturns(retVal,outILexIdentifierToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexIdentifierToken(ILexIdentifierToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexBooleanToken(node, question));


		mergeReturns(retVal,outILexBooleanToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexBooleanToken(ILexBooleanToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexCharacterToken(node, question));


		mergeReturns(retVal,outILexCharacterToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexCharacterToken(ILexCharacterToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexIntegerToken(node, question));


		mergeReturns(retVal,outILexIntegerToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexIntegerToken(ILexIntegerToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexQuoteToken(node, question));


		mergeReturns(retVal,outILexQuoteToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexQuoteToken(ILexQuoteToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexRealToken(node, question));


		mergeReturns(retVal,outILexRealToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexRealToken(ILexRealToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexStringToken(node, question));


		mergeReturns(retVal,outILexStringToken(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexStringToken(ILexStringToken node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseILexLocation(ILexLocation node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inILexLocation(node, question));


		mergeReturns(retVal,outILexLocation(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inILexLocation(ILexLocation node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outILexLocation(ILexLocation node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseClonableFile(ClonableFile node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inClonableFile(node, question));


		mergeReturns(retVal,outClonableFile(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inClonableFile(ClonableFile node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outClonableFile(ClonableFile node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseClonableString(ClonableString node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inClonableString(node, question));


		mergeReturns(retVal,outClonableString(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inClonableString(ClonableString node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outClonableString(ClonableString node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inClassDefinitionSettings(node, question));


		mergeReturns(retVal,outClassDefinitionSettings(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outClassDefinitionSettings(ClassDefinitionSettings node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseNameScope(NameScope node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inNameScope(node, question));


		mergeReturns(retVal,outNameScope(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inNameScope(NameScope node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outNameScope(NameScope node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A casePass(Pass node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inPass(node, question));


		mergeReturns(retVal,outPass(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inPass(Pass node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outPass(Pass node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseBoolean(Boolean node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inBoolean(node, question));


		mergeReturns(retVal,outBoolean(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inBoolean(Boolean node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outBoolean(Boolean node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseInteger(Integer node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inInteger(node, question));


		mergeReturns(retVal,outInteger(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inInteger(Integer node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outInteger(Integer node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseString(String node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inString(node, question));


		mergeReturns(retVal,outString(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inString(String node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outString(String node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseLong(Long node, Q question) throws AnalysisException
	{
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inLong(node, question));


		mergeReturns(retVal,outLong(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inLong(Long node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outLong(Long node, Q question) throws AnalysisException
	{
		return null;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseTStatic(TStatic node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inTStatic(node, question));


		mergeReturns(retVal,outTStatic(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inTStatic(TStatic node, Q question) throws AnalysisException
	{
		return defaultInIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outTStatic(TStatic node, Q question) throws AnalysisException
	{
		return defaultOutIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A caseTAsync(TAsync node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inTAsync(node, question));


		mergeReturns(retVal,outTAsync(node, question));
		return retVal;
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A inTAsync(TAsync node, Q question) throws AnalysisException
	{
		return defaultInIToken(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A outTAsync(TAsync node, Q question) throws AnalysisException
	{
		return defaultOutIToken(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public A defaultInPExp(PExp node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public A defaultOutPExp(PExp node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public A defaultPExp(PExp node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public A inPExp(PExp node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public A outPExp(PExp node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public A caseAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAApplyExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getRoot() != null && !_visitedNodes.contains(node.getRoot())) 
		{
			mergeReturns(retVal,node.getRoot().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgtypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getRecursive() != null && !_visitedNodes.contains(node.getRecursive())) 
		{
			mergeReturns(retVal,node.getRecursive().apply(this, question));
		}

		mergeReturns(retVal,outAApplyExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public A inAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AApplyExp} node from {@link AApplyExp#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExp} node
	*/
	public A outAApplyExp(AApplyExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public A caseANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANarrowExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			mergeReturns(retVal,node.getTest().apply(this, question));
		}
		if(node.getTypeName() != null ) 
		{
			mergeReturns(retVal,node.getTypeName().apply(this, question));
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			mergeReturns(retVal,node.getBasicType().apply(this, question));
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			mergeReturns(retVal,node.getTypedef().apply(this, question));
		}

		mergeReturns(retVal,outANarrowExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public A inANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANarrowExp} node from {@link ANarrowExp#apply(IAnalysis)}.
	* @param node the calling {@link ANarrowExp} node
	*/
	public A outANarrowExp(ANarrowExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public A defaultInSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public A defaultOutSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public A defaultSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		return defaultPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public A inSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SUnaryExp} node from {@link SUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SUnaryExp} node
	*/
	public A outSUnaryExp(SUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public A defaultInSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public A defaultOutSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public A defaultSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		return defaultPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public A inSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SBinaryExp} node from {@link SBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBinaryExp} node
	*/
	public A outSBinaryExp(SBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public A caseABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABooleanConstExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outABooleanConstExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public A inABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ABooleanConstExp} node from {@link ABooleanConstExp#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanConstExp} node
	*/
	public A outABooleanConstExp(ABooleanConstExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public A caseACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACasesExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		{
			List<ACaseAlternative> copy = new ArrayList<ACaseAlternative>(node.getCases());
			for( ACaseAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			mergeReturns(retVal,node.getOthers().apply(this, question));
		}

		mergeReturns(retVal,outACasesExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public A inACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ACasesExp} node from {@link ACasesExp#apply(IAnalysis)}.
	* @param node the calling {@link ACasesExp} node
	*/
	public A outACasesExp(ACasesExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public A caseACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACharLiteralExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outACharLiteralExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public A inACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ACharLiteralExp} node from {@link ACharLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ACharLiteralExp} node
	*/
	public A outACharLiteralExp(ACharLiteralExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public A caseAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAElseIfExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			mergeReturns(retVal,node.getElseIf().apply(this, question));
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			mergeReturns(retVal,node.getThen().apply(this, question));
		}

		mergeReturns(retVal,outAElseIfExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public A inAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AElseIfExp} node from {@link AElseIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfExp} node
	*/
	public A outAElseIfExp(AElseIfExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public A caseAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExists1Exp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outAExists1Exp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public A inAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AExists1Exp} node from {@link AExists1Exp#apply(IAnalysis)}.
	* @param node the calling {@link AExists1Exp} node
	*/
	public A outAExists1Exp(AExists1Exp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public A caseAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExistsExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outAExistsExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public A inAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AExistsExp} node from {@link AExistsExp#apply(IAnalysis)}.
	* @param node the calling {@link AExistsExp} node
	*/
	public A outAExistsExp(AExistsExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public A caseAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFieldExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			mergeReturns(retVal,node.getObject().apply(this, question));
		}
		if(node.getMemberName() != null ) 
		{
			mergeReturns(retVal,node.getMemberName().apply(this, question));
		}
		if(node.getField() != null ) 
		{
			mergeReturns(retVal,node.getField().apply(this, question));
		}

		mergeReturns(retVal,outAFieldExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public A inAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFieldExp} node from {@link AFieldExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldExp} node
	*/
	public A outAFieldExp(AFieldExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public A caseAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFieldNumberExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTuple() != null && !_visitedNodes.contains(node.getTuple())) 
		{
			mergeReturns(retVal,node.getTuple().apply(this, question));
		}
		if(node.getField() != null ) 
		{
			mergeReturns(retVal,node.getField().apply(this, question));
		}

		mergeReturns(retVal,outAFieldNumberExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public A inAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFieldNumberExp} node from {@link AFieldNumberExp#apply(IAnalysis)}.
	* @param node the calling {@link AFieldNumberExp} node
	*/
	public A outAFieldNumberExp(AFieldNumberExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public A caseAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAForAllExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindList());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outAForAllExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public A inAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AForAllExp} node from {@link AForAllExp#apply(IAnalysis)}.
	* @param node the calling {@link AForAllExp} node
	*/
	public A outAForAllExp(AForAllExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public A caseAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFuncInstatiationExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			mergeReturns(retVal,node.getFunction().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getActualTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExpdef() != null && !_visitedNodes.contains(node.getExpdef())) 
		{
			mergeReturns(retVal,node.getExpdef().apply(this, question));
		}
		if(node.getImpdef() != null && !_visitedNodes.contains(node.getImpdef())) 
		{
			mergeReturns(retVal,node.getImpdef().apply(this, question));
		}

		mergeReturns(retVal,outAFuncInstatiationExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public A inAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AFuncInstatiationExp} node from {@link AFuncInstatiationExp#apply(IAnalysis)}.
	* @param node the calling {@link AFuncInstatiationExp} node
	*/
	public A outAFuncInstatiationExp(AFuncInstatiationExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public A caseAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAHistoryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getHop() != null ) 
		{
			mergeReturns(retVal,node.getHop().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOpnames());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}

		mergeReturns(retVal,outAHistoryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public A inAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AHistoryExp} node from {@link AHistoryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHistoryExp} node
	*/
	public A outAHistoryExp(AHistoryExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public A caseAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIfExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			mergeReturns(retVal,node.getTest().apply(this, question));
		}
		if(node.getThen() != null && !_visitedNodes.contains(node.getThen())) 
		{
			mergeReturns(retVal,node.getThen().apply(this, question));
		}
		{
			List<AElseIfExp> copy = new ArrayList<AElseIfExp>(node.getElseList());
			for( AElseIfExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getElse() != null && !_visitedNodes.contains(node.getElse())) 
		{
			mergeReturns(retVal,node.getElse().apply(this, question));
		}

		mergeReturns(retVal,outAIfExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public A inAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIfExp} node from {@link AIfExp#apply(IAnalysis)}.
	* @param node the calling {@link AIfExp} node
	*/
	public A outAIfExp(AIfExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public A caseAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIntLiteralExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAIntLiteralExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public A inAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIntLiteralExp} node from {@link AIntLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AIntLiteralExp} node
	*/
	public A outAIntLiteralExp(AIntLiteralExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public A caseAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIotaExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outAIotaExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public A inAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIotaExp} node from {@link AIotaExp#apply(IAnalysis)}.
	* @param node the calling {@link AIotaExp} node
	*/
	public A outAIotaExp(AIotaExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public A caseAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIsExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTypeName() != null ) 
		{
			mergeReturns(retVal,node.getTypeName().apply(this, question));
		}
		if(node.getBasicType() != null && !_visitedNodes.contains(node.getBasicType())) 
		{
			mergeReturns(retVal,node.getBasicType().apply(this, question));
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			mergeReturns(retVal,node.getTest().apply(this, question));
		}
		if(node.getTypedef() != null && !_visitedNodes.contains(node.getTypedef())) 
		{
			mergeReturns(retVal,node.getTypedef().apply(this, question));
		}

		mergeReturns(retVal,outAIsExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public A inAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsExp} node from {@link AIsExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsExp} node
	*/
	public A outAIsExp(AIsExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public A caseAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIsOfBaseClassExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBaseClass() != null ) 
		{
			mergeReturns(retVal,node.getBaseClass().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAIsOfBaseClassExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public A inAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfBaseClassExp} node from {@link AIsOfBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfBaseClassExp} node
	*/
	public A outAIsOfBaseClassExp(AIsOfBaseClassExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public A caseAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIsOfClassExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getClassName() != null ) 
		{
			mergeReturns(retVal,node.getClassName().apply(this, question));
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			mergeReturns(retVal,node.getClassType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAIsOfClassExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public A inAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AIsOfClassExp} node from {@link AIsOfClassExp#apply(IAnalysis)}.
	* @param node the calling {@link AIsOfClassExp} node
	*/
	public A outAIsOfClassExp(AIsOfClassExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public A caseALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALambdaExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ATypeBind> copy = new ArrayList<ATypeBind>(node.getBindList());
			for( ATypeBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParamPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getFunctionType() != null && !_visitedNodes.contains(node.getFunctionType())) 
		{
			mergeReturns(retVal,node.getFunctionType().apply(this, question));
		}

		mergeReturns(retVal,outALambdaExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public A inALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALambdaExp} node from {@link ALambdaExp#apply(IAnalysis)}.
	* @param node the calling {@link ALambdaExp} node
	*/
	public A outALambdaExp(ALambdaExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public A caseALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetBeStExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			mergeReturns(retVal,node.getSuchThat().apply(this, question));
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outALetBeStExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public A inALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALetBeStExp} node from {@link ALetBeStExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStExp} node
	*/
	public A outALetBeStExp(ALetBeStExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public A caseALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetDefExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outALetDefExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public A inALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ALetDefExp} node from {@link ALetDefExp#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefExp} node
	*/
	public A outALetDefExp(ALetDefExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public A caseADefExp(ADefExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADefExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outADefExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public A inADefExp(ADefExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ADefExp} node from {@link ADefExp#apply(IAnalysis)}.
	* @param node the calling {@link ADefExp} node
	*/
	public A outADefExp(ADefExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public A defaultInSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public A defaultOutSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public A defaultSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		return defaultPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public A inSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SMapExp} node from {@link SMapExp#apply(IAnalysis)}.
	* @param node the calling {@link SMapExp} node
	*/
	public A outSMapExp(SMapExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public A caseAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapletExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAMapletExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public A inAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMapletExp} node from {@link AMapletExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapletExp} node
	*/
	public A outAMapletExp(AMapletExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public A caseAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMkBasicExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getArg() != null && !_visitedNodes.contains(node.getArg())) 
		{
			mergeReturns(retVal,node.getArg().apply(this, question));
		}

		mergeReturns(retVal,outAMkBasicExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public A inAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMkBasicExp} node from {@link AMkBasicExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkBasicExp} node
	*/
	public A outAMkBasicExp(AMkBasicExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public A caseAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMkTypeExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTypeName() != null ) 
		{
			mergeReturns(retVal,node.getTypeName().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			mergeReturns(retVal,node.getRecordType().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getArgTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAMkTypeExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public A inAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMkTypeExp} node from {@link AMkTypeExp#apply(IAnalysis)}.
	* @param node the calling {@link AMkTypeExp} node
	*/
	public A outAMkTypeExp(AMkTypeExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public A caseAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMuExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getRecord() != null && !_visitedNodes.contains(node.getRecord())) 
		{
			mergeReturns(retVal,node.getRecord().apply(this, question));
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			mergeReturns(retVal,node.getRecordType().apply(this, question));
		}
		{
			List<ARecordModifier> copy = new ArrayList<ARecordModifier>(node.getModifiers());
			for( ARecordModifier e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getModTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAMuExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public A inAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AMuExp} node from {@link AMuExp#apply(IAnalysis)}.
	* @param node the calling {@link AMuExp} node
	*/
	public A outAMuExp(AMuExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public A caseANewExp(ANewExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANewExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getClassName() != null ) 
		{
			mergeReturns(retVal,node.getClassName().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			mergeReturns(retVal,node.getClassdef().apply(this, question));
		}
		if(node.getCtorDefinition() != null && !_visitedNodes.contains(node.getCtorDefinition())) 
		{
			mergeReturns(retVal,node.getCtorDefinition().apply(this, question));
		}

		mergeReturns(retVal,outANewExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public A inANewExp(ANewExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANewExp} node from {@link ANewExp#apply(IAnalysis)}.
	* @param node the calling {@link ANewExp} node
	*/
	public A outANewExp(ANewExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public A caseANilExp(ANilExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANilExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outANilExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public A inANilExp(ANilExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANilExp} node from {@link ANilExp#apply(IAnalysis)}.
	* @param node the calling {@link ANilExp} node
	*/
	public A outANilExp(ANilExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public A caseANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANotYetSpecifiedExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outANotYetSpecifiedExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public A inANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedExp} node from {@link ANotYetSpecifiedExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedExp} node
	*/
	public A outANotYetSpecifiedExp(ANotYetSpecifiedExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public A caseAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPostOpExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		if(node.getPreexpression() != null && !_visitedNodes.contains(node.getPreexpression())) 
		{
			mergeReturns(retVal,node.getPreexpression().apply(this, question));
		}
		if(node.getPostexpression() != null && !_visitedNodes.contains(node.getPostexpression())) 
		{
			mergeReturns(retVal,node.getPostexpression().apply(this, question));
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}

		mergeReturns(retVal,outAPostOpExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public A inAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APostOpExp} node from {@link APostOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APostOpExp} node
	*/
	public A outAPostOpExp(APostOpExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public A caseAPreExp(APreExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPreExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getFunction() != null && !_visitedNodes.contains(node.getFunction())) 
		{
			mergeReturns(retVal,node.getFunction().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAPreExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public A inAPreExp(APreExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APreExp} node from {@link APreExp#apply(IAnalysis)}.
	* @param node the calling {@link APreExp} node
	*/
	public A outAPreExp(APreExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public A caseAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPreOpExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}

		mergeReturns(retVal,outAPreOpExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public A inAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link APreOpExp} node from {@link APreOpExp#apply(IAnalysis)}.
	* @param node the calling {@link APreOpExp} node
	*/
	public A outAPreOpExp(APreOpExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public A caseAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAQuoteLiteralExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAQuoteLiteralExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public A inAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AQuoteLiteralExp} node from {@link AQuoteLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteLiteralExp} node
	*/
	public A outAQuoteLiteralExp(AQuoteLiteralExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public A caseARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARealLiteralExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outARealLiteralExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public A inARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ARealLiteralExp} node from {@link ARealLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link ARealLiteralExp} node
	*/
	public A outARealLiteralExp(ARealLiteralExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public A caseASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASameBaseClassExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASameBaseClassExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public A inASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASameBaseClassExp} node from {@link ASameBaseClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameBaseClassExp} node
	*/
	public A outASameBaseClassExp(ASameBaseClassExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public A caseASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASameClassExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASameClassExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public A inASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASameClassExp} node from {@link ASameClassExp#apply(IAnalysis)}.
	* @param node the calling {@link ASameClassExp} node
	*/
	public A outASameClassExp(ASameClassExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public A caseASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASelfExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outASelfExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public A inASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASelfExp} node from {@link ASelfExp#apply(IAnalysis)}.
	* @param node the calling {@link ASelfExp} node
	*/
	public A outASelfExp(ASelfExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public A defaultInSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public A defaultOutSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public A defaultSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		return defaultPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public A inSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSeqExp} node from {@link SSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link SSeqExp} node
	*/
	public A outSSeqExp(SSeqExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public A defaultInSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public A defaultOutSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public A defaultSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		return defaultPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public A inSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link SSetExp} node from {@link SSetExp#apply(IAnalysis)}.
	* @param node the calling {@link SSetExp} node
	*/
	public A outSSetExp(SSetExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public A caseAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStateInitExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}

		mergeReturns(retVal,outAStateInitExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public A inAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AStateInitExp} node from {@link AStateInitExp#apply(IAnalysis)}.
	* @param node the calling {@link AStateInitExp} node
	*/
	public A outAStateInitExp(AStateInitExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public A caseAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStringLiteralExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAStringLiteralExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public A inAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AStringLiteralExp} node from {@link AStringLiteralExp#apply(IAnalysis)}.
	* @param node the calling {@link AStringLiteralExp} node
	*/
	public A outAStringLiteralExp(AStringLiteralExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public A caseASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASubclassResponsibilityExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outASubclassResponsibilityExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public A inASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityExp} node from {@link ASubclassResponsibilityExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityExp} node
	*/
	public A outASubclassResponsibilityExp(ASubclassResponsibilityExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public A caseASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASubseqExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getSeq() != null && !_visitedNodes.contains(node.getSeq())) 
		{
			mergeReturns(retVal,node.getSeq().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			mergeReturns(retVal,node.getTo().apply(this, question));
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			mergeReturns(retVal,node.getFtype().apply(this, question));
		}
		if(node.getTtype() != null && !_visitedNodes.contains(node.getTtype())) 
		{
			mergeReturns(retVal,node.getTtype().apply(this, question));
		}

		mergeReturns(retVal,outASubseqExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public A inASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ASubseqExp} node from {@link ASubseqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubseqExp} node
	*/
	public A outASubseqExp(ASubseqExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public A caseAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAThreadIdExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAThreadIdExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public A inAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AThreadIdExp} node from {@link AThreadIdExp#apply(IAnalysis)}.
	* @param node the calling {@link AThreadIdExp} node
	*/
	public A outAThreadIdExp(AThreadIdExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public A caseATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATimeExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outATimeExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public A inATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ATimeExp} node from {@link ATimeExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeExp} node
	*/
	public A outATimeExp(ATimeExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public A caseATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATupleExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outATupleExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public A inATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link ATupleExp} node from {@link ATupleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATupleExp} node
	*/
	public A outATupleExp(ATupleExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public A caseAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUndefinedExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAUndefinedExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public A inAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AUndefinedExp} node from {@link AUndefinedExp#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedExp} node
	*/
	public A outAUndefinedExp(AUndefinedExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public A caseAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAVariableExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getVardef() != null && !_visitedNodes.contains(node.getVardef())) 
		{
			mergeReturns(retVal,node.getVardef().apply(this, question));
		}

		mergeReturns(retVal,outAVariableExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public A inAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		return defaultInPExp(node, question);
	}


	/**
	* Called by the {@link AVariableExp} node from {@link AVariableExp#apply(IAnalysis)}.
	* @param node the calling {@link AVariableExp} node
	*/
	public A outAVariableExp(AVariableExp node, Q question) throws AnalysisException
	{
		return defaultOutPExp(node, question);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public A caseAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAbsoluteUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAAbsoluteUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public A inAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AAbsoluteUnaryExp} node from {@link AAbsoluteUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAbsoluteUnaryExp} node
	*/
	public A outAAbsoluteUnaryExp(AAbsoluteUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public A caseACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACardinalityUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outACardinalityUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public A inACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ACardinalityUnaryExp} node from {@link ACardinalityUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACardinalityUnaryExp} node
	*/
	public A outACardinalityUnaryExp(ACardinalityUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public A caseADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADistConcatUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outADistConcatUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public A inADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistConcatUnaryExp} node from {@link ADistConcatUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistConcatUnaryExp} node
	*/
	public A outADistConcatUnaryExp(ADistConcatUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public A caseADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADistIntersectUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outADistIntersectUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public A inADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistIntersectUnaryExp} node from {@link ADistIntersectUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistIntersectUnaryExp} node
	*/
	public A outADistIntersectUnaryExp(ADistIntersectUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public A caseADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADistMergeUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outADistMergeUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public A inADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistMergeUnaryExp} node from {@link ADistMergeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistMergeUnaryExp} node
	*/
	public A outADistMergeUnaryExp(ADistMergeUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public A caseADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADistUnionUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outADistUnionUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public A inADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ADistUnionUnaryExp} node from {@link ADistUnionUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADistUnionUnaryExp} node
	*/
	public A outADistUnionUnaryExp(ADistUnionUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public A caseAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAElementsUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAElementsUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public A inAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AElementsUnaryExp} node from {@link AElementsUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AElementsUnaryExp} node
	*/
	public A outAElementsUnaryExp(AElementsUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public A caseAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFloorUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAFloorUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public A inAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AFloorUnaryExp} node from {@link AFloorUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnaryExp} node
	*/
	public A outAFloorUnaryExp(AFloorUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public A caseAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAHeadUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAHeadUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public A inAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AHeadUnaryExp} node from {@link AHeadUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AHeadUnaryExp} node
	*/
	public A outAHeadUnaryExp(AHeadUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public A caseAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIndicesUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAIndicesUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public A inAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AIndicesUnaryExp} node from {@link AIndicesUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AIndicesUnaryExp} node
	*/
	public A outAIndicesUnaryExp(AIndicesUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public A caseALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALenUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outALenUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public A inALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ALenUnaryExp} node from {@link ALenUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALenUnaryExp} node
	*/
	public A outALenUnaryExp(ALenUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public A caseAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapDomainUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAMapDomainUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public A inAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapDomainUnaryExp} node from {@link AMapDomainUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapDomainUnaryExp} node
	*/
	public A outAMapDomainUnaryExp(AMapDomainUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public A caseAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapInverseUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			mergeReturns(retVal,node.getMapType().apply(this, question));
		}

		mergeReturns(retVal,outAMapInverseUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public A inAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapInverseUnaryExp} node from {@link AMapInverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapInverseUnaryExp} node
	*/
	public A outAMapInverseUnaryExp(AMapInverseUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public A caseAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapRangeUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAMapRangeUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public A inAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AMapRangeUnaryExp} node from {@link AMapRangeUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapRangeUnaryExp} node
	*/
	public A outAMapRangeUnaryExp(AMapRangeUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public A caseANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANotUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outANotUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public A inANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ANotUnaryExp} node from {@link ANotUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotUnaryExp} node
	*/
	public A outANotUnaryExp(ANotUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public A caseAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPowerSetUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAPowerSetUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public A inAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link APowerSetUnaryExp} node from {@link APowerSetUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APowerSetUnaryExp} node
	*/
	public A outAPowerSetUnaryExp(APowerSetUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public A caseAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAReverseUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAReverseUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public A inAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AReverseUnaryExp} node from {@link AReverseUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AReverseUnaryExp} node
	*/
	public A outAReverseUnaryExp(AReverseUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public A caseATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATailUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outATailUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public A inATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link ATailUnaryExp} node from {@link ATailUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATailUnaryExp} node
	*/
	public A outATailUnaryExp(ATailUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public A caseAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnaryMinusUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAUnaryMinusUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public A inAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryMinusUnaryExp} node from {@link AUnaryMinusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryMinusUnaryExp} node
	*/
	public A outAUnaryMinusUnaryExp(AUnaryMinusUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public A caseAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnaryPlusUnaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAUnaryPlusUnaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public A inAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		return defaultInSUnaryExp(node, question);
	}


	/**
	* Called by the {@link AUnaryPlusUnaryExp} node from {@link AUnaryPlusUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryPlusUnaryExp} node
	*/
	public A outAUnaryPlusUnaryExp(AUnaryPlusUnaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSUnaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public A defaultInSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public A defaultOutSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public A defaultSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public A inSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SBooleanBinaryExp} node from {@link SBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SBooleanBinaryExp} node
	*/
	public A outSBooleanBinaryExp(SBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public A caseACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACompBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outACompBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public A inACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ACompBinaryExp} node from {@link ACompBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ACompBinaryExp} node
	*/
	public A outACompBinaryExp(ACompBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public A caseADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADomainResByBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outADomainResByBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public A inADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResByBinaryExp} node from {@link ADomainResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResByBinaryExp} node
	*/
	public A outADomainResByBinaryExp(ADomainResByBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public A caseADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADomainResToBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outADomainResToBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public A inADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADomainResToBinaryExp} node from {@link ADomainResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADomainResToBinaryExp} node
	*/
	public A outADomainResToBinaryExp(ADomainResToBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public A caseAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAEqualsBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAEqualsBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public A inAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEqualsBinaryExp} node from {@link AEqualsBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsBinaryExp} node
	*/
	public A outAEqualsBinaryExp(AEqualsBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public A caseAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAInSetBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAInSetBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public A inAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AInSetBinaryExp} node from {@link AInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AInSetBinaryExp} node
	*/
	public A outAInSetBinaryExp(AInSetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public A caseAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapUnionBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAMapUnionBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public A inAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapUnionBinaryExp} node from {@link AMapUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionBinaryExp} node
	*/
	public A outAMapUnionBinaryExp(AMapUnionBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public A caseANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANotEqualBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outANotEqualBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public A inANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotEqualBinaryExp} node from {@link ANotEqualBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotEqualBinaryExp} node
	*/
	public A outANotEqualBinaryExp(ANotEqualBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public A caseANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANotInSetBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outANotInSetBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public A inANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ANotInSetBinaryExp} node from {@link ANotInSetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ANotInSetBinaryExp} node
	*/
	public A outANotInSetBinaryExp(ANotInSetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public A defaultInSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public A defaultOutSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public A defaultSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public A inSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link SNumericBinaryExp} node from {@link SNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBinaryExp} node
	*/
	public A outSNumericBinaryExp(SNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public A caseAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPlusPlusBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAPlusPlusBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public A inAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusPlusBinaryExp} node from {@link APlusPlusBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusPlusBinaryExp} node
	*/
	public A outAPlusPlusBinaryExp(APlusPlusBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public A caseAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAProperSubsetBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAProperSubsetBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public A inAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AProperSubsetBinaryExp} node from {@link AProperSubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AProperSubsetBinaryExp} node
	*/
	public A outAProperSubsetBinaryExp(AProperSubsetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public A caseARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARangeResByBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outARangeResByBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public A inARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResByBinaryExp} node from {@link ARangeResByBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResByBinaryExp} node
	*/
	public A outARangeResByBinaryExp(ARangeResByBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public A caseARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARangeResToBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outARangeResToBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public A inARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARangeResToBinaryExp} node from {@link ARangeResToBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARangeResToBinaryExp} node
	*/
	public A outARangeResToBinaryExp(ARangeResToBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public A caseASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeqConcatBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASeqConcatBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public A inASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASeqConcatBinaryExp} node from {@link ASeqConcatBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqConcatBinaryExp} node
	*/
	public A outASeqConcatBinaryExp(ASeqConcatBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public A caseASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetDifferenceBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASetDifferenceBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public A inASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetDifferenceBinaryExp} node from {@link ASetDifferenceBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetDifferenceBinaryExp} node
	*/
	public A outASetDifferenceBinaryExp(ASetDifferenceBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public A caseASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetIntersectBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASetIntersectBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public A inASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetIntersectBinaryExp} node from {@link ASetIntersectBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetIntersectBinaryExp} node
	*/
	public A outASetIntersectBinaryExp(ASetIntersectBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public A caseASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetUnionBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASetUnionBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public A inASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASetUnionBinaryExp} node from {@link ASetUnionBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetUnionBinaryExp} node
	*/
	public A outASetUnionBinaryExp(ASetUnionBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public A caseAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStarStarBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAStarStarBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public A inAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AStarStarBinaryExp} node from {@link AStarStarBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AStarStarBinaryExp} node
	*/
	public A outAStarStarBinaryExp(AStarStarBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public A caseASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASubsetBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASubsetBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public A inASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubsetBinaryExp} node from {@link ASubsetBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubsetBinaryExp} node
	*/
	public A outASubsetBinaryExp(ASubsetBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBinaryExp(node, question);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public A caseAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAndBooleanBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAAndBooleanBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public A inAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AAndBooleanBinaryExp} node from {@link AAndBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AAndBooleanBinaryExp} node
	*/
	public A outAAndBooleanBinaryExp(AAndBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public A caseAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAEquivalentBooleanBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAEquivalentBooleanBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public A inAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AEquivalentBooleanBinaryExp} node from {@link AEquivalentBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AEquivalentBooleanBinaryExp} node
	*/
	public A outAEquivalentBooleanBinaryExp(AEquivalentBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public A caseAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAImpliesBooleanBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAImpliesBooleanBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public A inAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AImpliesBooleanBinaryExp} node from {@link AImpliesBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBooleanBinaryExp} node
	*/
	public A outAImpliesBooleanBinaryExp(AImpliesBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public A caseAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAOrBooleanBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAOrBooleanBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public A inAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link AOrBooleanBinaryExp} node from {@link AOrBooleanBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AOrBooleanBinaryExp} node
	*/
	public A outAOrBooleanBinaryExp(AOrBooleanBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSBooleanBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public A caseADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADivNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outADivNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public A inADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivNumericBinaryExp} node from {@link ADivNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivNumericBinaryExp} node
	*/
	public A outADivNumericBinaryExp(ADivNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public A caseADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADivideNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outADivideNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public A inADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ADivideNumericBinaryExp} node from {@link ADivideNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ADivideNumericBinaryExp} node
	*/
	public A outADivideNumericBinaryExp(ADivideNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public A caseAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAGreaterEqualNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAGreaterEqualNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public A inAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterEqualNumericBinaryExp} node from {@link AGreaterEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterEqualNumericBinaryExp} node
	*/
	public A outAGreaterEqualNumericBinaryExp(AGreaterEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public A caseAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAGreaterNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAGreaterNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public A inAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AGreaterNumericBinaryExp} node from {@link AGreaterNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AGreaterNumericBinaryExp} node
	*/
	public A outAGreaterNumericBinaryExp(AGreaterNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public A caseALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALessEqualNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outALessEqualNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public A inALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessEqualNumericBinaryExp} node from {@link ALessEqualNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualNumericBinaryExp} node
	*/
	public A outALessEqualNumericBinaryExp(ALessEqualNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public A caseALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALessNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outALessNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public A inALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ALessNumericBinaryExp} node from {@link ALessNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ALessNumericBinaryExp} node
	*/
	public A outALessNumericBinaryExp(ALessNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public A caseAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAModNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAModNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public A inAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AModNumericBinaryExp} node from {@link AModNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AModNumericBinaryExp} node
	*/
	public A outAModNumericBinaryExp(AModNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public A caseAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPlusNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAPlusNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public A inAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link APlusNumericBinaryExp} node from {@link APlusNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link APlusNumericBinaryExp} node
	*/
	public A outAPlusNumericBinaryExp(APlusNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public A caseARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARemNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outARemNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public A inARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ARemNumericBinaryExp} node from {@link ARemNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ARemNumericBinaryExp} node
	*/
	public A outARemNumericBinaryExp(ARemNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public A caseASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASubtractNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outASubtractNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public A inASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ASubtractNumericBinaryExp} node from {@link ASubtractNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ASubtractNumericBinaryExp} node
	*/
	public A outASubtractNumericBinaryExp(ASubtractNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public A caseATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATimesNumericBinaryExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getOp() != null ) 
		{
			mergeReturns(retVal,node.getOp().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outATimesNumericBinaryExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public A inATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultInSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link ATimesNumericBinaryExp} node from {@link ATimesNumericBinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimesNumericBinaryExp} node
	*/
	public A outATimesNumericBinaryExp(ATimesNumericBinaryExp node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBinaryExp(node, question);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public A caseAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapCompMapExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			mergeReturns(retVal,node.getFirst().apply(this, question));
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outAMapCompMapExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public A inAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		return defaultInSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapCompMapExp} node from {@link AMapCompMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapCompMapExp} node
	*/
	public A outAMapCompMapExp(AMapCompMapExp node, Q question) throws AnalysisException
	{
		return defaultOutSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public A caseAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapEnumMapExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<AMapletExp> copy = new ArrayList<AMapletExp>(node.getMembers());
			for( AMapletExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getDomTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getRngTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAMapEnumMapExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public A inAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		return defaultInSMapExp(node, question);
	}


	/**
	* Called by the {@link AMapEnumMapExp} node from {@link AMapEnumMapExp#apply(IAnalysis)}.
	* @param node the calling {@link AMapEnumMapExp} node
	*/
	public A outAMapEnumMapExp(AMapEnumMapExp node, Q question) throws AnalysisException
	{
		return defaultOutSMapExp(node, question);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public A caseASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeqCompSeqExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			mergeReturns(retVal,node.getFirst().apply(this, question));
		}
		if(node.getSetBind() != null && !_visitedNodes.contains(node.getSetBind())) 
		{
			mergeReturns(retVal,node.getSetBind().apply(this, question));
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outASeqCompSeqExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public A inASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		return defaultInSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqCompSeqExp} node from {@link ASeqCompSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqCompSeqExp} node
	*/
	public A outASeqCompSeqExp(ASeqCompSeqExp node, Q question) throws AnalysisException
	{
		return defaultOutSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public A caseASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeqEnumSeqExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASeqEnumSeqExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public A inASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		return defaultInSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASeqEnumSeqExp} node from {@link ASeqEnumSeqExp#apply(IAnalysis)}.
	* @param node the calling {@link ASeqEnumSeqExp} node
	*/
	public A outASeqEnumSeqExp(ASeqEnumSeqExp node, Q question) throws AnalysisException
	{
		return defaultOutSSeqExp(node, question);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public A caseASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetCompSetExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			mergeReturns(retVal,node.getSetType().apply(this, question));
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			mergeReturns(retVal,node.getFirst().apply(this, question));
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getPredicate() != null && !_visitedNodes.contains(node.getPredicate())) 
		{
			mergeReturns(retVal,node.getPredicate().apply(this, question));
		}

		mergeReturns(retVal,outASetCompSetExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public A inASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		return defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetCompSetExp} node from {@link ASetCompSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetCompSetExp} node
	*/
	public A outASetCompSetExp(ASetCompSetExp node, Q question) throws AnalysisException
	{
		return defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public A caseASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetEnumSetExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			mergeReturns(retVal,node.getSetType().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getMembers());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASetEnumSetExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public A inASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		return defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetEnumSetExp} node from {@link ASetEnumSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetEnumSetExp} node
	*/
	public A outASetEnumSetExp(ASetEnumSetExp node, Q question) throws AnalysisException
	{
		return defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public A caseASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetRangeSetExp(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			mergeReturns(retVal,node.getSetType().apply(this, question));
		}
		if(node.getFirst() != null && !_visitedNodes.contains(node.getFirst())) 
		{
			mergeReturns(retVal,node.getFirst().apply(this, question));
		}
		if(node.getLast() != null && !_visitedNodes.contains(node.getLast())) 
		{
			mergeReturns(retVal,node.getLast().apply(this, question));
		}
		if(node.getFtype() != null && !_visitedNodes.contains(node.getFtype())) 
		{
			mergeReturns(retVal,node.getFtype().apply(this, question));
		}
		if(node.getLtype() != null && !_visitedNodes.contains(node.getLtype())) 
		{
			mergeReturns(retVal,node.getLtype().apply(this, question));
		}

		mergeReturns(retVal,outASetRangeSetExp(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public A inASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		return defaultInSSetExp(node, question);
	}


	/**
	* Called by the {@link ASetRangeSetExp} node from {@link ASetRangeSetExp#apply(IAnalysis)}.
	* @param node the calling {@link ASetRangeSetExp} node
	*/
	public A outASetRangeSetExp(ASetRangeSetExp node, Q question) throws AnalysisException
	{
		return defaultOutSSetExp(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public A defaultInPModifier(PModifier node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public A defaultOutPModifier(PModifier node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public A defaultPModifier(PModifier node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public A inPModifier(PModifier node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModifier} node from {@link PModifier#apply(IAnalysis)}.
	* @param node the calling {@link PModifier} node
	*/
	public A outPModifier(PModifier node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public A caseARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARecordModifier(node, question));

		if(node.getTag() != null ) 
		{
			mergeReturns(retVal,node.getTag().apply(this, question));
		}
		if(node.getValue() != null && !_visitedNodes.contains(node.getValue())) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outARecordModifier(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public A inARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		return defaultInPModifier(node, question);
	}


	/**
	* Called by the {@link ARecordModifier} node from {@link ARecordModifier#apply(IAnalysis)}.
	* @param node the calling {@link ARecordModifier} node
	*/
	public A outARecordModifier(ARecordModifier node, Q question) throws AnalysisException
	{
		return defaultOutPModifier(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public A defaultInPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public A defaultOutPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public A defaultPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public A inPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternative} node from {@link PAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PAlternative} node
	*/
	public A outPAlternative(PAlternative node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public A caseACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACaseAlternative(node, question));

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			mergeReturns(retVal,node.getCexp().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}

		mergeReturns(retVal,outACaseAlternative(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public A inACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		return defaultInPAlternative(node, question);
	}


	/**
	* Called by the {@link ACaseAlternative} node from {@link ACaseAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternative} node
	*/
	public A outACaseAlternative(ACaseAlternative node, Q question) throws AnalysisException
	{
		return defaultOutPAlternative(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public A defaultInPType(PType node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public A defaultOutPType(PType node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public A defaultPType(PType node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public A inPType(PType node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public A outPType(PType node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public A defaultInSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public A defaultOutSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public A defaultSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		return defaultPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public A inSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SBasicType} node from {@link SBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SBasicType} node
	*/
	public A outSBasicType(SBasicType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public A caseABracketType(ABracketType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABracketType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outABracketType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public A inABracketType(ABracketType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link ABracketType} node from {@link ABracketType#apply(IAnalysis)}.
	* @param node the calling {@link ABracketType} node
	*/
	public A outABracketType(ABracketType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public A caseAClassType(AClassType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAClassType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassdef() != null && !_visitedNodes.contains(node.getClassdef())) 
		{
			mergeReturns(retVal,node.getClassdef().apply(this, question));
		}

		mergeReturns(retVal,outAClassType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public A inAClassType(AClassType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AClassType} node from {@link AClassType#apply(IAnalysis)}.
	* @param node the calling {@link AClassType} node
	*/
	public A outAClassType(AClassType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public A caseAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFunctionType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}

		mergeReturns(retVal,outAFunctionType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public A inAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AFunctionType} node from {@link AFunctionType#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionType} node
	*/
	public A outAFunctionType(AFunctionType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public A defaultInSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public A defaultOutSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public A defaultSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		return defaultPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public A inSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SInvariantType} node from {@link SInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link SInvariantType} node
	*/
	public A outSInvariantType(SInvariantType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public A defaultInSMapType(SMapType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public A defaultOutSMapType(SMapType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public A defaultSMapType(SMapType node, Q question) throws AnalysisException
	{
		return defaultPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public A inSMapType(SMapType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SMapType} node from {@link SMapType#apply(IAnalysis)}.
	* @param node the calling {@link SMapType} node
	*/
	public A outSMapType(SMapType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public A caseAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAOperationType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getParameters());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}

		mergeReturns(retVal,outAOperationType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public A inAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AOperationType} node from {@link AOperationType#apply(IAnalysis)}.
	* @param node the calling {@link AOperationType} node
	*/
	public A outAOperationType(AOperationType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public A caseAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAOptionalType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAOptionalType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public A inAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AOptionalType} node from {@link AOptionalType#apply(IAnalysis)}.
	* @param node the calling {@link AOptionalType} node
	*/
	public A outAOptionalType(AOptionalType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public A caseAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAParameterType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outAParameterType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public A inAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AParameterType} node from {@link AParameterType#apply(IAnalysis)}.
	* @param node the calling {@link AParameterType} node
	*/
	public A outAParameterType(AParameterType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public A caseAProductType(AProductType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAProductType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAProductType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public A inAProductType(AProductType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AProductType} node from {@link AProductType#apply(IAnalysis)}.
	* @param node the calling {@link AProductType} node
	*/
	public A outAProductType(AProductType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public A caseAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAQuoteType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAQuoteType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public A inAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AQuoteType} node from {@link AQuoteType#apply(IAnalysis)}.
	* @param node the calling {@link AQuoteType} node
	*/
	public A outAQuoteType(AQuoteType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public A defaultInSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public A defaultOutSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public A defaultSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		return defaultPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public A inSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link SSeqType} node from {@link SSeqType#apply(IAnalysis)}.
	* @param node the calling {@link SSeqType} node
	*/
	public A outSSeqType(SSeqType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public A caseASetType(ASetType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getSetof() != null && !_visitedNodes.contains(node.getSetof())) 
		{
			mergeReturns(retVal,node.getSetof().apply(this, question));
		}

		mergeReturns(retVal,outASetType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public A inASetType(ASetType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link ASetType} node from {@link ASetType#apply(IAnalysis)}.
	* @param node the calling {@link ASetType} node
	*/
	public A outASetType(ASetType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public A caseAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUndefinedType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAUndefinedType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public A inAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUndefinedType} node from {@link AUndefinedType#apply(IAnalysis)}.
	* @param node the calling {@link AUndefinedType} node
	*/
	public A outAUndefinedType(AUndefinedType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public A caseAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnionType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getTypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			mergeReturns(retVal,node.getSeqType().apply(this, question));
		}
		if(node.getSetType() != null && !_visitedNodes.contains(node.getSetType())) 
		{
			mergeReturns(retVal,node.getSetType().apply(this, question));
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			mergeReturns(retVal,node.getMapType().apply(this, question));
		}
		if(node.getProdType() != null && !_visitedNodes.contains(node.getProdType())) 
		{
			mergeReturns(retVal,node.getProdType().apply(this, question));
		}
		if(node.getFuncType() != null && !_visitedNodes.contains(node.getFuncType())) 
		{
			mergeReturns(retVal,node.getFuncType().apply(this, question));
		}
		if(node.getOpType() != null && !_visitedNodes.contains(node.getOpType())) 
		{
			mergeReturns(retVal,node.getOpType().apply(this, question));
		}
		if(node.getNumType() != null && !_visitedNodes.contains(node.getNumType())) 
		{
			mergeReturns(retVal,node.getNumType().apply(this, question));
		}
		if(node.getRecType() != null && !_visitedNodes.contains(node.getRecType())) 
		{
			mergeReturns(retVal,node.getRecType().apply(this, question));
		}
		if(node.getClassType() != null && !_visitedNodes.contains(node.getClassType())) 
		{
			mergeReturns(retVal,node.getClassType().apply(this, question));
		}

		mergeReturns(retVal,outAUnionType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public A inAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnionType} node from {@link AUnionType#apply(IAnalysis)}.
	* @param node the calling {@link AUnionType} node
	*/
	public A outAUnionType(AUnionType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public A caseAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnknownType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAUnknownType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public A inAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnknownType} node from {@link AUnknownType#apply(IAnalysis)}.
	* @param node the calling {@link AUnknownType} node
	*/
	public A outAUnknownType(AUnknownType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public A caseAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnresolvedType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outAUnresolvedType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public A inAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AUnresolvedType} node from {@link AUnresolvedType#apply(IAnalysis)}.
	* @param node the calling {@link AUnresolvedType} node
	*/
	public A outAUnresolvedType(AUnresolvedType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public A caseAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAVoidReturnType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAVoidReturnType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public A inAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AVoidReturnType} node from {@link AVoidReturnType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidReturnType} node
	*/
	public A outAVoidReturnType(AVoidReturnType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public A caseAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAVoidType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAVoidType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public A inAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		return defaultInPType(node, question);
	}


	/**
	* Called by the {@link AVoidType} node from {@link AVoidType#apply(IAnalysis)}.
	* @param node the calling {@link AVoidType} node
	*/
	public A outAVoidType(AVoidType node, Q question) throws AnalysisException
	{
		return defaultOutPType(node, question);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public A caseASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeqSeqType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			mergeReturns(retVal,node.getSeqof().apply(this, question));
		}

		mergeReturns(retVal,outASeqSeqType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public A inASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		return defaultInSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeqSeqType} node from {@link ASeqSeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeqSeqType} node
	*/
	public A outASeqSeqType(ASeqSeqType node, Q question) throws AnalysisException
	{
		return defaultOutSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public A caseASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeq1SeqType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getSeqof() != null && !_visitedNodes.contains(node.getSeqof())) 
		{
			mergeReturns(retVal,node.getSeqof().apply(this, question));
		}

		mergeReturns(retVal,outASeq1SeqType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public A inASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		return defaultInSSeqType(node, question);
	}


	/**
	* Called by the {@link ASeq1SeqType} node from {@link ASeq1SeqType#apply(IAnalysis)}.
	* @param node the calling {@link ASeq1SeqType} node
	*/
	public A outASeq1SeqType(ASeq1SeqType node, Q question) throws AnalysisException
	{
		return defaultOutSSeqType(node, question);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public A caseAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAInMapMapType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			mergeReturns(retVal,node.getTo().apply(this, question));
		}

		mergeReturns(retVal,outAInMapMapType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public A inAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		return defaultInSMapType(node, question);
	}


	/**
	* Called by the {@link AInMapMapType} node from {@link AInMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AInMapMapType} node
	*/
	public A outAInMapMapType(AInMapMapType node, Q question) throws AnalysisException
	{
		return defaultOutSMapType(node, question);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public A caseAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapMapType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			mergeReturns(retVal,node.getTo().apply(this, question));
		}

		mergeReturns(retVal,outAMapMapType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public A inAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		return defaultInSMapType(node, question);
	}


	/**
	* Called by the {@link AMapMapType} node from {@link AMapMapType#apply(IAnalysis)}.
	* @param node the calling {@link AMapMapType} node
	*/
	public A outAMapMapType(AMapMapType node, Q question) throws AnalysisException
	{
		return defaultOutSMapType(node, question);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public A caseANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANamedInvariantType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			mergeReturns(retVal,node.getInvDef().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outANamedInvariantType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public A inANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		return defaultInSInvariantType(node, question);
	}


	/**
	* Called by the {@link ANamedInvariantType} node from {@link ANamedInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ANamedInvariantType} node
	*/
	public A outANamedInvariantType(ANamedInvariantType node, Q question) throws AnalysisException
	{
		return defaultOutSInvariantType(node, question);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public A caseARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARecordInvariantType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getInvDef() != null && !_visitedNodes.contains(node.getInvDef())) 
		{
			mergeReturns(retVal,node.getInvDef().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outARecordInvariantType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public A inARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		return defaultInSInvariantType(node, question);
	}


	/**
	* Called by the {@link ARecordInvariantType} node from {@link ARecordInvariantType#apply(IAnalysis)}.
	* @param node the calling {@link ARecordInvariantType} node
	*/
	public A outARecordInvariantType(ARecordInvariantType node, Q question) throws AnalysisException
	{
		return defaultOutSInvariantType(node, question);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public A caseABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABooleanBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outABooleanBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public A inABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		return defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ABooleanBasicType} node from {@link ABooleanBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanBasicType} node
	*/
	public A outABooleanBasicType(ABooleanBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public A caseACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACharBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outACharBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public A inACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		return defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ACharBasicType} node from {@link ACharBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ACharBasicType} node
	*/
	public A outACharBasicType(ACharBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public A defaultInSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public A defaultOutSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public A defaultSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public A inSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link SNumericBasicType} node from {@link SNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link SNumericBasicType} node
	*/
	public A outSNumericBasicType(SNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public A caseATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATokenBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outATokenBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public A inATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		return defaultInSBasicType(node, question);
	}


	/**
	* Called by the {@link ATokenBasicType} node from {@link ATokenBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ATokenBasicType} node
	*/
	public A outATokenBasicType(ATokenBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSBasicType(node, question);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public A caseAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIntNumericBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAIntNumericBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public A inAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link AIntNumericBasicType} node from {@link AIntNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link AIntNumericBasicType} node
	*/
	public A outAIntNumericBasicType(AIntNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public A caseANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANatOneNumericBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANatOneNumericBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public A inANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatOneNumericBasicType} node from {@link ANatOneNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatOneNumericBasicType} node
	*/
	public A outANatOneNumericBasicType(ANatOneNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public A caseANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANatNumericBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANatNumericBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public A inANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ANatNumericBasicType} node from {@link ANatNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ANatNumericBasicType} node
	*/
	public A outANatNumericBasicType(ANatNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public A caseARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARationalNumericBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outARationalNumericBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public A inARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARationalNumericBasicType} node from {@link ARationalNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARationalNumericBasicType} node
	*/
	public A outARationalNumericBasicType(ARationalNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public A caseARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARealNumericBasicType(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outARealNumericBasicType(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public A inARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultInSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link ARealNumericBasicType} node from {@link ARealNumericBasicType#apply(IAnalysis)}.
	* @param node the calling {@link ARealNumericBasicType} node
	*/
	public A outARealNumericBasicType(ARealNumericBasicType node, Q question) throws AnalysisException
	{
		return defaultOutSNumericBasicType(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public A defaultInPField(PField node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public A defaultOutPField(PField node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public A defaultPField(PField node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public A inPField(PField node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PField} node from {@link PField#apply(IAnalysis)}.
	* @param node the calling {@link PField} node
	*/
	public A outPField(PField node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public A caseAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFieldField(node, question));

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getTagname() != null ) 
		{
			mergeReturns(retVal,node.getTagname().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAFieldField(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public A inAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		return defaultInPField(node, question);
	}


	/**
	* Called by the {@link AFieldField} node from {@link AFieldField#apply(IAnalysis)}.
	* @param node the calling {@link AFieldField} node
	*/
	public A outAFieldField(AFieldField node, Q question) throws AnalysisException
	{
		return defaultOutPField(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public A defaultInPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public A defaultOutPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public A defaultPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public A inPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccessSpecifier} node from {@link PAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link PAccessSpecifier} node
	*/
	public A outPAccessSpecifier(PAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public A caseAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAccessSpecifierAccessSpecifier(node, question));

		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getStatic() != null && !_visitedNodes.contains(node.getStatic())) 
		{
			mergeReturns(retVal,node.getStatic().apply(this, question));
		}
		if(node.getAsync() != null && !_visitedNodes.contains(node.getAsync())) 
		{
			mergeReturns(retVal,node.getAsync().apply(this, question));
		}

		mergeReturns(retVal,outAAccessSpecifierAccessSpecifier(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public A inAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultInPAccessSpecifier(node, question);
	}


	/**
	* Called by the {@link AAccessSpecifierAccessSpecifier} node from {@link AAccessSpecifierAccessSpecifier#apply(IAnalysis)}.
	* @param node the calling {@link AAccessSpecifierAccessSpecifier} node
	*/
	public A outAAccessSpecifierAccessSpecifier(AAccessSpecifierAccessSpecifier node, Q question) throws AnalysisException
	{
		return defaultOutPAccessSpecifier(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public A defaultInPAccess(PAccess node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public A defaultOutPAccess(PAccess node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public A defaultPAccess(PAccess node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public A inPAccess(PAccess node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAccess} node from {@link PAccess#apply(IAnalysis)}.
	* @param node the calling {@link PAccess} node
	*/
	public A outPAccess(PAccess node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public A caseAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPublicAccess(node, question));


		mergeReturns(retVal,outAPublicAccess(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public A inAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		return defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link APublicAccess} node from {@link APublicAccess#apply(IAnalysis)}.
	* @param node the calling {@link APublicAccess} node
	*/
	public A outAPublicAccess(APublicAccess node, Q question) throws AnalysisException
	{
		return defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public A caseAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAProtectedAccess(node, question));


		mergeReturns(retVal,outAProtectedAccess(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public A inAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		return defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link AProtectedAccess} node from {@link AProtectedAccess#apply(IAnalysis)}.
	* @param node the calling {@link AProtectedAccess} node
	*/
	public A outAProtectedAccess(AProtectedAccess node, Q question) throws AnalysisException
	{
		return defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public A caseAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPrivateAccess(node, question));


		mergeReturns(retVal,outAPrivateAccess(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public A inAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		return defaultInPAccess(node, question);
	}


	/**
	* Called by the {@link APrivateAccess} node from {@link APrivateAccess#apply(IAnalysis)}.
	* @param node the calling {@link APrivateAccess} node
	*/
	public A outAPrivateAccess(APrivateAccess node, Q question) throws AnalysisException
	{
		return defaultOutPAccess(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public A defaultInPPattern(PPattern node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public A defaultOutPPattern(PPattern node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public A defaultPPattern(PPattern node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public A inPPattern(PPattern node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPattern} node from {@link PPattern#apply(IAnalysis)}.
	* @param node the calling {@link PPattern} node
	*/
	public A outPPattern(PPattern node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public A caseABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABooleanPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outABooleanPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public A inABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ABooleanPattern} node from {@link ABooleanPattern#apply(IAnalysis)}.
	* @param node the calling {@link ABooleanPattern} node
	*/
	public A outABooleanPattern(ABooleanPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public A caseACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACharacterPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outACharacterPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public A inACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ACharacterPattern} node from {@link ACharacterPattern#apply(IAnalysis)}.
	* @param node the calling {@link ACharacterPattern} node
	*/
	public A outACharacterPattern(ACharacterPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public A caseAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAConcatenationPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAConcatenationPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public A inAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AConcatenationPattern} node from {@link AConcatenationPattern#apply(IAnalysis)}.
	* @param node the calling {@link AConcatenationPattern} node
	*/
	public A outAConcatenationPattern(AConcatenationPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public A caseAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExpressionPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outAExpressionPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public A inAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AExpressionPattern} node from {@link AExpressionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AExpressionPattern} node
	*/
	public A outAExpressionPattern(AExpressionPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public A caseAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIdentifierPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outAIdentifierPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public A inAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIdentifierPattern} node from {@link AIdentifierPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierPattern} node
	*/
	public A outAIdentifierPattern(AIdentifierPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public A caseAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIgnorePattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getAnyName() != null ) 
		{
			mergeReturns(retVal,node.getAnyName().apply(this, question));
		}

		mergeReturns(retVal,outAIgnorePattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public A inAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIgnorePattern} node from {@link AIgnorePattern#apply(IAnalysis)}.
	* @param node the calling {@link AIgnorePattern} node
	*/
	public A outAIgnorePattern(AIgnorePattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public A caseAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIntegerPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAIntegerPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public A inAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AIntegerPattern} node from {@link AIntegerPattern#apply(IAnalysis)}.
	* @param node the calling {@link AIntegerPattern} node
	*/
	public A outAIntegerPattern(AIntegerPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public A caseANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANilPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANilPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public A inANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ANilPattern} node from {@link ANilPattern#apply(IAnalysis)}.
	* @param node the calling {@link ANilPattern} node
	*/
	public A outANilPattern(ANilPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public A caseAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAQuotePattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAQuotePattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public A inAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AQuotePattern} node from {@link AQuotePattern#apply(IAnalysis)}.
	* @param node the calling {@link AQuotePattern} node
	*/
	public A outAQuotePattern(AQuotePattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public A caseARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARealPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outARealPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public A inARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ARealPattern} node from {@link ARealPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARealPattern} node
	*/
	public A outARealPattern(ARealPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public A caseARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARecordPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getTypename() != null ) 
		{
			mergeReturns(retVal,node.getTypename().apply(this, question));
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outARecordPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public A inARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ARecordPattern} node from {@link ARecordPattern#apply(IAnalysis)}.
	* @param node the calling {@link ARecordPattern} node
	*/
	public A outARecordPattern(ARecordPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public A caseASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASeqPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASeqPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public A inASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ASeqPattern} node from {@link ASeqPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASeqPattern} node
	*/
	public A outASeqPattern(ASeqPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public A caseASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASetPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public A inASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ASetPattern} node from {@link ASetPattern#apply(IAnalysis)}.
	* @param node the calling {@link ASetPattern} node
	*/
	public A outASetPattern(ASetPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public A caseAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStringPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getValue() != null ) 
		{
			mergeReturns(retVal,node.getValue().apply(this, question));
		}

		mergeReturns(retVal,outAStringPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public A inAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AStringPattern} node from {@link AStringPattern#apply(IAnalysis)}.
	* @param node the calling {@link AStringPattern} node
	*/
	public A outAStringPattern(AStringPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public A caseATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATuplePattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outATuplePattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public A inATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link ATuplePattern} node from {@link ATuplePattern#apply(IAnalysis)}.
	* @param node the calling {@link ATuplePattern} node
	*/
	public A outATuplePattern(ATuplePattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public A caseAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUnionPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAUnionPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public A inAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AUnionPattern} node from {@link AUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AUnionPattern} node
	*/
	public A outAUnionPattern(AUnionPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public A caseAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<AMapletPatternMaplet> copy = new ArrayList<AMapletPatternMaplet>(node.getMaplets());
			for( AMapletPatternMaplet e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAMapPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public A inAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AMapPattern} node from {@link AMapPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapPattern} node
	*/
	public A outAMapPattern(AMapPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public A caseAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapUnionPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAMapUnionPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public A inAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AMapUnionPattern} node from {@link AMapUnionPattern#apply(IAnalysis)}.
	* @param node the calling {@link AMapUnionPattern} node
	*/
	public A outAMapUnionPattern(AMapUnionPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public A caseAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAObjectPattern(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClassname() != null ) 
		{
			mergeReturns(retVal,node.getClassname().apply(this, question));
		}
		{
			List<ANamePatternPair> copy = new ArrayList<ANamePatternPair>(node.getFields());
			for( ANamePatternPair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAObjectPattern(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public A inAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		return defaultInPPattern(node, question);
	}


	/**
	* Called by the {@link AObjectPattern} node from {@link AObjectPattern#apply(IAnalysis)}.
	* @param node the calling {@link AObjectPattern} node
	*/
	public A outAObjectPattern(AObjectPattern node, Q question) throws AnalysisException
	{
		return defaultOutPPattern(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public A defaultInPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public A defaultOutPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public A defaultPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public A inPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMaplet} node from {@link PMaplet#apply(IAnalysis)}.
	* @param node the calling {@link PMaplet} node
	*/
	public A outPMaplet(PMaplet node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public A caseAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapletPatternMaplet(node, question));

		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			mergeReturns(retVal,node.getTo().apply(this, question));
		}

		mergeReturns(retVal,outAMapletPatternMaplet(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public A inAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		return defaultInPMaplet(node, question);
	}


	/**
	* Called by the {@link AMapletPatternMaplet} node from {@link AMapletPatternMaplet#apply(IAnalysis)}.
	* @param node the calling {@link AMapletPatternMaplet} node
	*/
	public A outAMapletPatternMaplet(AMapletPatternMaplet node, Q question) throws AnalysisException
	{
		return defaultOutPMaplet(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public A defaultInPPair(PPair node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public A defaultOutPPair(PPair node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public A defaultPPair(PPair node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public A inPPair(PPair node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPair} node from {@link PPair#apply(IAnalysis)}.
	* @param node the calling {@link PPair} node
	*/
	public A outPPair(PPair node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public A caseAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPatternTypePair(node, question));

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAPatternTypePair(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public A inAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		return defaultInPPair(node, question);
	}


	/**
	* Called by the {@link APatternTypePair} node from {@link APatternTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternTypePair} node
	*/
	public A outAPatternTypePair(APatternTypePair node, Q question) throws AnalysisException
	{
		return defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public A caseAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPatternListTypePair(node, question));

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAPatternListTypePair(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public A inAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		return defaultInPPair(node, question);
	}


	/**
	* Called by the {@link APatternListTypePair} node from {@link APatternListTypePair#apply(IAnalysis)}.
	* @param node the calling {@link APatternListTypePair} node
	*/
	public A outAPatternListTypePair(APatternListTypePair node, Q question) throws AnalysisException
	{
		return defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public A caseANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANamePatternPair(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}

		mergeReturns(retVal,outANamePatternPair(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public A inANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		return defaultInPPair(node, question);
	}


	/**
	* Called by the {@link ANamePatternPair} node from {@link ANamePatternPair#apply(IAnalysis)}.
	* @param node the calling {@link ANamePatternPair} node
	*/
	public A outANamePatternPair(ANamePatternPair node, Q question) throws AnalysisException
	{
		return defaultOutPPair(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public A defaultInPBind(PBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public A defaultOutPBind(PBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public A defaultPBind(PBind node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public A inPBind(PBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PBind} node from {@link PBind#apply(IAnalysis)}.
	* @param node the calling {@link PBind} node
	*/
	public A outPBind(PBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public A caseASetBind(ASetBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetBind(node, question));

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			mergeReturns(retVal,node.getSet().apply(this, question));
		}

		mergeReturns(retVal,outASetBind(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public A inASetBind(ASetBind node, Q question) throws AnalysisException
	{
		return defaultInPBind(node, question);
	}


	/**
	* Called by the {@link ASetBind} node from {@link ASetBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetBind} node
	*/
	public A outASetBind(ASetBind node, Q question) throws AnalysisException
	{
		return defaultOutPBind(node, question);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public A caseATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATypeBind(node, question));

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outATypeBind(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public A inATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		return defaultInPBind(node, question);
	}


	/**
	* Called by the {@link ATypeBind} node from {@link ATypeBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeBind} node
	*/
	public A outATypeBind(ATypeBind node, Q question) throws AnalysisException
	{
		return defaultOutPBind(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public A defaultInPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public A defaultOutPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public A defaultPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public A inPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PMultipleBind} node from {@link PMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link PMultipleBind} node
	*/
	public A outPMultipleBind(PMultipleBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public A caseASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASetMultipleBind(node, question));

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			mergeReturns(retVal,node.getSet().apply(this, question));
		}

		mergeReturns(retVal,outASetMultipleBind(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public A inASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		return defaultInPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ASetMultipleBind} node from {@link ASetMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ASetMultipleBind} node
	*/
	public A outASetMultipleBind(ASetMultipleBind node, Q question) throws AnalysisException
	{
		return defaultOutPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public A caseATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATypeMultipleBind(node, question));

		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getPlist());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outATypeMultipleBind(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public A inATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		return defaultInPMultipleBind(node, question);
	}


	/**
	* Called by the {@link ATypeMultipleBind} node from {@link ATypeMultipleBind#apply(IAnalysis)}.
	* @param node the calling {@link ATypeMultipleBind} node
	*/
	public A outATypeMultipleBind(ATypeMultipleBind node, Q question) throws AnalysisException
	{
		return defaultOutPMultipleBind(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public A defaultInPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public A defaultOutPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public A defaultPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public A inPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PPatternBind} node from {@link PPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link PPatternBind} node
	*/
	public A outPPatternBind(PPatternBind node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public A caseADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADefPatternBind(node, question));

		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outADefPatternBind(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public A inADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		return defaultInPPatternBind(node, question);
	}


	/**
	* Called by the {@link ADefPatternBind} node from {@link ADefPatternBind#apply(IAnalysis)}.
	* @param node the calling {@link ADefPatternBind} node
	*/
	public A outADefPatternBind(ADefPatternBind node, Q question) throws AnalysisException
	{
		return defaultOutPPatternBind(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public A defaultInPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public A defaultOutPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public A defaultPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public A inPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PDefinition} node from {@link PDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PDefinition} node
	*/
	public A outPDefinition(PDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public A caseAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAssignmentDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}

		mergeReturns(retVal,outAAssignmentDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public A inAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AAssignmentDefinition} node from {@link AAssignmentDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentDefinition} node
	*/
	public A outAAssignmentDefinition(AAssignmentDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public A caseAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAInstanceVariableDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}
		if(node.getOldname() != null ) 
		{
			mergeReturns(retVal,node.getOldname().apply(this, question));
		}

		mergeReturns(retVal,outAInstanceVariableDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public A inAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceVariableDefinition} node from {@link AInstanceVariableDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceVariableDefinition} node
	*/
	public A outAInstanceVariableDefinition(AInstanceVariableDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public A defaultInSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public A defaultOutSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public A defaultSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		return defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public A inSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SClassDefinition} node from {@link SClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SClassDefinition} node
	*/
	public A outSClassDefinition(SClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public A caseAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAClassInvariantDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outAClassInvariantDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public A inAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AClassInvariantDefinition} node from {@link AClassInvariantDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantDefinition} node
	*/
	public A outAClassInvariantDefinition(AClassInvariantDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public A caseAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAEqualsDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getTypebind() != null && !_visitedNodes.contains(node.getTypebind())) 
		{
			mergeReturns(retVal,node.getTypebind().apply(this, question));
		}
		if(node.getSetbind() != null && !_visitedNodes.contains(node.getSetbind())) 
		{
			mergeReturns(retVal,node.getSetbind().apply(this, question));
		}
		if(node.getTest() != null && !_visitedNodes.contains(node.getTest())) 
		{
			mergeReturns(retVal,node.getTest().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}
		if(node.getDefType() != null && !_visitedNodes.contains(node.getDefType())) 
		{
			mergeReturns(retVal,node.getDefType().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAEqualsDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public A inAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AEqualsDefinition} node from {@link AEqualsDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AEqualsDefinition} node
	*/
	public A outAEqualsDefinition(AEqualsDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public A defaultInSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public A defaultOutSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public A defaultSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public A inSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SFunctionDefinition} node from {@link SFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SFunctionDefinition} node
	*/
	public A outSFunctionDefinition(SFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public A caseAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExternalDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}
		if(node.getOldname() != null ) 
		{
			mergeReturns(retVal,node.getOldname().apply(this, question));
		}

		mergeReturns(retVal,outAExternalDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public A inAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AExternalDefinition} node from {@link AExternalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExternalDefinition} node
	*/
	public A outAExternalDefinition(AExternalDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public A defaultInSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public A defaultOutSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public A defaultSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public A inSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link SOperationDefinition} node from {@link SOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link SOperationDefinition} node
	*/
	public A outSOperationDefinition(SOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public A caseAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAImportedDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outAImportedDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public A inAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AImportedDefinition} node from {@link AImportedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImportedDefinition} node
	*/
	public A outAImportedDefinition(AImportedDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public A caseAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAInheritedDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getSuperdef() != null && !_visitedNodes.contains(node.getSuperdef())) 
		{
			mergeReturns(retVal,node.getSuperdef().apply(this, question));
		}
		if(node.getOldname() != null ) 
		{
			mergeReturns(retVal,node.getOldname().apply(this, question));
		}

		mergeReturns(retVal,outAInheritedDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public A inAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AInheritedDefinition} node from {@link AInheritedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInheritedDefinition} node
	*/
	public A outAInheritedDefinition(AInheritedDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public A caseALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALocalDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outALocalDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public A inALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ALocalDefinition} node from {@link ALocalDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALocalDefinition} node
	*/
	public A outALocalDefinition(ALocalDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public A caseAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMultiBindListDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PMultipleBind> copy = new ArrayList<PMultipleBind>(node.getBindings());
			for( PMultipleBind e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAMultiBindListDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public A inAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AMultiBindListDefinition} node from {@link AMultiBindListDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMultiBindListDefinition} node
	*/
	public A outAMultiBindListDefinition(AMultiBindListDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public A caseAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMutexSyncDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getOperations());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}

		mergeReturns(retVal,outAMutexSyncDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public A inAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AMutexSyncDefinition} node from {@link AMutexSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AMutexSyncDefinition} node
	*/
	public A outAMutexSyncDefinition(AMutexSyncDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public A caseANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANamedTraceDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANamedTraceDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public A inANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ANamedTraceDefinition} node from {@link ANamedTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ANamedTraceDefinition} node
	*/
	public A outANamedTraceDefinition(ANamedTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public A caseAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPerSyncDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		if(node.getGuard() != null && !_visitedNodes.contains(node.getGuard())) 
		{
			mergeReturns(retVal,node.getGuard().apply(this, question));
		}

		mergeReturns(retVal,outAPerSyncDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public A inAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link APerSyncDefinition} node from {@link APerSyncDefinition#apply(IAnalysis)}.
	* @param node the calling {@link APerSyncDefinition} node
	*/
	public A outAPerSyncDefinition(APerSyncDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public A caseARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARenamedDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outARenamedDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public A inARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ARenamedDefinition} node from {@link ARenamedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARenamedDefinition} node
	*/
	public A outARenamedDefinition(ARenamedDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public A caseAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStateDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<AFieldField> copy = new ArrayList<AFieldField>(node.getFields());
			for( AFieldField e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			mergeReturns(retVal,node.getInvPattern().apply(this, question));
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			mergeReturns(retVal,node.getInvExpression().apply(this, question));
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			mergeReturns(retVal,node.getInvdef().apply(this, question));
		}
		if(node.getInitPattern() != null && !_visitedNodes.contains(node.getInitPattern())) 
		{
			mergeReturns(retVal,node.getInitPattern().apply(this, question));
		}
		if(node.getInitExpression() != null && !_visitedNodes.contains(node.getInitExpression())) 
		{
			mergeReturns(retVal,node.getInitExpression().apply(this, question));
		}
		if(node.getInitdef() != null && !_visitedNodes.contains(node.getInitdef())) 
		{
			mergeReturns(retVal,node.getInitdef().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getStateDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getRecordDefinition() != null && !_visitedNodes.contains(node.getRecordDefinition())) 
		{
			mergeReturns(retVal,node.getRecordDefinition().apply(this, question));
		}
		if(node.getRecordType() != null && !_visitedNodes.contains(node.getRecordType())) 
		{
			mergeReturns(retVal,node.getRecordType().apply(this, question));
		}

		mergeReturns(retVal,outAStateDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public A inAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AStateDefinition} node from {@link AStateDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AStateDefinition} node
	*/
	public A outAStateDefinition(AStateDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public A caseAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAThreadDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}
		if(node.getOperationName() != null ) 
		{
			mergeReturns(retVal,node.getOperationName().apply(this, question));
		}
		if(node.getOperationDef() != null && !_visitedNodes.contains(node.getOperationDef())) 
		{
			mergeReturns(retVal,node.getOperationDef().apply(this, question));
		}

		mergeReturns(retVal,outAThreadDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public A inAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AThreadDefinition} node from {@link AThreadDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AThreadDefinition} node
	*/
	public A outAThreadDefinition(AThreadDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public A caseATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATypeDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getInvType() != null && !_visitedNodes.contains(node.getInvType())) 
		{
			mergeReturns(retVal,node.getInvType().apply(this, question));
		}
		if(node.getInvPattern() != null && !_visitedNodes.contains(node.getInvPattern())) 
		{
			mergeReturns(retVal,node.getInvPattern().apply(this, question));
		}
		if(node.getInvExpression() != null && !_visitedNodes.contains(node.getInvExpression())) 
		{
			mergeReturns(retVal,node.getInvExpression().apply(this, question));
		}
		if(node.getInvdef() != null && !_visitedNodes.contains(node.getInvdef())) 
		{
			mergeReturns(retVal,node.getInvdef().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getComposeDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outATypeDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public A inATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link ATypeDefinition} node from {@link ATypeDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ATypeDefinition} node
	*/
	public A outATypeDefinition(ATypeDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public A caseAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAUntypedDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAUntypedDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public A inAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AUntypedDefinition} node from {@link AUntypedDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AUntypedDefinition} node
	*/
	public A outAUntypedDefinition(AUntypedDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public A caseAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAValueDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}

		mergeReturns(retVal,outAValueDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public A inAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		return defaultInPDefinition(node, question);
	}


	/**
	* Called by the {@link AValueDefinition} node from {@link AValueDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AValueDefinition} node
	*/
	public A outAValueDefinition(AValueDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public A caseAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExplicitFunctionDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			mergeReturns(retVal,node.getPrecondition().apply(this, question));
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			mergeReturns(retVal,node.getPostcondition().apply(this, question));
		}
		if(node.getMeasure() != null ) 
		{
			mergeReturns(retVal,node.getMeasure().apply(this, question));
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			mergeReturns(retVal,node.getPredef().apply(this, question));
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			mergeReturns(retVal,node.getPostdef().apply(this, question));
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			mergeReturns(retVal,node.getMeasureDef().apply(this, question));
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			mergeReturns(retVal,node.getExpectedResult().apply(this, question));
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			mergeReturns(retVal,node.getActualResult().apply(this, question));
		}
		{
			List<List<PPattern>> copy = new ArrayList<List<PPattern>>(node.getParamPatternList());
			for( List<PPattern> list : copy) {
				for( PPattern e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						mergeReturns(retVal,e.apply(this, question));
					}
				}
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitionList());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAExplicitFunctionDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public A inAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultInSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitFunctionDefinition} node from {@link AExplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitFunctionDefinition} node
	*/
	public A outAExplicitFunctionDefinition(AExplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public A caseAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAImplicitFunctionDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			mergeReturns(retVal,node.getPrecondition().apply(this, question));
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			mergeReturns(retVal,node.getPostcondition().apply(this, question));
		}
		if(node.getMeasure() != null ) 
		{
			mergeReturns(retVal,node.getMeasure().apply(this, question));
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			mergeReturns(retVal,node.getPredef().apply(this, question));
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			mergeReturns(retVal,node.getPostdef().apply(this, question));
		}
		if(node.getMeasureDef() != null && !_visitedNodes.contains(node.getMeasureDef())) 
		{
			mergeReturns(retVal,node.getMeasureDef().apply(this, question));
		}
		if(node.getExpectedResult() != null && !_visitedNodes.contains(node.getExpectedResult())) 
		{
			mergeReturns(retVal,node.getExpectedResult().apply(this, question));
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			mergeReturns(retVal,node.getActualResult().apply(this, question));
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParamPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAImplicitFunctionDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public A inAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultInSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitFunctionDefinition} node from {@link AImplicitFunctionDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitFunctionDefinition} node
	*/
	public A outAImplicitFunctionDefinition(AImplicitFunctionDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSFunctionDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public A caseAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExplicitOperationDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			mergeReturns(retVal,node.getPrecondition().apply(this, question));
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			mergeReturns(retVal,node.getPostcondition().apply(this, question));
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			mergeReturns(retVal,node.getPredef().apply(this, question));
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			mergeReturns(retVal,node.getPostdef().apply(this, question));
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			mergeReturns(retVal,node.getActualResult().apply(this, question));
		}
		{
			List<PPattern> copy = new ArrayList<PPattern>(node.getParameterPatterns());
			for( PPattern e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getParamDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAExplicitOperationDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public A inAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultInSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AExplicitOperationDefinition} node from {@link AExplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AExplicitOperationDefinition} node
	*/
	public A outAExplicitOperationDefinition(AExplicitOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public A caseAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAImplicitOperationDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			mergeReturns(retVal,node.getPrecondition().apply(this, question));
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			mergeReturns(retVal,node.getPostcondition().apply(this, question));
		}
		if(node.getPredef() != null && !_visitedNodes.contains(node.getPredef())) 
		{
			mergeReturns(retVal,node.getPredef().apply(this, question));
		}
		if(node.getPostdef() != null && !_visitedNodes.contains(node.getPostdef())) 
		{
			mergeReturns(retVal,node.getPostdef().apply(this, question));
		}
		if(node.getState() != null && !_visitedNodes.contains(node.getState())) 
		{
			mergeReturns(retVal,node.getState().apply(this, question));
		}
		if(node.getActualResult() != null && !_visitedNodes.contains(node.getActualResult())) 
		{
			mergeReturns(retVal,node.getActualResult().apply(this, question));
		}
		{
			List<APatternListTypePair> copy = new ArrayList<APatternListTypePair>(node.getParameterPatterns());
			for( APatternListTypePair e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			mergeReturns(retVal,node.getStateDefinition().apply(this, question));
		}

		mergeReturns(retVal,outAImplicitOperationDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public A inAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultInSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link AImplicitOperationDefinition} node from {@link AImplicitOperationDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AImplicitOperationDefinition} node
	*/
	public A outAImplicitOperationDefinition(AImplicitOperationDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSOperationDefinition(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public A defaultInPTerm(PTerm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public A defaultOutPTerm(PTerm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public A defaultPTerm(PTerm node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public A inPTerm(PTerm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTerm} node from {@link PTerm#apply(IAnalysis)}.
	* @param node the calling {@link PTerm} node
	*/
	public A outPTerm(PTerm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public A caseATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATraceDefinitionTerm(node, question));

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getList());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outATraceDefinitionTerm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public A inATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		return defaultInPTerm(node, question);
	}


	/**
	* Called by the {@link ATraceDefinitionTerm} node from {@link ATraceDefinitionTerm#apply(IAnalysis)}.
	* @param node the calling {@link ATraceDefinitionTerm} node
	*/
	public A outATraceDefinitionTerm(ATraceDefinitionTerm node, Q question) throws AnalysisException
	{
		return defaultOutPTerm(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public A defaultInPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public A defaultOutPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public A defaultPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public A inPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceDefinition} node from {@link PTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceDefinition} node
	*/
	public A outPTraceDefinition(PTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public A caseAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAInstanceTraceDefinition(node, question));


		mergeReturns(retVal,outAInstanceTraceDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public A inAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link AInstanceTraceDefinition} node from {@link AInstanceTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AInstanceTraceDefinition} node
	*/
	public A outAInstanceTraceDefinition(AInstanceTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public A caseALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetBeStBindingTraceDefinition(node, question));

		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		if(node.getStexp() != null && !_visitedNodes.contains(node.getStexp())) 
		{
			mergeReturns(retVal,node.getStexp().apply(this, question));
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outALetBeStBindingTraceDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public A inALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetBeStBindingTraceDefinition} node from {@link ALetBeStBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStBindingTraceDefinition} node
	*/
	public A outALetBeStBindingTraceDefinition(ALetBeStBindingTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public A caseALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetDefBindingTraceDefinition(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}

		mergeReturns(retVal,outALetDefBindingTraceDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public A inALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ALetDefBindingTraceDefinition} node from {@link ALetDefBindingTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ALetDefBindingTraceDefinition} node
	*/
	public A outALetDefBindingTraceDefinition(ALetDefBindingTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public A caseARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inARepeatTraceDefinition(node, question));

		if(node.getCore() != null && !_visitedNodes.contains(node.getCore())) 
		{
			mergeReturns(retVal,node.getCore().apply(this, question));
		}

		mergeReturns(retVal,outARepeatTraceDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public A inARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link ARepeatTraceDefinition} node from {@link ARepeatTraceDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ARepeatTraceDefinition} node
	*/
	public A outARepeatTraceDefinition(ARepeatTraceDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceDefinition(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public A defaultInPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public A defaultOutPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public A defaultPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public A inPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PTraceCoreDefinition} node from {@link PTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link PTraceCoreDefinition} node
	*/
	public A outPTraceCoreDefinition(PTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public A caseAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAApplyExpressionTraceCoreDefinition(node, question));

		if(node.getCallStatement() != null && !_visitedNodes.contains(node.getCallStatement())) 
		{
			mergeReturns(retVal,node.getCallStatement().apply(this, question));
		}

		mergeReturns(retVal,outAApplyExpressionTraceCoreDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public A inAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AApplyExpressionTraceCoreDefinition} node from {@link AApplyExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AApplyExpressionTraceCoreDefinition} node
	*/
	public A outAApplyExpressionTraceCoreDefinition(AApplyExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public A caseABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABracketedExpressionTraceCoreDefinition(node, question));

		{
			List<ATraceDefinitionTerm> copy = new ArrayList<ATraceDefinitionTerm>(node.getTerms());
			for( ATraceDefinitionTerm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outABracketedExpressionTraceCoreDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public A inABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABracketedExpressionTraceCoreDefinition} node from {@link ABracketedExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABracketedExpressionTraceCoreDefinition} node
	*/
	public A outABracketedExpressionTraceCoreDefinition(ABracketedExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public A caseAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAConcurrentExpressionTraceCoreDefinition(node, question));

		{
			List<PTraceDefinition> copy = new ArrayList<PTraceDefinition>(node.getDefs());
			for( PTraceDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAConcurrentExpressionTraceCoreDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public A inAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultInPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link AConcurrentExpressionTraceCoreDefinition} node from {@link AConcurrentExpressionTraceCoreDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AConcurrentExpressionTraceCoreDefinition} node
	*/
	public A outAConcurrentExpressionTraceCoreDefinition(AConcurrentExpressionTraceCoreDefinition node, Q question) throws AnalysisException
	{
		return defaultOutPTraceCoreDefinition(node, question);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public A caseABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABusClassDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			mergeReturns(retVal,node.getClasstype().apply(this, question));
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			mergeReturns(retVal,node.getInvariant().apply(this, question));
		}
		if(node.getInstance() != null && !_visitedNodes.contains(node.getInstance())) 
		{
			mergeReturns(retVal,node.getInstance().apply(this, question));
		}

		mergeReturns(retVal,outABusClassDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public A inABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ABusClassDefinition} node from {@link ABusClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ABusClassDefinition} node
	*/
	public A outABusClassDefinition(ABusClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public A caseACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACpuClassDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			mergeReturns(retVal,node.getClasstype().apply(this, question));
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			mergeReturns(retVal,node.getInvariant().apply(this, question));
		}

		mergeReturns(retVal,outACpuClassDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public A inACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ACpuClassDefinition} node from {@link ACpuClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ACpuClassDefinition} node
	*/
	public A outACpuClassDefinition(ACpuClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public A caseASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASystemClassDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			mergeReturns(retVal,node.getClasstype().apply(this, question));
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			mergeReturns(retVal,node.getInvariant().apply(this, question));
		}

		mergeReturns(retVal,outASystemClassDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public A inASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link ASystemClassDefinition} node from {@link ASystemClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link ASystemClassDefinition} node
	*/
	public A outASystemClassDefinition(ASystemClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public A caseAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAClassClassDefinition(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getAccess() != null && !_visitedNodes.contains(node.getAccess())) 
		{
			mergeReturns(retVal,node.getAccess().apply(this, question));
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PType> copy = new ArrayList<PType>(node.getSupertypes());
			for( PType e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getSupernames());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getAllInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<SClassDefinition> copy = new ArrayList<SClassDefinition>(node.getSuperDefs());
			for( SClassDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getSuperInheritedDefinitions());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getClasstype() != null && !_visitedNodes.contains(node.getClasstype())) 
		{
			mergeReturns(retVal,node.getClasstype().apply(this, question));
		}
		if(node.getInvariant() != null && !_visitedNodes.contains(node.getInvariant())) 
		{
			mergeReturns(retVal,node.getInvariant().apply(this, question));
		}

		mergeReturns(retVal,outAClassClassDefinition(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public A inAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		return defaultInSClassDefinition(node, question);
	}


	/**
	* Called by the {@link AClassClassDefinition} node from {@link AClassClassDefinition#apply(IAnalysis)}.
	* @param node the calling {@link AClassClassDefinition} node
	*/
	public A outAClassClassDefinition(AClassClassDefinition node, Q question) throws AnalysisException
	{
		return defaultOutSClassDefinition(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public A defaultInPModules(PModules node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public A defaultOutPModules(PModules node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public A defaultPModules(PModules node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public A inPModules(PModules node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PModules} node from {@link PModules#apply(IAnalysis)}.
	* @param node the calling {@link PModules} node
	*/
	public A outPModules(PModules node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public A caseAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAModuleModules(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getImports() != null && !_visitedNodes.contains(node.getImports())) 
		{
			mergeReturns(retVal,node.getImports().apply(this, question));
		}
		if(node.getExports() != null && !_visitedNodes.contains(node.getExports())) 
		{
			mergeReturns(retVal,node.getExports().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getImportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getExportdefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAModuleModules(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public A inAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		return defaultInPModules(node, question);
	}


	/**
	* Called by the {@link AModuleModules} node from {@link AModuleModules#apply(IAnalysis)}.
	* @param node the calling {@link AModuleModules} node
	*/
	public A outAModuleModules(AModuleModules node, Q question) throws AnalysisException
	{
		return defaultOutPModules(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public A defaultInPImports(PImports node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public A defaultOutPImports(PImports node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public A defaultPImports(PImports node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public A inPImports(PImports node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImports} node from {@link PImports#apply(IAnalysis)}.
	* @param node the calling {@link PImports} node
	*/
	public A outPImports(PImports node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public A caseAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAModuleImports(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<AFromModuleImports> copy = new ArrayList<AFromModuleImports>(node.getImports());
			for( AFromModuleImports e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAModuleImports(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public A inAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		return defaultInPImports(node, question);
	}


	/**
	* Called by the {@link AModuleImports} node from {@link AModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleImports} node
	*/
	public A outAModuleImports(AModuleImports node, Q question) throws AnalysisException
	{
		return defaultOutPImports(node, question);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public A caseAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFromModuleImports(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<List<PImport>> copy = new ArrayList<List<PImport>>(node.getSignatures());
			for( List<PImport> list : copy) {
				for( PImport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						mergeReturns(retVal,e.apply(this, question));
					}
				}
			}
		}

		mergeReturns(retVal,outAFromModuleImports(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public A inAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		return defaultInPImports(node, question);
	}


	/**
	* Called by the {@link AFromModuleImports} node from {@link AFromModuleImports#apply(IAnalysis)}.
	* @param node the calling {@link AFromModuleImports} node
	*/
	public A outAFromModuleImports(AFromModuleImports node, Q question) throws AnalysisException
	{
		return defaultOutPImports(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public A defaultInPImport(PImport node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public A defaultOutPImport(PImport node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public A defaultPImport(PImport node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public A inPImport(PImport node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PImport} node from {@link PImport#apply(IAnalysis)}.
	* @param node the calling {@link PImport} node
	*/
	public A outPImport(PImport node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public A caseAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAllImport(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getRenamed() != null ) 
		{
			mergeReturns(retVal,node.getRenamed().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}

		mergeReturns(retVal,outAAllImport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public A inAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		return defaultInPImport(node, question);
	}


	/**
	* Called by the {@link AAllImport} node from {@link AAllImport#apply(IAnalysis)}.
	* @param node the calling {@link AAllImport} node
	*/
	public A outAAllImport(AAllImport node, Q question) throws AnalysisException
	{
		return defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public A caseATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATypeImport(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getRenamed() != null ) 
		{
			mergeReturns(retVal,node.getRenamed().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outATypeImport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public A inATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		return defaultInPImport(node, question);
	}


	/**
	* Called by the {@link ATypeImport} node from {@link ATypeImport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeImport} node
	*/
	public A outATypeImport(ATypeImport node, Q question) throws AnalysisException
	{
		return defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public A defaultInSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		return defaultInPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public A defaultOutSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		return defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public A defaultSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		return defaultPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public A inSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		return defaultInPImport(node, question);
	}


	/**
	* Called by the {@link SValueImport} node from {@link SValueImport#apply(IAnalysis)}.
	* @param node the calling {@link SValueImport} node
	*/
	public A outSValueImport(SValueImport node, Q question) throws AnalysisException
	{
		return defaultOutPImport(node, question);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public A caseAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAValueValueImport(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getRenamed() != null ) 
		{
			mergeReturns(retVal,node.getRenamed().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			mergeReturns(retVal,node.getImportType().apply(this, question));
		}

		mergeReturns(retVal,outAValueValueImport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public A inAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		return defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AValueValueImport} node from {@link AValueValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AValueValueImport} node
	*/
	public A outAValueValueImport(AValueValueImport node, Q question) throws AnalysisException
	{
		return defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public A caseAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFunctionValueImport(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getRenamed() != null ) 
		{
			mergeReturns(retVal,node.getRenamed().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			mergeReturns(retVal,node.getImportType().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getTypeParams());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}

		mergeReturns(retVal,outAFunctionValueImport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public A inAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		return defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AFunctionValueImport} node from {@link AFunctionValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionValueImport} node
	*/
	public A outAFunctionValueImport(AFunctionValueImport node, Q question) throws AnalysisException
	{
		return defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public A caseAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAOperationValueImport(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getRenamed() != null ) 
		{
			mergeReturns(retVal,node.getRenamed().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getImportType() != null && !_visitedNodes.contains(node.getImportType())) 
		{
			mergeReturns(retVal,node.getImportType().apply(this, question));
		}

		mergeReturns(retVal,outAOperationValueImport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public A inAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		return defaultInSValueImport(node, question);
	}


	/**
	* Called by the {@link AOperationValueImport} node from {@link AOperationValueImport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationValueImport} node
	*/
	public A outAOperationValueImport(AOperationValueImport node, Q question) throws AnalysisException
	{
		return defaultOutSValueImport(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public A defaultInPExports(PExports node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public A defaultOutPExports(PExports node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public A defaultPExports(PExports node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public A inPExports(PExports node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExports} node from {@link PExports#apply(IAnalysis)}.
	* @param node the calling {@link PExports} node
	*/
	public A outPExports(PExports node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public A caseAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAModuleExports(node, question));

		{
			List<List<PExport>> copy = new ArrayList<List<PExport>>(node.getExports());
			for( List<PExport> list : copy) {
				for( PExport e : list) 
			{
					if(!_visitedNodes.contains(e))
					{
						mergeReturns(retVal,e.apply(this, question));
					}
				}
			}
		}

		mergeReturns(retVal,outAModuleExports(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public A inAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		return defaultInPExports(node, question);
	}


	/**
	* Called by the {@link AModuleExports} node from {@link AModuleExports#apply(IAnalysis)}.
	* @param node the calling {@link AModuleExports} node
	*/
	public A outAModuleExports(AModuleExports node, Q question) throws AnalysisException
	{
		return defaultOutPExports(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public A defaultInPExport(PExport node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public A defaultOutPExport(PExport node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public A defaultPExport(PExport node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public A inPExport(PExport node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PExport} node from {@link PExport#apply(IAnalysis)}.
	* @param node the calling {@link PExport} node
	*/
	public A outPExport(PExport node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public A caseAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAllExport(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAAllExport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public A inAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		return defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AAllExport} node from {@link AAllExport#apply(IAnalysis)}.
	* @param node the calling {@link AAllExport} node
	*/
	public A outAAllExport(AAllExport node, Q question) throws AnalysisException
	{
		return defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public A caseAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFunctionExport(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			mergeReturns(retVal,node.getExportType().apply(this, question));
		}

		mergeReturns(retVal,outAFunctionExport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public A inAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		return defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AFunctionExport} node from {@link AFunctionExport#apply(IAnalysis)}.
	* @param node the calling {@link AFunctionExport} node
	*/
	public A outAFunctionExport(AFunctionExport node, Q question) throws AnalysisException
	{
		return defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public A caseAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAOperationExport(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			mergeReturns(retVal,node.getExportType().apply(this, question));
		}

		mergeReturns(retVal,outAOperationExport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public A inAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		return defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AOperationExport} node from {@link AOperationExport#apply(IAnalysis)}.
	* @param node the calling {@link AOperationExport} node
	*/
	public A outAOperationExport(AOperationExport node, Q question) throws AnalysisException
	{
		return defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public A caseATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATypeExport(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outATypeExport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public A inATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		return defaultInPExport(node, question);
	}


	/**
	* Called by the {@link ATypeExport} node from {@link ATypeExport#apply(IAnalysis)}.
	* @param node the calling {@link ATypeExport} node
	*/
	public A outATypeExport(ATypeExport node, Q question) throws AnalysisException
	{
		return defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public A caseAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAValueExport(node, question));

		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefinition());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getNameList());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getExportType() != null && !_visitedNodes.contains(node.getExportType())) 
		{
			mergeReturns(retVal,node.getExportType().apply(this, question));
		}

		mergeReturns(retVal,outAValueExport(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public A inAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		return defaultInPExport(node, question);
	}


	/**
	* Called by the {@link AValueExport} node from {@link AValueExport#apply(IAnalysis)}.
	* @param node the calling {@link AValueExport} node
	*/
	public A outAValueExport(AValueExport node, Q question) throws AnalysisException
	{
		return defaultOutPExport(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public A defaultInPStm(PStm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public A defaultOutPStm(PStm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public A defaultPStm(PStm node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public A inPStm(PStm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public A outPStm(PStm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public A caseAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAlwaysStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getAlways() != null && !_visitedNodes.contains(node.getAlways())) 
		{
			mergeReturns(retVal,node.getAlways().apply(this, question));
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}

		mergeReturns(retVal,outAAlwaysStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public A inAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAlwaysStm} node from {@link AAlwaysStm#apply(IAnalysis)}.
	* @param node the calling {@link AAlwaysStm} node
	*/
	public A outAAlwaysStm(AAlwaysStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public A caseAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAssignmentStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getTarget() != null && !_visitedNodes.contains(node.getTarget())) 
		{
			mergeReturns(retVal,node.getTarget().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		if(node.getTargetType() != null && !_visitedNodes.contains(node.getTargetType())) 
		{
			mergeReturns(retVal,node.getTargetType().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}
		if(node.getClassDefinition() != null && !_visitedNodes.contains(node.getClassDefinition())) 
		{
			mergeReturns(retVal,node.getClassDefinition().apply(this, question));
		}
		if(node.getStateDefinition() != null && !_visitedNodes.contains(node.getStateDefinition())) 
		{
			mergeReturns(retVal,node.getStateDefinition().apply(this, question));
		}

		mergeReturns(retVal,outAAssignmentStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public A inAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAssignmentStm} node from {@link AAssignmentStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignmentStm} node
	*/
	public A outAAssignmentStm(AAssignmentStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public A caseAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAAtomicStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<AAssignmentStm> copy = new ArrayList<AAssignmentStm>(node.getAssignments());
			for( AAssignmentStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getStatedef() != null && !_visitedNodes.contains(node.getStatedef())) 
		{
			mergeReturns(retVal,node.getStatedef().apply(this, question));
		}

		mergeReturns(retVal,outAAtomicStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public A inAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AAtomicStm} node from {@link AAtomicStm#apply(IAnalysis)}.
	* @param node the calling {@link AAtomicStm} node
	*/
	public A outAAtomicStm(AAtomicStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public A caseACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACallObjectStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getDesignator() != null && !_visitedNodes.contains(node.getDesignator())) 
		{
			mergeReturns(retVal,node.getDesignator().apply(this, question));
		}
		if(node.getClassname() != null ) 
		{
			mergeReturns(retVal,node.getClassname().apply(this, question));
		}
		if(node.getFieldname() != null ) 
		{
			mergeReturns(retVal,node.getFieldname().apply(this, question));
		}
		if(node.getField() != null ) 
		{
			mergeReturns(retVal,node.getField().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outACallObjectStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public A inACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACallObjectStm} node from {@link ACallObjectStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallObjectStm} node
	*/
	public A outACallObjectStm(ACallObjectStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public A caseACallStm(ACallStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACallStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getRootdef() != null && !_visitedNodes.contains(node.getRootdef())) 
		{
			mergeReturns(retVal,node.getRootdef().apply(this, question));
		}

		mergeReturns(retVal,outACallStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public A inACallStm(ACallStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACallStm} node from {@link ACallStm#apply(IAnalysis)}.
	* @param node the calling {@link ACallStm} node
	*/
	public A outACallStm(ACallStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public A caseACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACasesStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		{
			List<ACaseAlternativeStm> copy = new ArrayList<ACaseAlternativeStm>(node.getCases());
			for( ACaseAlternativeStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getOthers() != null && !_visitedNodes.contains(node.getOthers())) 
		{
			mergeReturns(retVal,node.getOthers().apply(this, question));
		}

		mergeReturns(retVal,outACasesStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public A inACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACasesStm} node from {@link ACasesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACasesStm} node
	*/
	public A outACasesStm(ACasesStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public A caseAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAClassInvariantStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getInvDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAClassInvariantStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public A inAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AClassInvariantStm} node from {@link AClassInvariantStm#apply(IAnalysis)}.
	* @param node the calling {@link AClassInvariantStm} node
	*/
	public A outAClassInvariantStm(AClassInvariantStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public A caseACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACyclesStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getCycles() != null && !_visitedNodes.contains(node.getCycles())) 
		{
			mergeReturns(retVal,node.getCycles().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outACyclesStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public A inACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ACyclesStm} node from {@link ACyclesStm#apply(IAnalysis)}.
	* @param node the calling {@link ACyclesStm} node
	*/
	public A outACyclesStm(ACyclesStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public A caseADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inADurationStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getDuration() != null && !_visitedNodes.contains(node.getDuration())) 
		{
			mergeReturns(retVal,node.getDuration().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outADurationStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public A inADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ADurationStm} node from {@link ADurationStm#apply(IAnalysis)}.
	* @param node the calling {@link ADurationStm} node
	*/
	public A outADurationStm(ADurationStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public A caseAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAElseIfStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getElseIf() != null && !_visitedNodes.contains(node.getElseIf())) 
		{
			mergeReturns(retVal,node.getElseIf().apply(this, question));
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			mergeReturns(retVal,node.getThenStm().apply(this, question));
		}

		mergeReturns(retVal,outAElseIfStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public A inAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AElseIfStm} node from {@link AElseIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AElseIfStm} node
	*/
	public A outAElseIfStm(AElseIfStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public A caseAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAErrorStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAErrorStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public A inAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AErrorStm} node from {@link AErrorStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorStm} node
	*/
	public A outAErrorStm(AErrorStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public A caseAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExitStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}
		if(node.getExpType() != null && !_visitedNodes.contains(node.getExpType())) 
		{
			mergeReturns(retVal,node.getExpType().apply(this, question));
		}

		mergeReturns(retVal,outAExitStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public A inAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AExitStm} node from {@link AExitStm#apply(IAnalysis)}.
	* @param node the calling {@link AExitStm} node
	*/
	public A outAExitStm(AExitStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public A caseAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAForAllStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getSet() != null && !_visitedNodes.contains(node.getSet())) 
		{
			mergeReturns(retVal,node.getSet().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outAForAllStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public A inAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForAllStm} node from {@link AForAllStm#apply(IAnalysis)}.
	* @param node the calling {@link AForAllStm} node
	*/
	public A outAForAllStm(AForAllStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public A caseAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAForIndexStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getVar() != null ) 
		{
			mergeReturns(retVal,node.getVar().apply(this, question));
		}
		if(node.getFrom() != null && !_visitedNodes.contains(node.getFrom())) 
		{
			mergeReturns(retVal,node.getFrom().apply(this, question));
		}
		if(node.getTo() != null && !_visitedNodes.contains(node.getTo())) 
		{
			mergeReturns(retVal,node.getTo().apply(this, question));
		}
		if(node.getBy() != null && !_visitedNodes.contains(node.getBy())) 
		{
			mergeReturns(retVal,node.getBy().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outAForIndexStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public A inAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForIndexStm} node from {@link AForIndexStm#apply(IAnalysis)}.
	* @param node the calling {@link AForIndexStm} node
	*/
	public A outAForIndexStm(AForIndexStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public A caseAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAForPatternBindStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			mergeReturns(retVal,node.getPatternBind().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			mergeReturns(retVal,node.getSeqType().apply(this, question));
		}

		mergeReturns(retVal,outAForPatternBindStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public A inAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AForPatternBindStm} node from {@link AForPatternBindStm#apply(IAnalysis)}.
	* @param node the calling {@link AForPatternBindStm} node
	*/
	public A outAForPatternBindStm(AForPatternBindStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public A caseAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIfStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getIfExp() != null && !_visitedNodes.contains(node.getIfExp())) 
		{
			mergeReturns(retVal,node.getIfExp().apply(this, question));
		}
		if(node.getThenStm() != null && !_visitedNodes.contains(node.getThenStm())) 
		{
			mergeReturns(retVal,node.getThenStm().apply(this, question));
		}
		{
			List<AElseIfStm> copy = new ArrayList<AElseIfStm>(node.getElseIf());
			for( AElseIfStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getElseStm() != null && !_visitedNodes.contains(node.getElseStm())) 
		{
			mergeReturns(retVal,node.getElseStm().apply(this, question));
		}

		mergeReturns(retVal,outAIfStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public A inAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AIfStm} node from {@link AIfStm#apply(IAnalysis)}.
	* @param node the calling {@link AIfStm} node
	*/
	public A outAIfStm(AIfStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public A caseALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetBeStStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getBind() != null && !_visitedNodes.contains(node.getBind())) 
		{
			mergeReturns(retVal,node.getBind().apply(this, question));
		}
		if(node.getSuchThat() != null && !_visitedNodes.contains(node.getSuchThat())) 
		{
			mergeReturns(retVal,node.getSuchThat().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}
		if(node.getDef() != null && !_visitedNodes.contains(node.getDef())) 
		{
			mergeReturns(retVal,node.getDef().apply(this, question));
		}

		mergeReturns(retVal,outALetBeStStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public A inALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ALetBeStStm} node from {@link ALetBeStStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetBeStStm} node
	*/
	public A outALetBeStStm(ALetBeStStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public A caseALetStm(ALetStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inALetStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getLocalDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outALetStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public A inALetStm(ALetStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ALetStm} node from {@link ALetStm#apply(IAnalysis)}.
	* @param node the calling {@link ALetStm} node
	*/
	public A outALetStm(ALetStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public A caseANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANotYetSpecifiedStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANotYetSpecifiedStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public A inANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ANotYetSpecifiedStm} node from {@link ANotYetSpecifiedStm#apply(IAnalysis)}.
	* @param node the calling {@link ANotYetSpecifiedStm} node
	*/
	public A outANotYetSpecifiedStm(ANotYetSpecifiedStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public A caseAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAReturnStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outAReturnStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public A inAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AReturnStm} node from {@link AReturnStm#apply(IAnalysis)}.
	* @param node the calling {@link AReturnStm} node
	*/
	public A outAReturnStm(AReturnStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public A defaultInSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public A defaultOutSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public A defaultSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public A inSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link SSimpleBlockStm} node from {@link SSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link SSimpleBlockStm} node
	*/
	public A outSSimpleBlockStm(SSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public A caseASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASkipStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outASkipStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public A inASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASkipStm} node from {@link ASkipStm#apply(IAnalysis)}.
	* @param node the calling {@link ASkipStm} node
	*/
	public A outASkipStm(ASkipStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public A caseASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASpecificationStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<AExternalClause> copy = new ArrayList<AExternalClause>(node.getExternals());
			for( AExternalClause e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getPrecondition() != null && !_visitedNodes.contains(node.getPrecondition())) 
		{
			mergeReturns(retVal,node.getPrecondition().apply(this, question));
		}
		if(node.getPostcondition() != null && !_visitedNodes.contains(node.getPostcondition())) 
		{
			mergeReturns(retVal,node.getPostcondition().apply(this, question));
		}
		{
			List<AErrorCase> copy = new ArrayList<AErrorCase>(node.getErrors());
			for( AErrorCase e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASpecificationStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public A inASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASpecificationStm} node from {@link ASpecificationStm#apply(IAnalysis)}.
	* @param node the calling {@link ASpecificationStm} node
	*/
	public A outASpecificationStm(ASpecificationStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public A caseAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStartStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			mergeReturns(retVal,node.getObj().apply(this, question));
		}

		mergeReturns(retVal,outAStartStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public A inAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AStartStm} node from {@link AStartStm#apply(IAnalysis)}.
	* @param node the calling {@link AStartStm} node
	*/
	public A outAStartStm(AStartStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public A caseAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAStopStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getObj() != null && !_visitedNodes.contains(node.getObj())) 
		{
			mergeReturns(retVal,node.getObj().apply(this, question));
		}

		mergeReturns(retVal,outAStopStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public A inAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AStopStm} node from {@link AStopStm#apply(IAnalysis)}.
	* @param node the calling {@link AStopStm} node
	*/
	public A outAStopStm(AStopStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public A caseASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASubclassResponsibilityStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outASubclassResponsibilityStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public A inASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASubclassResponsibilityStm} node from {@link ASubclassResponsibilityStm#apply(IAnalysis)}.
	* @param node the calling {@link ASubclassResponsibilityStm} node
	*/
	public A outASubclassResponsibilityStm(ASubclassResponsibilityStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public A caseATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATixeStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<ATixeStmtAlternative> copy = new ArrayList<ATixeStmtAlternative>(node.getTraps());
			for( ATixeStmtAlternative e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}

		mergeReturns(retVal,outATixeStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public A inATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ATixeStm} node from {@link ATixeStm#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStm} node
	*/
	public A outATixeStm(ATixeStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public A caseATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATrapStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			mergeReturns(retVal,node.getPatternBind().apply(this, question));
		}
		if(node.getWith() != null && !_visitedNodes.contains(node.getWith())) 
		{
			mergeReturns(retVal,node.getWith().apply(this, question));
		}
		if(node.getBody() != null && !_visitedNodes.contains(node.getBody())) 
		{
			mergeReturns(retVal,node.getBody().apply(this, question));
		}

		mergeReturns(retVal,outATrapStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public A inATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ATrapStm} node from {@link ATrapStm#apply(IAnalysis)}.
	* @param node the calling {@link ATrapStm} node
	*/
	public A outATrapStm(ATrapStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public A caseAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAWhileStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}

		mergeReturns(retVal,outAWhileStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public A inAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link AWhileStm} node from {@link AWhileStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhileStm} node
	*/
	public A outAWhileStm(AWhileStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public A caseAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAPeriodicStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAPeriodicStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public A inAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link APeriodicStm} node from {@link APeriodicStm#apply(IAnalysis)}.
	* @param node the calling {@link APeriodicStm} node
	*/
	public A outAPeriodicStm(APeriodicStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public A caseASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASporadicStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getOpname() != null ) 
		{
			mergeReturns(retVal,node.getOpname().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outASporadicStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public A inASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		return defaultInPStm(node, question);
	}


	/**
	* Called by the {@link ASporadicStm} node from {@link ASporadicStm#apply(IAnalysis)}.
	* @param node the calling {@link ASporadicStm} node
	*/
	public A outASporadicStm(ASporadicStm node, Q question) throws AnalysisException
	{
		return defaultOutPStm(node, question);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public A caseABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inABlockSimpleBlockStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		{
			List<AAssignmentDefinition> copy = new ArrayList<AAssignmentDefinition>(node.getAssignmentDefs());
			for( AAssignmentDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outABlockSimpleBlockStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public A inABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultInSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ABlockSimpleBlockStm} node from {@link ABlockSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ABlockSimpleBlockStm} node
	*/
	public A outABlockSimpleBlockStm(ABlockSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultOutSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public A caseANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANonDeterministicSimpleBlockStm(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getStatements());
			for( PStm e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outANonDeterministicSimpleBlockStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public A inANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultInSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link ANonDeterministicSimpleBlockStm} node from {@link ANonDeterministicSimpleBlockStm#apply(IAnalysis)}.
	* @param node the calling {@link ANonDeterministicSimpleBlockStm} node
	*/
	public A outANonDeterministicSimpleBlockStm(ANonDeterministicSimpleBlockStm node, Q question) throws AnalysisException
	{
		return defaultOutSSimpleBlockStm(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public A defaultInPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public A defaultOutPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public A defaultPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public A inPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStateDesignator} node from {@link PStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PStateDesignator} node
	*/
	public A outPStateDesignator(PStateDesignator node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public A caseAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFieldStateDesignator(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			mergeReturns(retVal,node.getObject().apply(this, question));
		}
		if(node.getField() != null ) 
		{
			mergeReturns(retVal,node.getField().apply(this, question));
		}
		if(node.getObjectfield() != null ) 
		{
			mergeReturns(retVal,node.getObjectfield().apply(this, question));
		}

		mergeReturns(retVal,outAFieldStateDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public A inAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		return defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldStateDesignator} node from {@link AFieldStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldStateDesignator} node
	*/
	public A outAFieldStateDesignator(AFieldStateDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public A caseAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIdentifierStateDesignator(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}

		mergeReturns(retVal,outAIdentifierStateDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public A inAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		return defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierStateDesignator} node from {@link AIdentifierStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierStateDesignator} node
	*/
	public A outAIdentifierStateDesignator(AIdentifierStateDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public A caseAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAMapSeqStateDesignator(node, question));

		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}
		if(node.getMapseq() != null && !_visitedNodes.contains(node.getMapseq())) 
		{
			mergeReturns(retVal,node.getMapseq().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}
		if(node.getMapType() != null && !_visitedNodes.contains(node.getMapType())) 
		{
			mergeReturns(retVal,node.getMapType().apply(this, question));
		}
		if(node.getSeqType() != null && !_visitedNodes.contains(node.getSeqType())) 
		{
			mergeReturns(retVal,node.getSeqType().apply(this, question));
		}

		mergeReturns(retVal,outAMapSeqStateDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public A inAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		return defaultInPStateDesignator(node, question);
	}


	/**
	* Called by the {@link AMapSeqStateDesignator} node from {@link AMapSeqStateDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AMapSeqStateDesignator} node
	*/
	public A outAMapSeqStateDesignator(AMapSeqStateDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPStateDesignator(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public A defaultInPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public A defaultOutPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public A defaultPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public A inPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PObjectDesignator} node from {@link PObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link PObjectDesignator} node
	*/
	public A outPObjectDesignator(PObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public A caseAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAApplyObjectDesignator(node, question));

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			mergeReturns(retVal,node.getObject().apply(this, question));
		}
		{
			List<PExp> copy = new ArrayList<PExp>(node.getArgs());
			for( PExp e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}

		mergeReturns(retVal,outAApplyObjectDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public A inAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AApplyObjectDesignator} node from {@link AApplyObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AApplyObjectDesignator} node
	*/
	public A outAApplyObjectDesignator(AApplyObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public A caseAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAFieldObjectDesignator(node, question));

		if(node.getObject() != null && !_visitedNodes.contains(node.getObject())) 
		{
			mergeReturns(retVal,node.getObject().apply(this, question));
		}
		if(node.getClassName() != null ) 
		{
			mergeReturns(retVal,node.getClassName().apply(this, question));
		}
		if(node.getFieldName() != null ) 
		{
			mergeReturns(retVal,node.getFieldName().apply(this, question));
		}
		if(node.getField() != null ) 
		{
			mergeReturns(retVal,node.getField().apply(this, question));
		}

		mergeReturns(retVal,outAFieldObjectDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public A inAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AFieldObjectDesignator} node from {@link AFieldObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AFieldObjectDesignator} node
	*/
	public A outAFieldObjectDesignator(AFieldObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public A caseAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAIdentifierObjectDesignator(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outAIdentifierObjectDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public A inAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link AIdentifierObjectDesignator} node from {@link AIdentifierObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierObjectDesignator} node
	*/
	public A outAIdentifierObjectDesignator(AIdentifierObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public A caseANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inANewObjectDesignator(node, question));

		if(node.getExpression() != null && !_visitedNodes.contains(node.getExpression())) 
		{
			mergeReturns(retVal,node.getExpression().apply(this, question));
		}

		mergeReturns(retVal,outANewObjectDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public A inANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ANewObjectDesignator} node from {@link ANewObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ANewObjectDesignator} node
	*/
	public A outANewObjectDesignator(ANewObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public A caseASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inASelfObjectDesignator(node, question));

		if(node.getSelf() != null ) 
		{
			mergeReturns(retVal,node.getSelf().apply(this, question));
		}

		mergeReturns(retVal,outASelfObjectDesignator(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public A inASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultInPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link ASelfObjectDesignator} node from {@link ASelfObjectDesignator#apply(IAnalysis)}.
	* @param node the calling {@link ASelfObjectDesignator} node
	*/
	public A outASelfObjectDesignator(ASelfObjectDesignator node, Q question) throws AnalysisException
	{
		return defaultOutPObjectDesignator(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public A defaultInPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public A defaultOutPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public A defaultPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public A inPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PAlternativeStm} node from {@link PAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link PAlternativeStm} node
	*/
	public A outPAlternativeStm(PAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public A caseACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inACaseAlternativeStm(node, question));

		if(node.getCexp() != null && !_visitedNodes.contains(node.getCexp())) 
		{
			mergeReturns(retVal,node.getCexp().apply(this, question));
		}
		if(node.getPattern() != null && !_visitedNodes.contains(node.getPattern())) 
		{
			mergeReturns(retVal,node.getPattern().apply(this, question));
		}
		if(node.getResult() != null && !_visitedNodes.contains(node.getResult())) 
		{
			mergeReturns(retVal,node.getResult().apply(this, question));
		}
		{
			List<PDefinition> copy = new ArrayList<PDefinition>(node.getDefs());
			for( PDefinition e : copy) 
			{
				if(!_visitedNodes.contains(e))
				{
					mergeReturns(retVal,e.apply(this, question));
				}
			}
		}
		if(node.getCtype() != null && !_visitedNodes.contains(node.getCtype())) 
		{
			mergeReturns(retVal,node.getCtype().apply(this, question));
		}

		mergeReturns(retVal,outACaseAlternativeStm(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public A inACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultInPAlternativeStm(node, question);
	}


	/**
	* Called by the {@link ACaseAlternativeStm} node from {@link ACaseAlternativeStm#apply(IAnalysis)}.
	* @param node the calling {@link ACaseAlternativeStm} node
	*/
	public A outACaseAlternativeStm(ACaseAlternativeStm node, Q question) throws AnalysisException
	{
		return defaultOutPAlternativeStm(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public A defaultInPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public A defaultOutPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public A defaultPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public A inPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PStmtAlternative} node from {@link PStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link PStmtAlternative} node
	*/
	public A outPStmtAlternative(PStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public A caseATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inATixeStmtAlternative(node, question));

		if(node.getPatternBind() != null && !_visitedNodes.contains(node.getPatternBind())) 
		{
			mergeReturns(retVal,node.getPatternBind().apply(this, question));
		}
		if(node.getStatement() != null && !_visitedNodes.contains(node.getStatement())) 
		{
			mergeReturns(retVal,node.getStatement().apply(this, question));
		}
		if(node.getExp() != null && !_visitedNodes.contains(node.getExp())) 
		{
			mergeReturns(retVal,node.getExp().apply(this, question));
		}

		mergeReturns(retVal,outATixeStmtAlternative(node, question));
		return retVal;
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public A inATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultInPStmtAlternative(node, question);
	}


	/**
	* Called by the {@link ATixeStmtAlternative} node from {@link ATixeStmtAlternative#apply(IAnalysis)}.
	* @param node the calling {@link ATixeStmtAlternative} node
	*/
	public A outATixeStmtAlternative(ATixeStmtAlternative node, Q question) throws AnalysisException
	{
		return defaultOutPStmtAlternative(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public A defaultInPClause(PClause node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public A defaultOutPClause(PClause node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public A defaultPClause(PClause node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public A inPClause(PClause node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PClause} node from {@link PClause#apply(IAnalysis)}.
	* @param node the calling {@link PClause} node
	*/
	public A outPClause(PClause node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public A caseAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAExternalClause(node, question));

		if(node.getMode() != null ) 
		{
			mergeReturns(retVal,node.getMode().apply(this, question));
		}
		{
			List<ILexNameToken> copy = new ArrayList<ILexNameToken>(node.getIdentifiers());
			for( ILexNameToken e : copy) 
			{
				mergeReturns(retVal,e.apply(this, question));
			}
		}
		if(node.getType() != null && !_visitedNodes.contains(node.getType())) 
		{
			mergeReturns(retVal,node.getType().apply(this, question));
		}

		mergeReturns(retVal,outAExternalClause(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public A inAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		return defaultInPClause(node, question);
	}


	/**
	* Called by the {@link AExternalClause} node from {@link AExternalClause#apply(IAnalysis)}.
	* @param node the calling {@link AExternalClause} node
	*/
	public A outAExternalClause(AExternalClause node, Q question) throws AnalysisException
	{
		return defaultOutPClause(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public A defaultInPCase(PCase node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public A defaultOutPCase(PCase node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public A defaultPCase(PCase node, Q question) throws AnalysisException
	{
		return defaultINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public A inPCase(PCase node, Q question) throws AnalysisException
	{
		return defaultInINode(node, question);
	}


	/**
	* Called by the {@link PCase} node from {@link PCase#apply(IAnalysis)}.
	* @param node the calling {@link PCase} node
	*/
	public A outPCase(PCase node, Q question) throws AnalysisException
	{
		return defaultOutINode(node, question);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public A caseAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		_visitedNodes.add(node);
		A retVal = createNewReturnValue(node, question);
		mergeReturns(retVal,inAErrorCase(node, question));

		if(node.getName() != null ) 
		{
			mergeReturns(retVal,node.getName().apply(this, question));
		}
		if(node.getLeft() != null && !_visitedNodes.contains(node.getLeft())) 
		{
			mergeReturns(retVal,node.getLeft().apply(this, question));
		}
		if(node.getRight() != null && !_visitedNodes.contains(node.getRight())) 
		{
			mergeReturns(retVal,node.getRight().apply(this, question));
		}

		mergeReturns(retVal,outAErrorCase(node, question));
		return retVal;
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public A inAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		return defaultInPCase(node, question);
	}


	/**
	* Called by the {@link AErrorCase} node from {@link AErrorCase#apply(IAnalysis)}.
	* @param node the calling {@link AErrorCase} node
	*/
	public A outAErrorCase(AErrorCase node, Q question) throws AnalysisException
	{
		return defaultOutPCase(node, question);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public A defaultOutINode(INode node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public A defaultInINode(INode node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public A defaultINode(INode node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A defaultOutIToken(IToken node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A defaultInIToken(IToken node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public A defaultIToken(IToken node, Q question) throws AnalysisException
	{
		return createNewReturnValue(node, question);
	}



	public abstract A mergeReturns(A original, A new_);


	public abstract A createNewReturnValue(INode node, Q question) throws AnalysisException;


	public abstract A createNewReturnValue(Object node, Q question) throws AnalysisException;


}
