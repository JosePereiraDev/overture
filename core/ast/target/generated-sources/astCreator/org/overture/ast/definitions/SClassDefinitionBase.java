/*******************************************************************************
* Copyright (c) 2009, 2011 Overture Team and others.
*
* Overture is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Overture is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Overture.  If not, see <http://www.gnu.org/licenses/>.
*
* The Overture Tool web-site: http://overturetool.org/
*******************************************************************************/

/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.overture.ast.definitions;


import org.overture.ast.definitions.PDefinition;
import org.overture.ast.definitions.AExplicitOperationDefinition;
import org.overture.ast.typechecker.ClassDefinitionSettings;
import org.overture.ast.definitions.PDefinitionBase;
import java.util.HashMap;
import org.overture.ast.definitions.SClassDefinition;
import org.overture.ast.intf.lex.ILexLocation;
import org.overture.ast.typechecker.Pass;
import java.util.List;
import org.overture.ast.intf.lex.ILexNameToken;
import org.overture.ast.types.AAccessSpecifierAccessSpecifier;
import org.overture.ast.typechecker.NameScope;
import java.util.Map;
import java.lang.Boolean;
import org.overture.ast.node.INode;
import org.overture.ast.node.GraphNodeList;
import java.lang.String;
import org.overture.ast.types.PType;
import java.util.LinkedList;


/**
* Generated file by AST Creator
* @author Kenneth Lausdahl
*
*/
public abstract class SClassDefinitionBase extends PDefinitionBase implements SClassDefinition
{
	private static final long serialVersionUID = 1L;

	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<PType> _supertypes = new GraphNodeList<PType>(this);
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<ILexNameToken> _supernames = new GraphNodeList<ILexNameToken>(this);
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<PDefinition> _definitions = new GraphNodeList<PDefinition>(this);
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<PDefinition> _allInheritedDefinitions = new GraphNodeList<PDefinition>(this);
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<PDefinition> _localInheritedDefinitions = new GraphNodeList<PDefinition>(this);
	protected Boolean _hasContructors;
	protected ClassDefinitionSettings _settingHierarchy;
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<SClassDefinition> _superDefs = new GraphNodeList<SClassDefinition>(this);
	protected Boolean _gettingInheritable;
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected GraphNodeList<PDefinition> _superInheritedDefinitions = new GraphNodeList<PDefinition>(this);
	protected Boolean _gettingInvDefs;
	protected Boolean _isAbstract;
	protected Boolean _isUndefined;
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected PType _classtype;
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected Boolean _typeChecked;
	/**
	* Graph field, parent will not be removed when added and parent 
	*  of this field may not be this node. Also excluded for visitor.
	*/
	protected AExplicitOperationDefinition _invariant;

	/**
	* Creates a new {@code SClassDefinitionBase} node with the given nodes as children.
	* @deprecated This method should not be used, use AstFactory instead.
	* The basic child nodes are removed from their previous parents.
	* @param supertypes_ the {@link GraphNodeList} <b>graph</a> node for the {@code supertypes} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code supertypes } will not be changed by adding it to this node.</i>
	* @param supernames_ the {@link GraphNodeList} <b>graph</a> node for the {@code supernames} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code supernames } will not be changed by adding it to this node.</i>
	* @param definitions_ the {@link GraphNodeList} <b>graph</a> node for the {@code definitions} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code definitions } will not be changed by adding it to this node.</i>
	* @param allInheritedDefinitions_ the {@link GraphNodeList} <b>graph</a> node for the {@code allInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code allInheritedDefinitions } will not be changed by adding it to this node.</i>
	* @param localInheritedDefinitions_ the {@link GraphNodeList} <b>graph</a> node for the {@code localInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code localInheritedDefinitions } will not be changed by adding it to this node.</i>
	* @param hasContructors_ the {@link Boolean} node for the {@code hasContructors} child of this {@link SClassDefinitionBase} node
	* @param settingHierarchy_ the {@link ClassDefinitionSettings} node for the {@code settingHierarchy} child of this {@link SClassDefinitionBase} node
	* @param superDefs_ the {@link GraphNodeList} <b>graph</a> node for the {@code superDefs} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code superDefs } will not be changed by adding it to this node.</i>
	* @param gettingInheritable_ the {@link Boolean} node for the {@code gettingInheritable} child of this {@link SClassDefinitionBase} node
	* @param superInheritedDefinitions_ the {@link GraphNodeList} <b>graph</a> node for the {@code superInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code superInheritedDefinitions } will not be changed by adding it to this node.</i>
	* @param gettingInvDefs_ the {@link Boolean} node for the {@code gettingInvDefs} child of this {@link SClassDefinitionBase} node
	* @param isAbstract_ the {@link Boolean} node for the {@code isAbstract} child of this {@link SClassDefinitionBase} node
	* @param isUndefined_ the {@link Boolean} node for the {@code isUndefined} child of this {@link SClassDefinitionBase} node
	* @param classtype_ the {@link PType} <b>graph</a> node for the {@code classtype} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code classtype } will not be changed by adding it to this node.</i>
	* @param typeChecked_ the {@link Boolean} <b>graph</a> node for the {@code typeChecked} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code typeChecked } will not be changed by adding it to this node.</i>
	* @param invariant_ the {@link AExplicitOperationDefinition} <b>graph</a> node for the {@code invariant} child of this {@link SClassDefinitionBase} node.
	*  <i>The parent of this {@code invariant } will not be changed by adding it to this node.</i>
	*/
	public SClassDefinitionBase(ILexLocation location_, ILexNameToken name_, NameScope nameScope_, Boolean used_, SClassDefinition classDefinition_, AAccessSpecifierAccessSpecifier access_, PType type_, Pass pass_, List<? extends PType> supertypes_, List<? extends ILexNameToken> supernames_, List<? extends PDefinition> definitions_, List<? extends PDefinition> allInheritedDefinitions_, List<? extends PDefinition> localInheritedDefinitions_, Boolean hasContructors_, ClassDefinitionSettings settingHierarchy_, List<? extends SClassDefinition> superDefs_, Boolean gettingInheritable_, List<? extends PDefinition> superInheritedDefinitions_, Boolean gettingInvDefs_, Boolean isAbstract_, Boolean isUndefined_, PType classtype_, Boolean typeChecked_, AExplicitOperationDefinition invariant_)
	{
		super(location_,name_,nameScope_,used_,classDefinition_,access_,type_,pass_);
		this.setSupertypes(supertypes_);
		this.setSupernames(supernames_);
		this.setDefinitions(definitions_);
		this.setAllInheritedDefinitions(allInheritedDefinitions_);
		this.setLocalInheritedDefinitions(localInheritedDefinitions_);
		this.setHasContructors(hasContructors_);
		this.setSettingHierarchy(settingHierarchy_);
		this.setSuperDefs(superDefs_);
		this.setGettingInheritable(gettingInheritable_);
		this.setSuperInheritedDefinitions(superInheritedDefinitions_);
		this.setGettingInvDefs(gettingInvDefs_);
		this.setIsAbstract(isAbstract_);
		this.setIsUndefined(isUndefined_);
		this.setClasstype(classtype_);
		this.setTypeChecked(typeChecked_);
		this.setInvariant(invariant_);

	}


	/**
	* Creates a new {@code SClassDefinitionBase TAG=#class} node with the given nodes as children.
	* @deprecated This method should not be used, use AstFactory instead.
	* The basic child nodes are removed from their previous parents.
	* @param hasContructors_ the {@link Boolean} node for the {@code hasContructors} child of this {@link SClassDefinitionBase} node
	* @param settingHierarchy_ the {@link ClassDefinitionSettings} node for the {@code settingHierarchy} child of this {@link SClassDefinitionBase} node
	* @param gettingInheritable_ the {@link Boolean} node for the {@code gettingInheritable} child of this {@link SClassDefinitionBase} node
	* @param gettingInvDefs_ the {@link Boolean} node for the {@code gettingInvDefs} child of this {@link SClassDefinitionBase} node
	* @param isAbstract_ the {@link Boolean} node for the {@code isAbstract} child of this {@link SClassDefinitionBase} node
	* @param isUndefined_ the {@link Boolean} node for the {@code isUndefined} child of this {@link SClassDefinitionBase} node
	*/
	public SClassDefinitionBase(ILexLocation location_, NameScope nameScope_, Boolean used_, AAccessSpecifierAccessSpecifier access_, Pass pass_, Boolean hasContructors_, ClassDefinitionSettings settingHierarchy_, Boolean gettingInheritable_, Boolean gettingInvDefs_, Boolean isAbstract_, Boolean isUndefined_)
	{
		super(location_,null,nameScope_,used_,null,access_,null,pass_);
		this.setHasContructors(hasContructors_);
		this.setSettingHierarchy(settingHierarchy_);
		this.setGettingInheritable(gettingInheritable_);
		this.setGettingInvDefs(gettingInvDefs_);
		this.setIsAbstract(isAbstract_);
		this.setIsUndefined(isUndefined_);
		this.setTypeChecked(false);

	}


	/**
	 * Creates a new {@link SClassDefinitionBase} node with no children.
	 */
	public SClassDefinitionBase()
	{

	}


	/**
	* Essentially this.toString().equals(o.toString()).
	**/
	@Override
	public boolean equals(Object o)
	{
		if (o != null && o instanceof SClassDefinitionBase)		{
			 return toString().equals(o.toString());
		}
		return false;
	}


	/**
	 * Creates a deep clone of this {@link SClassDefinitionBase} node while putting all
	 * old node-new node relations in the map {@code oldToNewMap}.
	 * @param oldToNewMap the map filled with the old node-new node relation
	 * @return a deep clone of this {@link SClassDefinitionBase} node
	 */
	@Override
	public abstract SClassDefinition clone(Map<INode,INode> oldToNewMap);

	/**
	 * Removes the {@link INode} {@code child} as a child of this {@link SClassDefinitionBase} node.
	 * Do not call this method with any graph fields of this node. This will cause any child's
	 * with the same reference to be removed unintentionally or {@link RuntimeException}will be thrown.
	 * @param child the child node to be removed from this {@link SClassDefinitionBase} node
	 * @throws RuntimeException if {@code child} is not a child of this {@link SClassDefinitionBase} node
	 */
	public void removeChild(INode child)
	{
		if (this._name == child) {
			return;
		}

		if (this._classDefinition == child) {
			return;
		}

		if (this._access == child) {
			this._access = null;
			return;
		}

		if (this._type == child) {
			return;
		}

		if (this._supertypes.contains(child)) {
			return;
		}

		if (this._supernames.contains(child)) {
			return;
		}

		if (this._definitions.contains(child)) {
			return;
		}

		if (this._allInheritedDefinitions.contains(child)) {
			return;
		}

		if (this._localInheritedDefinitions.contains(child)) {
			return;
		}

		if (this._superDefs.contains(child)) {
			return;
		}

		if (this._superInheritedDefinitions.contains(child)) {
			return;
		}

		if (this._classtype == child) {
			return;
		}

		if (this._invariant == child) {
			return;
		}

		throw new RuntimeException("Not a child.");
	}


	/**
	 * Creates a map of all field names and their value
	 * @param includeInheritedFields if true all inherited fields are included
	 * @return a a map of names to values of all fields
	 */
	@Override
	public Map<String,Object> getChildren(Boolean includeInheritedFields)
	{
		Map<String,Object> fields = new HashMap<String,Object>();
		if(includeInheritedFields)
		{
			fields.putAll(super.getChildren(includeInheritedFields));
		}
		fields.put("_supertypes",this._supertypes);
		fields.put("_supernames",this._supernames);
		fields.put("_definitions",this._definitions);
		fields.put("_allInheritedDefinitions",this._allInheritedDefinitions);
		fields.put("_localInheritedDefinitions",this._localInheritedDefinitions);
		fields.put("_hasContructors",this._hasContructors);
		fields.put("_settingHierarchy",this._settingHierarchy);
		fields.put("_superDefs",this._superDefs);
		fields.put("_gettingInheritable",this._gettingInheritable);
		fields.put("_superInheritedDefinitions",this._superInheritedDefinitions);
		fields.put("_gettingInvDefs",this._gettingInvDefs);
		fields.put("_isAbstract",this._isAbstract);
		fields.put("_isUndefined",this._isUndefined);
		fields.put("_classtype",this._classtype);
		fields.put("_typeChecked",this._typeChecked);
		fields.put("_invariant",this._invariant);
		return fields;
	}



	public String toString()
	{
		return super.toString();

	}


	/**
	* Forwarding hashCode call to {@link Object#hashCode()}.
	**/
	@Override
	public int hashCode()
	{
		return super.hashCode();
	}


	/**
	 * Returns a deep clone of this {@link SClassDefinitionBase} node.
	 * @return a deep clone of this {@link SClassDefinitionBase} node
	 */
	@Override
	public abstract SClassDefinition clone();

	/**
	 * Sets the {@code _supertypes} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _supertypes} child of this {@link SClassDefinitionBase} node
	*/
	public void setSupertypes(List<? extends PType> value)
	{
		if (this._supertypes.equals(value)) {
			return;
		}
		this._supertypes.clear();
		if (value != null) {
			this._supertypes.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _supertypes} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<PType> getSupertypes()
	{
		return this._supertypes;
	}


	/**
	 * Sets the {@code _supernames} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _supernames} child of this {@link SClassDefinitionBase} node
	*/
	public void setSupernames(List<? extends ILexNameToken> value)
	{
		if (this._supernames.equals(value)) {
			return;
		}
		this._supernames.clear();
		if (value != null) {
			this._supernames.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _supernames} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<ILexNameToken> getSupernames()
	{
		return this._supernames;
	}


	/**
	 * Sets the {@code _definitions} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _definitions} child of this {@link SClassDefinitionBase} node
	*/
	public void setDefinitions(List<? extends PDefinition> value)
	{
		if (this._definitions.equals(value)) {
			return;
		}
		this._definitions.clear();
		if (value != null) {
			this._definitions.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _definitions} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<PDefinition> getDefinitions()
	{
		return this._definitions;
	}


	/**
	 * Sets the {@code _allInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _allInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public void setAllInheritedDefinitions(List<? extends PDefinition> value)
	{
		if (this._allInheritedDefinitions.equals(value)) {
			return;
		}
		this._allInheritedDefinitions.clear();
		if (value != null) {
			this._allInheritedDefinitions.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _allInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<PDefinition> getAllInheritedDefinitions()
	{
		return this._allInheritedDefinitions;
	}


	/**
	 * Sets the {@code _localInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _localInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public void setLocalInheritedDefinitions(List<? extends PDefinition> value)
	{
		if (this._localInheritedDefinitions.equals(value)) {
			return;
		}
		this._localInheritedDefinitions.clear();
		if (value != null) {
			this._localInheritedDefinitions.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _localInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<PDefinition> getLocalInheritedDefinitions()
	{
		return this._localInheritedDefinitions;
	}


	/**
	 * Sets the {@code _hasContructors} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _hasContructors} child of this {@link SClassDefinitionBase} node
	*/
	public void setHasContructors(Boolean value)
	{
		this._hasContructors = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _hasContructors} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getHasContructors()
	{
		return this._hasContructors;
	}


	/**
	 * Sets the {@code _settingHierarchy} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _settingHierarchy} child of this {@link SClassDefinitionBase} node
	*/
	public void setSettingHierarchy(ClassDefinitionSettings value)
	{
		this._settingHierarchy = value;
	}


	/**
	 * @return the {@link ClassDefinitionSettings} node which is the {@code _settingHierarchy} child of this {@link SClassDefinitionBase} node
	*/
	public ClassDefinitionSettings getSettingHierarchy()
	{
		return this._settingHierarchy;
	}


	/**
	 * Sets the {@code _superDefs} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _superDefs} child of this {@link SClassDefinitionBase} node
	*/
	public void setSuperDefs(List<? extends SClassDefinition> value)
	{
		if (this._superDefs.equals(value)) {
			return;
		}
		this._superDefs.clear();
		if (value != null) {
			this._superDefs.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _superDefs} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<SClassDefinition> getSuperDefs()
	{
		return this._superDefs;
	}


	/**
	 * Sets the {@code _gettingInheritable} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _gettingInheritable} child of this {@link SClassDefinitionBase} node
	*/
	public void setGettingInheritable(Boolean value)
	{
		this._gettingInheritable = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _gettingInheritable} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getGettingInheritable()
	{
		return this._gettingInheritable;
	}


	/**
	 * Sets the {@code _superInheritedDefinitions} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _superInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public void setSuperInheritedDefinitions(List<? extends PDefinition> value)
	{
		if (this._superInheritedDefinitions.equals(value)) {
			return;
		}
		this._superInheritedDefinitions.clear();
		if (value != null) {
			this._superInheritedDefinitions.addAll(value);
		}

	}


	/**
	 * @return the {@link LinkedList} node which is the {@code _superInheritedDefinitions} child of this {@link SClassDefinitionBase} node
	*/
	public LinkedList<PDefinition> getSuperInheritedDefinitions()
	{
		return this._superInheritedDefinitions;
	}


	/**
	 * Sets the {@code _gettingInvDefs} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _gettingInvDefs} child of this {@link SClassDefinitionBase} node
	*/
	public void setGettingInvDefs(Boolean value)
	{
		this._gettingInvDefs = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _gettingInvDefs} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getGettingInvDefs()
	{
		return this._gettingInvDefs;
	}


	/**
	 * Sets the {@code _isAbstract} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _isAbstract} child of this {@link SClassDefinitionBase} node
	*/
	public void setIsAbstract(Boolean value)
	{
		this._isAbstract = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _isAbstract} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getIsAbstract()
	{
		return this._isAbstract;
	}


	/**
	 * Sets the {@code _isUndefined} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _isUndefined} child of this {@link SClassDefinitionBase} node
	*/
	public void setIsUndefined(Boolean value)
	{
		this._isUndefined = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _isUndefined} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getIsUndefined()
	{
		return this._isUndefined;
	}


	/**
	 * Sets the {@code _classtype} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _classtype} child of this {@link SClassDefinitionBase} node
	*/
	public void setClasstype(PType value)
	{
		if( value != null && value.parent() == null) {
			value.parent(this);
		}
		this._classtype = value;

	}


	/**
	 * @return the {@link PType} node which is the {@code _classtype} child of this {@link SClassDefinitionBase} node
	*/
	public PType getClasstype()
	{
		return this._classtype;
	}


	/**
	 * Sets the {@code _typeChecked} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _typeChecked} child of this {@link SClassDefinitionBase} node
	*/
	public void setTypeChecked(Boolean value)
	{
		this._typeChecked = value;
	}


	/**
	 * @return the {@link Boolean} node which is the {@code _typeChecked} child of this {@link SClassDefinitionBase} node
	*/
	public Boolean getTypeChecked()
	{
		return this._typeChecked;
	}


	/**
	 * Sets the {@code _invariant} child of this {@link SClassDefinitionBase} node.
	 * @param value the new {@code _invariant} child of this {@link SClassDefinitionBase} node
	*/
	public void setInvariant(AExplicitOperationDefinition value)
	{
		if( value != null && value.parent() == null) {
			value.parent(this);
		}
		this._invariant = value;

	}


	/**
	 * @return the {@link AExplicitOperationDefinition} node which is the {@code _invariant} child of this {@link SClassDefinitionBase} node
	*/
	public AExplicitOperationDefinition getInvariant()
	{
		return this._invariant;
	}



}
