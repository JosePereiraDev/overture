
============================================================================================================
|
|		Specificatopn SLs
|___________________________________________________________________________________________________________
Parsed Specificatopn SL - ModuleList<AModuleModules>         : module DEFAULT  definitions private static  Cg = Cg private static  Hzd = Hzd private static  Inf = Inf private static  Kg = Kg 	inv k == ((k <> <INFINITY>) => (k >= 0)) private static  Realp = Realp 	inv r == (r >= 0) private static  Metre = Metre private static  Object = Object private static  Element_label = Element_label private static  Element = Element private static  Point = Point private static  Pes_types = Pes_types private static  Magazine = Magazine private static  Storage_building = Storage_building private static  Process_building = Process_building private static  Other_building = Other_building private static  Exs_types = Exs_types private static  Building = Building private static  Quad = Quad 	inv q == (((len q) = 4) and rectangular(q)) private static  Site_label = Site_label private static  Exposed_site = Exposed_site 	inv exs == ((forall p in set (elems ((exs.vertices)(2, ... ,4))) & (((distance(mk_Point(0, 0), (exs.vertices)(1)) <= distance(mk_Point(0, 0), p)) and (distance(mk_Point(0, 0), (exs.vertices)(1)) = distance(mk_Point(0, 0), p))) => (((exs.vertices)(1).y) < (p.y)))) and (((exs.door) in set {0, ... ,3}) and (exists i in set (inds (exs.vertices)), j in set (inds (exs.vertices)) & (((abs (j - i)) = 2) and ((distance((exs.vertices)(1), (exs.vertices)(i)) = ((exs.building).length)) and (distance((exs.vertices)(1), (exs.vertices)(j)) = ((exs.building).breadth))))))) private static  Pot_explosion_site = Pot_explosion_site 	inv pes == ((forall p in set (elems ((pes.vertices)(2, ... ,4))) & (((distance(mk_Point(0, 0), (pes.vertices)(1)) <= distance(mk_Point(0, 0), p)) and (distance(mk_Point(0, 0), (pes.vertices)(1)) = distance(mk_Point(0, 0), p))) => (((pes.vertices)(1).y) < (p.y)))) and (((pes.door) in set {0, ... ,3}) and (exists i in set (inds (pes.vertices)), j in set (inds (pes.vertices)) & ((distance((pes.vertices)(1), (pes.vertices)(i)) = ((pes.mgzn).length)) and (distance((pes.vertices)(1), (pes.vertices)(j)) = ((pes.mgzn).breadth)))))) private static  Line = Line private static  RelOrientation = RelOrientation private static  OrientedExs = OrientedExs 	inv mk_(exs, ro) == ((not is_(exs, Storage_building)) <=> (ro = <NONE>)) private static  OrientedPes = OrientedPes 	inv mk_(pes, ro) == ((pes <> <EARTHCOVEREDBUILDING>) <=> (ro = <NONE>)) private static  Table_Co_ordinate = Table_Co_ordinate private static  asharp:map ((unresolved DEFAULT`Hzd)) to (map ((unresolved DEFAULT`Table_Co_ordinate)) to (real)) = {h |-> let m:map ((unresolved DEFAULT`Table_Co_ordinate)) to (real) in m | h:(unresolved DEFAULT`Hzd)} private static  bsharp:map ((unresolved DEFAULT`Hzd)) to (map ((unresolved DEFAULT`Table_Co_ordinate)) to (real)) = {h |-> let m:map ((unresolved DEFAULT`Table_Co_ordinate)) to (real) in m | h:(unresolved DEFAULT`Hzd)} private static  exceptions_hd1_1:set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s:set of ((unresolved DEFAULT`Table_Co_ordinate)) in s private static  exceptions_hd1_2:set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s:set of ((unresolved DEFAULT`Table_Co_ordinate)) in s private static  exceptions_hd1_3a:set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s:set of ((unresolved DEFAULT`Table_Co_ordinate)) in s private static  exceptions_hd1_3b:set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s:set of ((unresolved DEFAULT`Table_Co_ordinate)) in s private static  Xmax = 5 private static  Ymax = 5 private static  next_point:map (nat) to (nat) = {1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1} private static  Compatible_pairs:set of (((unresolved DEFAULT`Cg) * (unresolved DEFAULT`Cg))) = {mk_(<A>, <A>), mk_(<A>, <S>), mk_(<B>, <B>), mk_(<B>, <S>), mk_(<C>, <C>), mk_(<C>, <D>), mk_(<C>, <E>), mk_(<C>, <G>), mk_(<C>, <S>), mk_(<D>, <D>), mk_(<D>, <E>), mk_(<D>, <G>), mk_(<D>, <S>), mk_(<E>, <E>), mk_(<E>, <G>), mk_(<E>, <G>), mk_(<E>, <S>), mk_(<F>, <F>), mk_(<F>, <S>), mk_(<G>, <G>), mk_(<G>, <S>), mk_(<H>, <H>), mk_(<H>, <S>), mk_(<J>, <J>), mk_(<J>, <S>)} private static  hzdnum:map ((unresolved DEFAULT`Hzd)) to (nat) = {<ONEPONE> |-> 1, <ONEPTWO> |-> 2, <ONEPTHREE> |-> 3, <ONEPFOUR> |-> 4} private static  orientation:map (nat) to ((unresolved DEFAULT`RelOrientation)) = {0 |-> <PERP>, 1 |-> <FACING>, 2 |-> <PERP>, 3 |-> <AWAY>} private static  esharp:nat = let x:nat in x private  state Storeof [pes : inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), exs : inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), xmax : (unresolved DEFAULT`Metre), ymax : (unresolved DEFAULT`Metre)] 	inv mk_Store(pes, exs, xmax, ymax) == ((xmax > 0) and ((ymax > 0) and (((dom pes) subset (dom exs)) and (forall p in set (dom pes) & is_(((exs(p).building).type), Storage_building))))) 	init store == (store = mk_Store({|->}, {|->}, Xmax, Ymax)) private static  private static rectangular: (seq of ((unresolved DEFAULT`Point)) -> bool) 	rectangular(v) == ((distance(v(1), v(2)) = distance(v(3), v(4))) and ((distance(v(1), v(4)) = distance(v(2), v(3))) and ((distance(v(1), v(3)) = distance(v(2), v(4))) and ((card (elems v)) = (len v))))) 	pre ((len v) = 4) private static  private static distance: ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> (unresolved DEFAULT`Metre)) 	distance(p1, p2) == sqrt(((((p2.x) - (p1.x)) ** 2) + (((p2.y) - (p1.y)) ** 2))) private static  private static  sqrt((x:real))s:(unresolved DEFAULT`Realp) 	pre (x >= 0) 	post ((s >= 0) and ((s ** 2) = x)) private static  private static suff_space_at: ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) * (unresolved DEFAULT`Point) -> bool) 	suff_space_at(o, m, p) == ((0 < ((p.x) + (o.xlen))) and ((((p.x) + (o.xlen)) <= (m.length)) and ((0 < ((p.y) + (o.ylen))) and ((((p.y) + (o.ylen)) <= (m.breadth)) and ((0 < (o.zlen)) and (((o.zlen) <= (m.height)) and (forall a in set (rng (m.elements)) & ((((a.x) > ((p.x) + (o.xlen))) or (((a.x) + ((a.object).xlen)) < (p.x))) and (((a.y) > ((p.y) + (o.ylen))) or (((a.y) + ((a.object).ylen)) < (p.y))))))))))) private static  private static  find_point((o:(unresolved DEFAULT`Object)), (m:(unresolved DEFAULT`Magazine)))pt:(unresolved DEFAULT`Point) 	pre (exists x:(unresolved DEFAULT`Realp), y:(unresolved DEFAULT`Realp) & suff_space_at(o, m, mk_Point(x, y))) 	post suff_space_at(o, m, pt) private static  private static within_hazard: ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool) 	within_hazard(o, m) == (hzdnum((o.hzd)) >= hzdnum((m.hzd))) private static  private static compatible: ((unresolved DEFAULT`Cg) * (unresolved DEFAULT`Cg) -> bool) 	compatible(m, n) == ((mk_(m, n) in set Compatible_pairs) or (mk_(n, m) in set Compatible_pairs)) private static  private static all_compatible: ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool) 	all_compatible(o, m) == (forall elt in set (rng (m.elements)) & compatible((o.cg), ((elt.object).cg))) private static  private static sum: (set of (real) -> real) 	sum(s) == (if (s = {}) then 0 else let x:real be st (x in set s) in (x + sum((s \ {x})))) private static  private static Card: (set of (real) -> nat) 	Card(s) == (card s) private static  private static suff_capacity: ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool) 	suff_capacity(o, m) == (if ((m.max_neq) <> <INFINITY>) then ((sum({((elt.object).neq) | elt in set (rng (m.elements))}) + (o.neq)) <= (m.max_neq)) else true) private static  private static safe_addition: ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) * (unresolved DEFAULT`Point) -> bool) 	safe_addition(o, m, p) == (suff_space_at(o, m, p) and (within_hazard(o, m) and (all_compatible(o, m) and suff_capacity(o, m)))) private static  private static rel_pos: ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> nat) 	rel_pos(pes, exs) == ((floor ang_sep(pes, exs)) div 90) private static  private static table_entry: ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Table_Co_ordinate)) 	table_entry(pes, exs) == let inc = rel_pos(pes, exs) in let exs_ro = (if is_(((exs.building).type), Storage_building) then orientation(((inc + (exs.door)) mod 4)) else <NONE>), pes_ro = (if (((pes.mgzn).type) = <EARTHCOVEREDBUILDING>) then orientation(((inc + (pes.door)) mod 4)) else <NONE>) in let o_exs = mk_(((exs.building).type), exs_ro), o_pes = mk_(((pes.mgzn).type), pes_ro) in mk_(o_exs, o_pes) private static  private static  min((s:set of ((unresolved DEFAULT`Realp))))m:(unresolved DEFAULT`Realp) 	pre (s <> {}) 	post ((m in set s) and (forall x in set s & (m <= x))) private static  private static  max((s:set of ((unresolved DEFAULT`Realp))))m:(unresolved DEFAULT`Realp) 	pre (s <> {}) 	post ((m in set s) and (forall x in set s & (m >= x))) private static  private static truncated: ((unresolved DEFAULT`Realp) -> bool) 	truncated(r) == is_((r * (10 ** esharp)), nat) private static  private static side: ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> set of ((unresolved DEFAULT`Point))) 	side(p1, p2) == (if ((p2.x) = (p1.x)) then {mk_Point((p1.x), y) | y:(unresolved DEFAULT`Realp) & (truncated(y) and ((min({(p1.y), (p2.y)}) <= y) and (y <= max({(p1.y), (p2.y)}))))} else {mk_Point(x, y) | x:(unresolved DEFAULT`Realp), y:(unresolved DEFAULT`Realp) & (truncated(x) and (truncated(y) and ((min({(p1.x), (p2.x)}) <= x) and ((x <= max({(p1.x), (p2.x)})) and ((min({(p1.y), (p2.y)}) <= y) and ((y <= max({(p1.y), (p2.y)})) and (if (x <> (p1.x)) then (((y - (p1.y)) / (x - (p1.x))) = (((p2.y) - (p1.y)) / ((p2.x) - (p1.x)))) else (y = (p1.y)))))))))}) private static  private static perimeter: (((unresolved DEFAULT`Exposed_site) | (unresolved DEFAULT`Pot_explosion_site)) -> set of ((unresolved DEFAULT`Point))) 	perimeter(site) == (dunion {side((site.vertices)(i), (site.vertices)(next_point(i))) | i in set {1, ... ,4}}) private static  private static shortest_dist: ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Metre)) 	shortest_dist(pes, exs) == min({distance(p1, p2) | p1:(unresolved DEFAULT`Point), p2:(unresolved DEFAULT`Point) & ((p1 in set perimeter(pes)) and (p2 in set perimeter(exs)))}) private static  private static min_separation: ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> bool) 	min_separation(pes, exs) == (shortest_dist(pes, exs) >= bsharp(((pes.mgzn).hzd))(table_entry(pes, exs))) private static  private static qd: ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Kg)) 	qd(pes, exs) == let d = shortest_dist(pes, exs), tbe = table_entry(pes, exs) in (cases ((pes.mgzn).hzd) : (<ONEPONE>) -> (if (tbe in set exceptions_hd1_1) then (if (d < 180) then (0.54 * (d ** (3 / 2))) elseif ((180 <= d) and (d < 240)) then (0.03 * (d ** 2)) else ((9.1 * (10 ** -5)) * (d ** 3))) else (asharp(<ONEPONE>)(tbe) * (d ** 3))), (<ONEPTWO>) -> (if (tbe in set exceptions_hd1_2) then <INFINITY> else (asharp(<ONEPTWO>)(tbe) * (d ** 5.5))), (<ONEPTHREE>) -> (if (tbe in set exceptions_hd1_3a) then <INFINITY> elseif (tbe in set exceptions_hd1_3b) then (asharp(<ONEPTHREE>)(tbe) * (d ** 2)) else (asharp(<ONEPTHREE>)(tbe) * (d ** 3))), (<ONEPFOUR>) -> <INFINITY>  end) private static  private static  nearest_storage_building((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:set of ((unresolved DEFAULT`Exposed_site))))e:(unresolved DEFAULT`Exposed_site) 	pre (exists ex in set exs & is_(((ex.building).type), Storage_building)) 	post ((e in set exs) and (is_(((e.building).type), Storage_building) and (forall ex in set exs & (is_(((ex.building).type), Storage_building) => (shortest_dist(pes, e) <= shortest_dist(pes, ex)))))) private static  private static  nearest_inhabited_building((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:set of ((unresolved DEFAULT`Exposed_site))))e:(unresolved DEFAULT`Exposed_site) 	pre (exists ex in set exs & ((((ex.building).type).kind) = <INHABITEDBUILDING>)) 	post ((e in set exs) and (((((e.building).type).kind) = <INHABITEDBUILDING>) and (forall ex in set exs & (((((ex.building).type).kind) = <INHABITEDBUILDING>) => (shortest_dist(pes, e) <= shortest_dist(pes, ex)))))) private static  private static  nearest_traffic_route((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:set of ((unresolved DEFAULT`Exposed_site))))e:(unresolved DEFAULT`Exposed_site) 	pre (exists ex in set exs & ((((ex.building).type).kind) = <TRAFFICROUTE>)) 	post ((e in set exs) and (((((e.building).type).kind) = <TRAFFICROUTE>) and (forall ex in set exs & (((((ex.building).type).kind) = <TRAFFICROUTE>) => (shortest_dist(pes, e) <= shortest_dist(pes, ex)))))) private static  private static  nearest_process_building((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:set of ((unresolved DEFAULT`Exposed_site))))e:(unresolved DEFAULT`Exposed_site) 	pre (exists ex in set exs & is_(((ex.building).type), Process_building)) 	post ((e in set exs) and (is_(((e.building).type), Process_building) and (forall ex in set exs & (is_(((ex.building).type), Process_building) => (shortest_dist(pes, e) <= shortest_dist(pes, ex)))))) private static  private static  nearest_buildings((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:set of ((unresolved DEFAULT`Exposed_site))))exset:set of ((unresolved DEFAULT`Exposed_site)) 	post ((exists e in set exs & is_(((e.building).type), Storage_building)) => (((nearest_storage_building(pes, exs) in set exset) and (exists e in set exs & is_(((e.building).type), Process_building))) => (((nearest_process_building(pes, exs) in set exset) and (exists e in set exs & ((((e.building).type).kind) = <INHABITEDBUILDING>))) => (((nearest_inhabited_building(pes, exs) in set exset) and (exists e in set exs & ((((e.building).type).kind) = <TRAFFICROUTE>))) => (nearest_traffic_route(pes, exs) in set exset))))) private static  private static find_max_neq: ((unresolved DEFAULT`Pot_explosion_site) * set of ((unresolved DEFAULT`Exposed_site)) -> (unresolved DEFAULT`Kg)) 	find_max_neq(pes, exs) == min({qd(pes, e) | e in set nearest_buildings(pes, exs)}) 	pre (exs <> {}) private static  private static  centre((v:(unresolved DEFAULT`Quad)))p:(unresolved DEFAULT`Point) 	post (forall i in set {1, ... ,3} & (distance(p, v(i)) = distance(p, v(1)))) private static  private static line_eqn: ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> (unresolved DEFAULT`Line)) 	line_eqn(p1, p2, p3) == mk_Line(((((p1.y) + (p2.y)) - (2 * (p3.y))) / (((p1.x) + (p2.x)) - (2 * (p3.x)))), ((p3.y) - ((p3.x) * ((((p1.y) + (p2.y)) - (2 * (p3.y))) / (((p1.x) + (p2.x)) - (2 * (p3.x))))))) 	pre (distance(p1, p3) = distance(p2, p3)) private static  private static incline: ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> real) 	incline(p1, p2, p3, p4, p5, p6) == let mk_Line(m1, c1) = line_eqn(p5, p6, p2) in let mk_Line(m2, c2) = line_eqn(p3, p4, p1) in let x3 = ((c1 - c2) / (m2 - m1)) in let y3 = (((m2 * c1) - (m1 * c2)) / (m2 - m1)) in sqrt(((((x3 - (p2.x)) ** 2) + ((y3 - (p2.y)) ** 2)) / (((x3 - (p1.x)) ** 2) + ((y3 - (p1.y)) ** 2)))) 	pre ((distance(p1, p2) = distance(p1, p4)) and ((distance(p2, p5) = distance(p2, p6)) and (((line_eqn(p5, p6, p2).m) * (line_eqn(p3, p4, p1).m)) = -1))) private static  private static  ang_sep((pes:(unresolved DEFAULT`Pot_explosion_site)), (exs:(unresolved DEFAULT`Exposed_site)))qsharp:real 	post let fsharp = arctan(incline(centre((pes.vertices)), centre((exs.vertices)), (pes.vertices)(1), (pes.vertices)(4), (exs.vertices)(1), (exs.vertices)(2))) in (if ((centre((pes.vertices)).x) = (centre((exs.vertices)).x)) then (if ((centre((pes.vertices)).y) < (centre((exs.vertices)).y)) then (qsharp = fsharp) else (qsharp = (fsharp + 180))) else let m1 = (line_eqn((pes.vertices)(1), (pes.vertices)(4), centre((pes.vertices))).m), m2 = (((centre((exs.vertices)).y) - (centre((pes.vertices)).y)) / ((centre((exs.vertices)).x) - (centre((pes.vertices)).x))) in (if (m2 > m1) then (qsharp = fsharp) else (qsharp = (fsharp + 180)))) private static  private static arctan: (real -> real) 	arctan(r) == let res:real in res private  ADD_OBJECT([o](unresolved DEFAULT`Object), [elt](unresolved DEFAULT`Element_label), [site](unresolved DEFAULT`Site_label)) 	ext [wr[pes]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site))] 	pre ((site in set (dom pes)) and (exists pt:(unresolved DEFAULT`Point) & (safe_addition(o, (pes(site).mgzn), pt) and (elt not in set (dom ((pes(site).mgzn).elements)))))) 	post let p = pes~(site) in let mk_Point(x, y) = find_point(o, (p.mgzn)) in let new_elems = (((p.mgzn).elements) ++ {elt |-> mk_Element(o, x, y)}) in let new_mag = mu((p.mgzn), elements |-> new_elems) in let new_site = mu(p, mgzn |-> new_mag) in (pes = (pes~ ++ {site |-> new_site})) private  REMOVE_OBJECT([elt](unresolved DEFAULT`Element_label), [site](unresolved DEFAULT`Site_label)) 	ext [wr[pes]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site))] 	pre ((site in set (dom pes)) and (elt in set (dom ((pes(site).mgzn).elements)))) 	post let p = pes~(site) in let new_elems = ({elt} <-: ((p.mgzn).elements)) in let new_mag = mu((p.mgzn), elements |-> new_elems) in let new_site = mu(p, mgzn |-> new_mag) in (pes = (pes~ ++ {site |-> new_site})) private  ADD_PES([pex](unresolved DEFAULT`Pot_explosion_site), [label](unresolved DEFAULT`Site_label), [type](unresolved DEFAULT`Storage_building)) 	ext [wr[pes]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), wr[exs]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), rd[xmax, ymax](unresolved DEFAULT`Metre)] 	pre (forall exp in set (rng exs) & (min_separation(pex, exp) and (forall v in set (elems (pex.vertices)) & (((0 <= (v.x)) and (((v.x) <= xmax) and ((0 <= (v.y)) and ((v.y) <= ymax)))) and (label not in set (dom pes)))))) 	post let new_neq = find_max_neq(pex, (rng exs~)) in let new_mgzn = mu((pex.mgzn), max_neq |-> new_neq) in let new_pex = mu(pex, mgzn |-> new_mgzn) in let new_building = mk_Building(type, ((pex.mgzn).length), ((pex.mgzn).breadth), ((pex.mgzn).height)) in let new_exp = mk_Exposed_site(new_building, (pex.vertices), (pex.door)) in ((pes = (pes~ ++ {label |-> new_pex})) and (exs = (exs~ ++ {label |-> new_exp}))) private  ADD_EXP([ex](unresolved DEFAULT`Exposed_site), [label](unresolved DEFAULT`Site_label)) 	ext [wr[exs]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), rd[pes]inmap ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), rd[xmax, ymax](unresolved DEFAULT`Metre)] 	pre ((not is_(((ex.building).type), Storage_building)) and (forall v in set (elems (ex.vertices)) & (((0 <= (v.x)) and (((v.x) <= xmax) and ((0 <= (v.y)) and ((v.y) <= ymax)))) and ((label not in set (dom exs)) and (forall pex in set (rng pes) & let proposed_neq = find_max_neq(pex, (rng (exs ++ {label |-> ex}))) in (if (proposed_neq <> <INFINITY>) then (find_max_neq(pex, (rng exs)) <= proposed_neq) else true)))))) 	post (exs = (exs~ ++ {label |-> ex})) end DEFAULT  from "ACSSL"








































