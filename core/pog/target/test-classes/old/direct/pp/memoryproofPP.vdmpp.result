["type invariant satisfiable obligation:(exists mk_State(mem, access, used):State \u0026 (used \u003d (dom mem)))","let be st existence obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 ((addr not in set used) \u003d\u003e (exists c:CON \u0026 true)))","type compatibility obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 ((addr not in set used) \u003d\u003e let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem ++ {addr |-\u003e let c:CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","let be st existence obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:CON \u0026 true)))","map compatible obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:CON in c}(rdom2))))))","type compatibility obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem munion {addr |-\u003e let c:CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","type compatibility obligation:(forall addr:ADDR, mk_State(mem, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to ((\u003cc0\u003e | CON)) \u003d (mem ++ {addr |-\u003e \u003cc0\u003e}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","let be st existence obligation:(forall addr:ADDR, mk_State(-, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:CON \u0026 true)))","type compatibility obligation:(forall addr:ADDR, mk_State(-, access, used):State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d {addr |-\u003e let c:CON in c} in inv_State(mk_State(mem\u0027, access, used\u0027))))","function establishes postcondition obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (pre_Alloc3(addr, mk_State(mem, access, used), mem2) \u003d\u003e post_Alloc3(addr, mk_State(mem, access, used), mem2, let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem munion {addr |-\u003e let c:CON in c}) in mk_State(mem\u0027, access, used\u0027))))","let be st existence obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let RESULT \u003d let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem munion {addr |-\u003e let c:CON in c}) in mk_State(mem\u0027, access, used\u0027) in (exists c:CON \u0026 true)))","map compatible obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let RESULT \u003d let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem munion {addr |-\u003e let c:CON in c}) in mk_State(mem\u0027, access, used\u0027) in (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:CON in c}(rdom2))))))","let be st existence obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:CON \u0026 true)))","map compatible obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:CON in c}(rdom2))))))","type compatibility obligation:(forall addr:ADDR, mk_State(mem, access, used):State, mem2:map (ADDR) to (CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (ADDR) \u003d (used union {addr}), mem\u0027:map (ADDR) to (CON) \u003d (mem munion {addr |-\u003e let c:CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","function establishes postcondition obligation:(forall addr:ADDR, sta:State \u0026 post_AllocSafe(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta)))))","legal function application obligation:(forall addr:ADDR, sta:State \u0026 (Safe(sta) \u003d\u003e pre_Alloc(addr, sta)))","function establishes postcondition obligation:(forall addr:ADDR, sta:State \u0026 (pre_AllocSafe0(addr, sta) \u003d\u003e post_AllocSafe0(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta))))))","legal function application obligation:(forall addr:ADDR, sta:State \u0026 ((addr not in set (sta.used)) \u003d\u003e (Safe(sta) \u003d\u003e pre_Alloc(addr, sta))))","function establishes postcondition obligation:(forall addr:ADDR, sta:State \u0026 (pre_AllocSafe2(addr, sta) \u003d\u003e post_AllocSafe2(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta))))))","legal function application obligation:(forall addr:ADDR, sta:State \u0026 (((addr not in set (sta.used)) and (addr in set (sta.access))) \u003d\u003e (Safe(sta) \u003d\u003e pre_Alloc(addr, sta))))","type compatibility obligation:inv_State(mk_State({\u003ca0\u003e |-\u003e \u003cc0\u003e}, {\u003ca0\u003e, \u003ca1\u003e}, {\u003ca0\u003e}))"]