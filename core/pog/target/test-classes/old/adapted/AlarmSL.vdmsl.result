["legal map application obligation:(forall mk_Plant(schedule, alarms):Plant \u0026 (forall a in set alarms \u0026 (forall peri in set (dom schedule) \u0026 (peri in set (dom schedule)))))","type invariant satisfiable obligation:(exists mk_Plant(schedule, alarms):Plant \u0026 (forall a in set alarms \u0026 (forall peri in set (dom schedule) \u0026 QualificationOK(schedule(peri), (a.quali)))))","type invariant satisfiable obligation:(exists sch:Schedule \u0026 (forall exs in set (rng sch) \u0026 ((exs \u003c\u003e {}) and (forall ex1, ex2 in set exs \u0026 ((ex1 \u003c\u003e ex2) \u003d\u003e ((ex1.expertid) \u003c\u003e (ex2.expertid)))))))","type invariant satisfiable obligation:(exists ex:Expert \u0026 ((ex.quali) \u003c\u003e {}))","legal map application obligation:(forall peri:Period, plant:Plant \u0026 ((peri in set (dom (plant.schedule))) \u003d\u003e (peri in set (dom (plant.schedule)))))","legal map application obligation:(forall ex:Expert, mk_Plant(sch, -):Plant \u0026 (forall peri in set (dom sch) \u0026 (peri in set (dom sch))))","legal map application obligation:(forall a:Alarm, peri:Period, plant:Plant \u0026 (((peri in set (dom (plant.schedule))) and (a in set (plant.alarms))) \u003d\u003e (exists r:Expert \u0026 (peri in set (dom (plant.schedule))))))","function postcondition satisfiable obligation:(forall a:Alarm, peri:Period, plant:Plant \u0026 (pre_ExpertToPage(a, peri, plant) \u003d\u003e (exists r:Expert \u0026 post_ExpertToPage(a, peri, plant, r))))","legal map application obligation:(forall mk_Plant(plan, alarms):Plant, ex1:Expert, ex2:Expert, peri:Period \u0026 (peri in set (dom plan)))","type compatibility obligation:(forall mk_Plant(plan, alarms):Plant, ex1:Expert, ex2:Expert, peri:Period \u0026 inv_Schedule((plan ++ {peri |-\u003e ((plan(peri) \\ {ex1}) union {ex2})})))","type compatibility obligation:(forall mk_Plant(plan, alarms):Plant, ex1:Expert, ex2:Expert, peri:Period \u0026 (inv_Plant(mk_Plant((plan ++ {peri |-\u003e ((plan(peri) \\ {ex1}) union {ex2})}), alarms)) and inv_Schedule((plan ++ {peri |-\u003e ((plan(peri) \\ {ex1}) union {ex2})}))))","type compatibility obligation:inv_Expert(mk_Expert(eid1, {\u003cElec\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid2, {\u003cMech\u003e, \u003cChem\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid3, {\u003cBio\u003e, \u003cChem\u003e, \u003cElec\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid4, {\u003cBio\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid5, {\u003cChem\u003e, \u003cBio\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid6, {\u003cElec\u003e, \u003cChem\u003e, \u003cBio\u003e, \u003cMech\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid7, {\u003cElec\u003e, \u003cMech\u003e}))","type compatibility obligation:inv_Expert(mk_Expert(eid8, {\u003cMech\u003e, \u003cBio\u003e}))","enumeration map injectivity obligation:(forall m1, m2 in set {{p1 |-\u003e {e7, e5, e1}}, {p2 |-\u003e {e6}}, {p3 |-\u003e {e1, e3, e8}}, {p4 |-\u003e {e6}}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_Schedule(s)","type compatibility obligation:(inv_Plant(mk_Plant(s, {a1, a2, a3})) and inv_Schedule(s))"]