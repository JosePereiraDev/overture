["type invariant satisfiable obligation:(exists d:Desk \u0026 ((rng (d.prev)) subset (d.issued)))","legal map application obligation:((r in set (dom (desk.prev))) \u003d\u003e (forall new_k:Key \u0026 ((new_k not in set (desk~.issued)) \u003d\u003e (r in set (dom (desk~.prev))))))","legal map application obligation:((r in set (dom (desk.prev))) \u003d\u003e (forall new_k:Key \u0026 ((new_k not in set (desk~.issued)) \u003d\u003e let new_c:Card \u003d mk_Card((desk~.prev)(r), new_k) in (((desk.issued) \u003d ((desk~.issued) union {new_k})) \u003d\u003e (((desk.prev) \u003d ((desk~.prev) ++ {r |-\u003e new_k})) \u003d\u003e ((g in set (dom guests~)) \u003d\u003e (g in set (dom guests~))))))))","map compatible obligation:((r in set (dom (desk.prev))) \u003d\u003e (forall new_k:Key \u0026 ((new_k not in set (desk~.issued)) \u003d\u003e let new_c:Card \u003d mk_Card((desk~.prev)(r), new_k) in (((desk.issued) \u003d ((desk~.issued) union {new_k})) \u003d\u003e (((desk.prev) \u003d ((desk~.prev) ++ {r |-\u003e new_k})) \u003d\u003e ((not (g in set (dom guests~))) \u003d\u003e (forall ldom1 in set (dom guests~), rdom2 in set (dom {g |-\u003e {new_c}}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (guests~(ldom1) \u003d {g |-\u003e {new_c}}(rdom2))))))))))","operation postcondition satisfiable obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 (pre_CheckIn(g, r, oldstate) \u003d\u003e (exists newstate:Hotel \u0026 post_CheckIn(g, r, oldstate, newstate))))","legal map application obligation:((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (g in set (dom guests))))","legal map application obligation:((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (forall c in set guests(g) \u0026 (r in set (dom locks)))))","legal map application obligation:((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (forall c in set guests(g) \u0026 ((not ((c.fst) \u003d locks(r))) \u003d\u003e (r in set (dom locks))))))","legal map application obligation:(((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (g in set (dom guests)))","legal map application obligation:(((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (forall c in set guests(g) \u0026 (r in set (dom locks))))","legal map application obligation:(((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (forall c in set guests(g) \u0026 ((not (((c.fst) \u003d locks(r)) and (locks \u003d (locks~ ++ {r |-\u003e (c.snd)})))) \u003d\u003e (r in set (dom locks)))))","operation postcondition satisfiable obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (pre_Enter(r, g, oldstate) \u003d\u003e (exists newstate:Hotel \u0026 post_Enter(r, g, oldstate, newstate))))","let be st existence obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e (exists new_k:Key \u0026 (new_k not in set (desk.issued)))))","legal map application obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e (r in set (dom (desk.prev)))))","state invariant holds obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","state invariant holds obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","state invariant holds obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","legal map application obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (g in set (dom guests)))))","map compatible obligation:(forall g:Guest, r:Room, oldstate:Hotel \u0026 ((r in set (dom (desk.prev))) \u003d\u003e ((not (g in set (dom guests))) \u003d\u003e (forall ldom1 in set (dom guests), rdom2 in set (dom {g |-\u003e {new_c}}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (guests(ldom1) \u003d {g |-\u003e {new_c}}(rdom2)))))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e ((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (g in set (dom guests))))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e ((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (forall c in set guests(g) \u0026 (r in set (dom locks)))))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e ((r in set (dom locks)) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (forall c in set guests(g) \u0026 ((not ((c.fst) \u003d locks(r))) \u003d\u003e (r in set (dom locks))))))))","let be st existence obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r))))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (g in set (dom guests))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (r in set (dom locks))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e ((not ((c.fst) \u003d locks(r))) \u003d\u003e (r in set (dom locks)))))","legal map application obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e (r in set (dom locks))))","state invariant holds obligation:(forall r:Room, g:Guest, oldstate:Hotel \u0026 (((r in set (dom locks)) and ((g in set (dom guests)) and (exists c in set guests(g) \u0026 (((c.fst) \u003d locks(r)) or ((c.snd) \u003d locks(r)))))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","let be st existence obligation:(exists k:Key \u0026 (k not in set (desk.issued)))","state invariant holds obligation:let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))","state invariant holds obligation:(forall r:Room, k:Key, oldstate:Hotel \u0026 (((k in set (desk.issued)) and (r not in set (dom locks))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","map compatible obligation:(forall r:Room, k:Key, oldstate:Hotel \u0026 (((k in set (desk.issued)) and (r not in set (dom locks))) \u003d\u003e (forall ldom1 in set (dom (desk.prev)), rdom2 in set (dom {r |-\u003e k}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ((desk.prev)(ldom1) \u003d {r |-\u003e k}(rdom2))))))","state invariant holds obligation:(forall r:Room, k:Key, oldstate:Hotel \u0026 (((k in set (desk.issued)) and (r not in set (dom locks))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","map compatible obligation:(forall r:Room, k:Key, oldstate:Hotel \u0026 (((k in set (desk.issued)) and (r not in set (dom locks))) \u003d\u003e (forall ldom1 in set (dom locks), rdom2 in set (dom {r |-\u003e k}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (locks(ldom1) \u003d {r |-\u003e k}(rdom2))))))","state invariant holds obligation:(forall g:Guest, cs:set of (Card), oldstate:Hotel \u0026 ((forall c in set cs \u0026 ({(c.fst), (c.snd)} subset (desk.issued))) \u003d\u003e let h \u003d Hotel in (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | c in set (dunion (rng (h.guests)))}) subset ((h.desk).issued)))))","legal map application obligation:(forall g:Guest, cs:set of (Card), oldstate:Hotel \u0026 ((forall c in set cs \u0026 ({(c.fst), (c.snd)} subset (desk.issued))) \u003d\u003e ((g in set (dom guests)) \u003d\u003e (g in set (dom guests)))))"]