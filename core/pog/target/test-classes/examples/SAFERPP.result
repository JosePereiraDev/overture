["type invariant satisfiable obligation:(exists dir:AxisMap \u0026 ((dom dir) \u003d {\u003caxis1\u003e, \u003caxis2\u003e, \u003caxis3\u003e}))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e \u003cZero\u003e} | a in set allaxes} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_AxisMap({a |-\u003e \u003cZero\u003e | a in set allaxes})","legal map application obligation:(forall a:Axis \u0026 (a in set (dom axesdir)))","type compatibility obligation:(forall a:Axis, d:Direction \u0026 inv_AxisMap((axesdir ++ {a |-\u003e d})))","legal map application obligation:(forall a in set (dom axesdir) \u0026 (a in set (dom axesdir)))","enumeration map injectivity obligation:(forall a, b, c in set {\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e} \u0026 (forall m1, m2 in set {{\u003caxis1\u003e |-\u003e a}, {\u003caxis2\u003e |-\u003e b}, {\u003caxis3\u003e |-\u003e c}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:is_({{\u003caxis1\u003e |-\u003e a, \u003caxis2\u003e |-\u003e b, \u003caxis3\u003e |-\u003e c} | a, b, c in set {\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e}}, set of (AxisMap))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(x, pitch, yaw_y, roll_z, modeswitch, \u003cUp\u003e) |-\u003e ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, \u003cUp\u003e, Command`nullaxesdir)} | x, pitch, yaw_y, roll_z in set DirectionSet, modeswitch in set ModeSet} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd) |-\u003e ControlCycle(x, pitch, yaw_y, roll_z, modeswitch, aahbutton, aahcmd)} | x, pitch, yaw_y, roll_z in set DirectionSet, modeswitch in set ModeSet, aahbutton in set AAHButtonSet, aahcmd in set RotCmdSet} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e})}, {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cB4\u003e}, {})}, {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e}, {\u003cB1\u003e, \u003cB4\u003e})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cB4\u003e}, {})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB4\u003e}, {\u003cB2\u003e, \u003cB3\u003e})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB3\u003e}, {})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e}, {\u003cB1\u003e, \u003cB4\u003e})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cB2\u003e}, {})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e}, {\u003cB2\u003e, \u003cB3\u003e})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e, \u003cF1\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB4\u003e, \u003cF2\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cF2\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cF1\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB3\u003e, \u003cF4\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cB2\u003e, \u003cF3\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cF3\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cB1\u003e, \u003cF4\u003e}, {})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e}, {\u003cF2\u003e, \u003cF3\u003e})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e, \u003cF2\u003e}, {})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e}, {\u003cF1\u003e, \u003cF4\u003e})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF1\u003e, \u003cF3\u003e}, {})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e, \u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF2\u003e, \u003cF4\u003e}, {})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cF3\u003e}, {\u003cF1\u003e, \u003cF4\u003e})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cF3\u003e, \u003cF4\u003e}, {})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cF4\u003e}, {\u003cF2\u003e, \u003cF3\u003e})}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e, \u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e})}, {mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cL3R\u003e}, {\u003cL1F\u003e, \u003cL3F\u003e})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cU3R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cU3R\u003e, \u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e})}, {mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cU4R\u003e}, {\u003cU3F\u003e, \u003cU4F\u003e})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cL1R\u003e, \u003cR4R\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e, \u003cL3R\u003e}, {})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cD1R\u003e, \u003cD2R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e})}, {mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cD1R\u003e}, {\u003cD1F\u003e, \u003cD2F\u003e})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({\u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e, \u003cR4R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e})}, {mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({\u003cR2R\u003e}, {\u003cR2F\u003e, \u003cR4F\u003e})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e) |-\u003e mk_ThrSel({}, {})}, {mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e) |-\u003e mk_ThrSel({}, {})}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(Command`X in set (dom tran))","legal map application obligation:(Command`PITCH in set (dom rot))","legal map application obligation:(Command`YAW in set (dom rot))","legal map application obligation:(Command`Y in set (dom tran))","legal map application obligation:(Command`Z in set (dom tran))","legal map application obligation:(Command`ROLL in set (dom rot))","legal map application obligation:(Command`ROLL in set (dom rot))","legal map application obligation:(Command`PITCH in set (dom rot))","legal map application obligation:((rot(Command`PITCH) \u003d \u003cZero\u003e) \u003d\u003e (Command`YAW in set (dom rot)))","legal map application obligation:(forall a in set Command`allaxes \u0026 ((not starting) \u003d\u003e ((engage \u003c\u003e \u003cAAH_off\u003e) \u003d\u003e ((a in set active_rot_axes) \u003d\u003e (a in set (dom rot))))))","legal map application obligation:(forall a in set Command`allaxes \u0026 (starting \u003d\u003e (a in set (dom rot))))","cases exhaustive obligation:(forall button_pos:Button, count:nat \u0026 ((((((((((((mk_(toggle, button_pos) \u003d mk_(\u003cAAH_off\u003e, \u003cUp\u003e)) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_off\u003e, \u003cDown\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_started\u003e, \u003cUp\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_started\u003e, \u003cDown\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_on\u003e, \u003cUp\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_on\u003e, \u003cDown\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cpressed_once\u003e, \u003cUp\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cpressed_once\u003e, \u003cDown\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_closing\u003e, \u003cUp\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cAAH_closing\u003e, \u003cDown\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cpressed_twice\u003e, \u003cUp\u003e))) or (mk_(toggle, button_pos) \u003d mk_(\u003cpressed_twice\u003e, \u003cDown\u003e))))","enumeration map injectivity obligation:(forall m1, m2 in set {{Command`X |-\u003e x}, {Command`Y |-\u003e (if (modeswitch \u003d \u003cTran\u003e)\nthen yaw_y\nelse \u003cZero\u003e)}, {Command`Z |-\u003e (if (modeswitch \u003d \u003cTran\u003e)\nthen roll_z\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{Command`ROLL |-\u003e (if (modeswitch \u003d \u003cRot\u003e)\nthen roll_z\nelse \u003cZero\u003e)}, {Command`PITCH |-\u003e pitch}, {Command`YAW |-\u003e (if (modeswitch \u003d \u003cRot\u003e)\nthen yaw_y\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","comprehension map injectivity obligation:(forall m1, m2 in set {{thr |-\u003e new Thruster()} | thr in set ThrusterControl`ThrusterSet} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall thr in set ThrusterControl`ThrusterSet \u0026 (thr in set (dom thrusters)))","legal map application obligation:(forall dir1:Direction, dir2:Direction, dir3:Direction \u0026 (mk_(dir1, dir2, dir3) in set (dom selections)))","legal map application obligation:(X in set (dom axesdir))","enumeration map injectivity obligation:((axesdir(X) \u003c\u003e \u003cZero\u003e) \u003d\u003e (forall m1, m2 in set {{Y |-\u003e \u003cZero\u003e}, {Z |-\u003e \u003cZero\u003e}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:inv_AxisMap((if (axesdir(X) \u003c\u003e \u003cZero\u003e)\nthen (axesdir ++ {Y |-\u003e \u003cZero\u003e, Z |-\u003e \u003cZero\u003e})\nelseif (axesdir(Y) \u003c\u003e \u003cZero\u003e)\nthen (axesdir ++ {Z |-\u003e \u003cZero\u003e})\nelse axesdir))","legal map application obligation:(forall a in set Command`allaxes \u0026 (a in set (dom (rotcmd.GetAxesdir)())))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e (aah.GetRotcmd)()(a)} | a in set aah_axes} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall a in set aah_axes \u0026 (a in set (dom (aah.GetRotcmd)())))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e (rotcmd.GetAxesdir)()(a)} | a in set (Command`allaxes \\ aah_axes)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall a in set (Command`allaxes \\ aah_axes) \u0026 (a in set (dom (rotcmd.GetAxesdir)())))","map compatible obligation:(forall ldom1 in set (dom {a |-\u003e (aah.GetRotcmd)()(a) | a in set aah_axes}), rdom2 in set (dom {a |-\u003e (rotcmd.GetAxesdir)()(a) | a in set (Command`allaxes \\ aah_axes)}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({a |-\u003e (aah.GetRotcmd)()(a) | a in set aah_axes}(ldom1) \u003d {a |-\u003e (rotcmd.GetAxesdir)()(a) | a in set (Command`allaxes \\ aah_axes)}(rdom2))))","type invariant satisfiable obligation:(exists inp:Input \u0026 ((len inp) \u003d 9))","legal sequence application obligation:(forall tm:seq of (seq of (bool)) \u0026 (((len tm) \u003d 4) \u003d\u003e (forall i in set (inds tm) \u0026 (i in set (inds tm)))))","type invariant satisfiable obligation:(exists tm:ThrusterMatrix \u0026 (((len tm) \u003d 4) and (forall i in set (inds tm) \u0026 ((len tm(i)) \u003d 6))))","enumeration map injectivity obligation:(forall inp:Input \u0026 let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d inp in (forall m1, m2 in set {{\u003caxis3\u003e |-\u003e ConvertAxisCmd(roll)}, {\u003caxis1\u003e |-\u003e ConvertAxisCmd(pitch)}, {\u003caxis2\u003e |-\u003e ConvertAxisCmd(yaw)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall inp:Input \u0026 is_(let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d inp in mk_(ConvertAxisCmd(horiz), ConvertAxisCmd(twist), ConvertAxisCmd(trans), ConvertAxisCmd(vert), (if (mode \u003d 1)\nthen \u003cTran\u003e\nelse \u003cRot\u003e), (if (aah \u003d 0)\nthen \u003cUp\u003e\nelse \u003cDown\u003e), {\u003caxis3\u003e |-\u003e ConvertAxisCmd(roll), \u003caxis1\u003e |-\u003e ConvertAxisCmd(pitch), \u003caxis2\u003e |-\u003e ConvertAxisCmd(yaw)}), (Direction * Direction * Direction * Direction * Mode * Button * AxisMap)))","type compatibility obligation:(forall ts:set of (ThrusterPosition) \u0026 inv_ThrusterMatrix(let tson:set of ((nat * nat)) \u003d {GenerateThrusterLabel(t) | t in set ts} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]))","cases exhaustive obligation:(forall tnm:ThrusterPosition \u0026 ((((((((((((((((((((((((tnm \u003d \u003cB1\u003e) or (tnm \u003d \u003cB2\u003e)) or (tnm \u003d \u003cB3\u003e)) or (tnm \u003d \u003cB4\u003e)) or (tnm \u003d \u003cF1\u003e)) or (tnm \u003d \u003cF2\u003e)) or (tnm \u003d \u003cF3\u003e)) or (tnm \u003d \u003cF4\u003e)) or (tnm \u003d \u003cL1R\u003e)) or (tnm \u003d \u003cL1F\u003e)) or (tnm \u003d \u003cR2R\u003e)) or (tnm \u003d \u003cR2F\u003e)) or (tnm \u003d \u003cL3R\u003e)) or (tnm \u003d \u003cL3F\u003e)) or (tnm \u003d \u003cR4R\u003e)) or (tnm \u003d \u003cR4F\u003e)) or (tnm \u003d \u003cD1R\u003e)) or (tnm \u003d \u003cD1F\u003e)) or (tnm \u003d \u003cD2R\u003e)) or (tnm \u003d \u003cD2F\u003e)) or (tnm \u003d \u003cU3R\u003e)) or (tnm \u003d \u003cU3F\u003e)) or (tnm \u003d \u003cU4R\u003e)) or (tnm \u003d \u003cU4F\u003e)))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cRoll\u003e |-\u003e \u003cZero\u003e}, {\u003cPitch\u003e |-\u003e \u003cZero\u003e}, {\u003cYaw\u003e |-\u003e \u003cZero\u003e}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","operation establishes postcondition obligation:(forall x:Direction, pitch:Direction, yaw_y:Direction, roll_z:Direction, modeswitch:Mode, aahbutton:Button, aahcmd:AxisMap \u0026 (((card RESULT) \u003c\u003d 4) and ThrusterConsistency(RESULT)))"]