["type compatibility obligation:(forall pe:Event \u0026 is_((events ^ [pe]), seq of (NetworkEvent)))","type compatibility obligation:(forall pe:Event \u0026 is_((interrupts ^ [pe]), seq of (InterruptEvent)))","non-empty sequence obligation:(interrupts \u003c\u003e [])","non-empty sequence obligation:(interrupts \u003c\u003e [])","non-empty sequence obligation:(events \u003c\u003e [])","non-empty sequence obligation:(events \u003c\u003e [])","map compatible obligation:(forall pet:EnvironmentTask \u0026 (forall ldom1 in set (dom envTasks), rdom2 in set (dom {(pet.getName)() |-\u003e pet}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (envTasks(ldom1) \u003d {(pet.getName)() |-\u003e pet}(rdom2)))))","comprehension map injectivity obligation:(forall dispatch1:EventDispatcher, appTasks2:set of (BasicTask), envTasks3:map (seq of (char)) to (EnvironmentTask), mode4:nat \u0026 (true \u003d\u003e (forall dispatch5:EventDispatcher, appTasks6:set of (BasicTask), envTasks7:map (seq of (char)) to (EnvironmentTask), mode8:nat \u0026 (true \u003d\u003e (forall dispatch9:EventDispatcher, appTasks10:set of (BasicTask), envTasks11:map (seq of (char)) to (EnvironmentTask), mode12:nat \u0026 (true \u003d\u003e (forall dispatch13:EventDispatcher, appTasks14:set of (BasicTask), envTasks15:map (seq of (char)) to (EnvironmentTask), mode16:nat \u0026 (true \u003d\u003e (forall m1, m2 in set {{name |-\u003e (envTasks(name).getMinMaxAverage)()} | name in set (dom envTasks)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))))))))","legal map application obligation:(forall dispatch1:EventDispatcher, appTasks2:set of (BasicTask), envTasks3:map (seq of (char)) to (EnvironmentTask), mode4:nat \u0026 (true \u003d\u003e (forall dispatch5:EventDispatcher, appTasks6:set of (BasicTask), envTasks7:map (seq of (char)) to (EnvironmentTask), mode8:nat \u0026 (true \u003d\u003e (forall dispatch9:EventDispatcher, appTasks10:set of (BasicTask), envTasks11:map (seq of (char)) to (EnvironmentTask), mode12:nat \u0026 (true \u003d\u003e (forall dispatch13:EventDispatcher, appTasks14:set of (BasicTask), envTasks15:map (seq of (char)) to (EnvironmentTask), mode16:nat \u0026 (true \u003d\u003e (forall name in set (dom envTasks) \u0026 (name in set (dom envTasks)))))))))))","legal function application obligation:(forall psrc:seq of (char), pdest:seq of (char), pid:nat \u0026 pre_(((io.fwriteval))[seq of ((nat | seq of (char)))]\"mytrace.txt\", [\"network\", psrc, pdest, pid, time], mode))","legal function application obligation:(forall psrc:seq of (char), pdest:seq of (char), pid:nat \u0026 pre_(((io.fwriteval))[seq of ((nat | seq of (char)))]\"mytrace.txt\", [\"interrupt\", psrc, pdest, pid, time], mode))","legal function application obligation:(forall pev:Event \u0026 pre_checkResponseTimes(e2s, s2e, 1500))","operation establishes postcondition obligation:(forall pev:Event \u0026 checkResponseTimes(e2s, s2e, 1500))","map compatible obligation:(forall pat:AbstractTask \u0026 (((pat.getName)() not in set (dom queues)) \u003d\u003e (forall ldom1 in set (dom queues), rdom2 in set (dom {(pat.getName)() |-\u003e pat}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (queues(ldom1) \u003d {(pat.getName)() |-\u003e pat}(rdom2))))))","non-empty sequence obligation:(interrupts \u003c\u003e [])","non-empty sequence obligation:(interrupts \u003c\u003e [])","non-empty sequence obligation:(messages \u003c\u003e [])","non-empty sequence obligation:(messages \u003c\u003e [])","legal map application obligation:(forall pe2s:map (nat) to (nat), ps2e:map (nat) to (nat), plim:nat \u0026 ((((dom ps2e) inter (dom pe2s)) \u003d (dom ps2e)) \u003d\u003e (forall idx in set (dom ps2e) \u0026 (idx in set (dom ps2e)))))","legal map application obligation:(forall pe2s:map (nat) to (nat), ps2e:map (nat) to (nat), plim:nat \u0026 ((((dom ps2e) inter (dom pe2s)) \u003d (dom ps2e)) \u003d\u003e (forall idx in set (dom ps2e) \u0026 (idx in set (dom pe2s)))))","map compatible obligation:(forall pev:nat \u0026 (forall ldom1 in set (dom e2s), rdom2 in set (dom {pev |-\u003e time}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (e2s(ldom1) \u003d {pev |-\u003e time}(rdom2)))))","map compatible obligation:(forall pev:nat \u0026 (forall ldom1 in set (dom s2e), rdom2 in set (dom {pev |-\u003e time}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (s2e(ldom1) \u003d {pev |-\u003e time}(rdom2)))))","legal map application obligation:(cnt in set (dom s2e))","legal map application obligation:(cnt in set (dom e2s))","type compatibility obligation:is_(dt, [nat])","type compatibility obligation:is_(dt, [nat])","type compatibility obligation:is_(dt, [nat])","type compatibility obligation:is_(dt, [nat])","type compatibility obligation:((diff + dt) \u003e\u003d 0)","non-zero obligation:((card (dom s2e)) \u003c\u003e 0)","type compatibility obligation:is_(RESULT, (nat * nat * real))","legal function application obligation:(forall pev:Event \u0026 pre_checkResponseTimes(e2s, s2e, 10000))","operation establishes postcondition obligation:(forall pev:Event \u0026 checkResponseTimes(e2s, s2e, 10000))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]