["legal map application obligation:(forall fromId:CardId, toId:CardId, sum:nat \u0026 ((({fromId, toId} subset (dom Purses)) and ((fromId \u003c\u003e toId) and ((Purses(fromId).GetBalance)() \u003e\u003d sum))) \u003d\u003e (({fromId, toId} subset (dom Purses)) \u003d\u003e ((fromId \u003c\u003e toId) \u003d\u003e (fromId in set (dom Purses))))))","comprehension map injectivity obligation:(forall PurseSet:set of (Purse) \u0026 ((forall p, q in set PurseSet \u0026 ((p \u003c\u003e q) \u003d\u003e ((p.GetCardNo)() \u003c\u003e (q.GetCardNo)()))) \u003d\u003e (forall m1, m2 in set {{(p.GetCardNo)() |-\u003e p} | p in set PurseSet} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","state invariant holds obligation:(forall PurseSet:set of (Purse) \u0026 ((forall p, q in set PurseSet \u0026 ((p \u003c\u003e q) \u003d\u003e ((p.GetCardNo)() \u003c\u003e (q.GetCardNo)()))) \u003d\u003e (forall p in set (dom Purses) \u0026 ((Purses(p).GetCardNo)() \u003d p))))","non-empty sequence obligation:(forall tseq:seq of (Transaction) \u0026 ((not (tseq \u003d [])) \u003d\u003e (tseq \u003c\u003e [])))","recursive function obligation:(forall tseq:seq of (Transaction) \u0026 ((not (tseq \u003d [])) \u003d\u003e let tx:Transaction \u003d (hd tseq) in (Len(tseq) \u003e Len((tl tseq)))))","non-empty sequence obligation:(forall tseq:seq of (Transaction) \u0026 ((not (tseq \u003d [])) \u003d\u003e let tx:Transaction \u003d (hd tseq) in (tseq \u003c\u003e [])))","type compatibility obligation:(forall sum:nat \u0026 ((sum \u003c\u003d balance) \u003d\u003e ((balance - sum) \u003e\u003d 0)))"]