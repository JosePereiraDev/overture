["function establishes postcondition obligation:(forall mk_SwitchPositions(mode, aah):SwitchPositions, raw_grip:HandGripPosition, aah_cmd:RotCommand, saferstate:SAFER, aahstate:AAH \u0026 post_ControlCycle(mk_SwitchPositions(mode, aah), raw_grip, aah_cmd, saferstate, aahstate, let mk_SAFER(clock):SAFER \u003d saferstate, grip_cmd:SixDofCommand \u003d GripCommand(raw_grip, mode), thrusters:ThrusterSet \u003d SelectedThrusters(grip_cmd, aah_cmd, (aahstate.active_axes), (aahstate.ignore_hcm)), aahstate\u0027:AAH \u003d Transition(aah, grip_cmd, clock, aahstate), saferstate\u0027:SAFER \u003d mu(saferstate, clock |-\u003e (clock + 1)) in mk_(thrusters, saferstate\u0027, aahstate\u0027)))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e \u003cZero\u003e} | a in set tran_axis_set} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_TranCommand({a |-\u003e \u003cZero\u003e | a in set tran_axis_set})","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e \u003cZero\u003e} | a in set rot_axis_set} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_RotCommand({a |-\u003e \u003cZero\u003e | a in set rot_axis_set})","type invariant satisfiable obligation:(exists cmd:TranCommand \u0026 ((dom cmd) \u003d tran_axis_set))","type invariant satisfiable obligation:(exists cmd:RotCommand \u0026 ((dom cmd) \u003d rot_axis_set))","legal map application obligation:(forall button_pos:ControlButton, hcm_cmd:SixDofCommand, clock:nat, aahstate:AAH \u0026 (forall a in set rot_axis_set \u0026 ((not starting) \u003d\u003e ((engage \u003c\u003e \u003cAAH_off\u003e) \u003d\u003e ((a in set active_axes) \u003d\u003e (a in set (dom (hcm_cmd.rot))))))))","legal map application obligation:(forall button_pos:ControlButton, hcm_cmd:SixDofCommand, clock:nat, aahstate:AAH \u0026 (forall a in set rot_axis_set \u0026 (starting \u003d\u003e (a in set (dom (hcm_cmd.rot))))))","cases exhaustive obligation:(forall estate:EngageState, button:ControlButton, active:set of (RotAxis), clock:nat, timeout:nat \u0026 ((((((((((((mk_(estate, button) \u003d mk_(\u003cAAH_off\u003e, \u003cUp\u003e)) or (mk_(estate, button) \u003d mk_(\u003cAAH_off\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_started\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_started\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_on\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_on\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_once\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_once\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_closing\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_closing\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_twice\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_twice\u003e, \u003cDown\u003e))))","enumeration map injectivity obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 (forall m1, m2 in set {{\u003cX\u003e |-\u003e horiz}, {\u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e)}, {\u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","enumeration map injectivity obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e)}, {\u003cPitch\u003e |-\u003e twist}, {\u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen twist\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 let tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen twist\nelse \u003cZero\u003e)} in inv_TranCommand(tran))","type compatibility obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 let tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen twist\nelse \u003cZero\u003e)} in inv_RotCommand(rot))","legal map application obligation:(forall cmd:RotCommand \u0026 (forall a in set (dom cmd) \u0026 (a in set (dom cmd))))","legal map application obligation:(forall tran:TranCommand \u0026 (\u003cX\u003e in set (dom tran)))","legal map application obligation:(forall tran:TranCommand \u0026 ((tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cX\u003e in set (dom tran))))","legal map application obligation:(forall tran:TranCommand \u0026 ((not (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cY\u003e in set (dom tran)))))","legal map application obligation:(forall tran:TranCommand \u0026 ((not (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((not (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cZ\u003e in set (dom tran))))))","type compatibility obligation:(forall tran:TranCommand \u0026 inv_TranCommand((if (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cX\u003e |-\u003e tran(\u003cX\u003e)})\nelseif (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cY\u003e |-\u003e tran(\u003cY\u003e)})\nelseif (tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e)\nthen (null_tran_command ++ {\u003cZ\u003e |-\u003e tran(\u003cZ\u003e)})\nelse null_tran_command)))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 (forall a in set rot_axis_set \u0026 (a in set (dom hcm_rot))))","comprehension map injectivity obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall m1, m2 in set {{a |-\u003e aah(a)} | a in set aah_axes} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall a in set aah_axes \u0026 (a in set (dom aah))))","comprehension map injectivity obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall m1, m2 in set {{a |-\u003e hcm_rot(a)} | a in set (rot_axis_set \\ aah_axes)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall a in set (rot_axis_set \\ aah_axes) \u0026 (a in set (dom hcm_rot))))","map compatible obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall ldom1 in set (dom {a |-\u003e aah(a) | a in set aah_axes}), rdom2 in set (dom {a |-\u003e hcm_rot(a) | a in set (rot_axis_set \\ aah_axes)}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({a |-\u003e aah(a) | a in set aah_axes}(ldom1) \u003d {a |-\u003e hcm_rot(a) | a in set (rot_axis_set \\ aah_axes)}(rdom2)))))","type compatibility obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 inv_RotCommand(let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in ({a |-\u003e aah(a) | a in set aah_axes} munion {a |-\u003e hcm_rot(a) | a in set (rot_axis_set \\ aah_axes)})))","cases exhaustive obligation:(forall A:AxisCommand, B:AxisCommand, C:AxisCommand \u0026 (((((((((((((((((((((((((((mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e)) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e))))","cases exhaustive obligation:(forall A:AxisCommand, B:AxisCommand, C:AxisCommand \u0026 (((((((((((((((((((((((((((mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e)) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e))))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cX\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cPitch\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cYaw\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cY\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cZ\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cRoll\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cRoll\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cPitch\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 ((rot(\u003cPitch\u003e) \u003d \u003cZero\u003e) \u003d\u003e (\u003cYaw\u003e in set (dom rot))))","enumeration map injectivity obligation:(forall a, b, c in set axis_command_set \u0026 (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e a}, {\u003cPitch\u003e |-\u003e b}, {\u003cYaw\u003e |-\u003e c}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:is_({{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set axis_command_set}, set of (RotCommand))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(switch, grip, aah_law) |-\u003e ControlCycle(switch, grip, aah_law, safer, aah)} | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall a, b, c in set axis_command_set \u0026 (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e a}, {\u003cPitch\u003e |-\u003e b}, {\u003cYaw\u003e |-\u003e c}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:is_({{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set axis_command_set}, set of (RotCommand))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(switch, grip, aah_law) |-\u003e ControlCycle(switch, grip, aah_law, safer, aah)} | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))"]