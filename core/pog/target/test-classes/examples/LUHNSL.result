["type invariant satisfiable obligation:(exists d:Digit \u0026 (d \u003c 10))","type compatibility obligation:(forall data:seq1 of (Digit) \u0026 (inv_Digit(((total(data) * 9) mod 10)) and is_(((total(data) * 9) mod 10), nat)))","type compatibility obligation:(forall number:nat \u0026 is_(natToSeq(number), seq1 of (Digit)))","non-empty sequence obligation:(forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e (data \u003c\u003e [])))","recursive function obligation:(forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (slen(data) \u003e slen((tl data)))))","non-empty sequence obligation:(forall data:seq of (Digit) \u0026 ((not (data \u003d [])) \u003d\u003e let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (data \u003c\u003e [])))","type compatibility obligation:(forall data:seq of (Digit) \u0026 ((if (data \u003d [])\nthen 0\nelse let multipler:int \u003d (((len data) mod 2) + 1), product:int \u003d ((hd data) * multipler) in (total((tl data)) + (if (product \u003c 10)\nthen product\nelse ((product mod 10) + 1)))) \u003e\u003d 0))","cases exhaustive obligation:(forall s:seq1 of (char) \u0026 (forall i in set (inds s) \u0026 ((((((((((s(i) \u003d \u00270\u0027) or (s(i) \u003d \u00271\u0027)) or (s(i) \u003d \u00272\u0027)) or (s(i) \u003d \u00273\u0027)) or (s(i) \u003d \u00274\u0027)) or (s(i) \u003d \u00275\u0027)) or (s(i) \u003d \u00276\u0027)) or (s(i) \u003d \u00277\u0027)) or (s(i) \u003d \u00278\u0027)) or (s(i) \u003d \u00279\u0027))))","type compatibility obligation:(forall s:seq1 of (char) \u0026 is_([(cases s(i) :\nchar value [0] -\u003e 0,\nchar value [1] -\u003e 1,\nchar value [2] -\u003e 2,\nchar value [3] -\u003e 3,\nchar value [4] -\u003e 4,\nchar value [5] -\u003e 5,\nchar value [6] -\u003e 6,\nchar value [7] -\u003e 7,\nchar value [8] -\u003e 8,\nchar value [9] -\u003e 9\n end) | i in set (inds s)], seq1 of (Digit)))","type compatibility obligation:(forall n:nat \u0026 ((not (n \u003c 10)) \u003d\u003e ((n div 10) \u003e\u003d 0)))","recursive function obligation:(forall n:nat \u0026 ((not (n \u003c 10)) \u003d\u003e (id(n) \u003e id((n div 10)))))","type compatibility obligation:(forall n:nat \u0026 is_((if (n \u003c 10)\nthen [n]\nelse (natToSeq((n div 10)) ^ [(n rem 10)])), seq of (Digit)))","operation establishes postcondition obligation:(forall data:seq1 of (Digit), expected:Digit \u0026 (RESULT \u003d true))","operation establishes postcondition obligation:(forall data:seq1 of (Digit), expected:Digit \u0026 (RESULT \u003d true))"]