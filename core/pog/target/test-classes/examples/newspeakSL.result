["cases exhaustive obligation:(forall tp:Expressible_type \u0026 (((((((exists mk_VoidType(t):Expressible_type \u0026 (tp \u003d mk_VoidType(t))) or (exists mk_TrType(range, fl):Expressible_type \u0026 (tp \u003d mk_TrType(range, fl)))) or (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (tp \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(range, abse, rele, fl):Expressible_type \u0026 (tp \u003d mk_Float(range, abse, rele, fl)))) or (exists mk_VectorType(lower, upper, tp, fl):Expressible_type \u0026 (tp \u003d mk_VectorType(lower, upper, tp, fl)))) or (exists mk_StructureType(tps, fl):Expressible_type \u0026 (tp \u003d mk_StructureType(tps, fl)))) or (exists mk_UnionType(tps, fl):Expressible_type \u0026 (tp \u003d mk_UnionType(tps, fl)))))","let be st existence obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_min((s \\ {m}))))))","let be st existence obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_max((s \\ {m}))))))","cases exhaustive obligation:(forall x:Int, y:Int, mk_NumOp(op):NumOp \u0026 (((((((op \u003d \u003cnumplus\u003e) or (op \u003d \u003cbinaryminus\u003e)) or (op \u003d \u003cnummult\u003e)) or (op \u003d \u003cnumdiv\u003e)) or (op \u003d \u003cnummod\u003e)) or (op \u003d \u003cnummax\u003e)) or (op \u003d \u003cnummin\u003e)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))}))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i + j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))}))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (int) \u003d {(i - j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range))))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))}))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min({(abs min(range)), (abs max(range))})))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_min(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 let fl:Flavdom \u003d fl_mult(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i * j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e pre_max(range)))","non-zero obligation:(forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 (j \u003c\u003e 0))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(abs min(range)), (abs max(range))})))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min(range)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max(range)))","non-zero obligation:(forall x:Int, y:Int \u0026 ((not (0 in set ((y.type).range))) \u003d\u003e let fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)), range:set of (int) \u003d {(i div j) | i in set ((x.type).range), j in set ((y.type).range)} in ((not (max({(abs min(range)), (abs max(range))}) \u003e\u003d maxint)) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if (exists r in set range \u0026 ((abs r) \u003e\u003d bytemax))\nthen \u003cword\u003e\nelse \u003cbyte\u003e) in ((y.val) \u003c\u003e 0))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_max({i, j}))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in pre_max({(x.val), (y.val)})))","type compatibility obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(range, set of (int))))","type compatibility obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {max({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(max({(x.val), (y.val)}), int)))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_min({i, j}))))","legal function application obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in pre_min({(x.val), (y.val)})))","type compatibility obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(range, set of (int))))","type compatibility obligation:(forall x:Int, y:Int \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let rep:(\u003cbyte\u003e | \u003cword\u003e) \u003d (if ((((x.type).rep) \u003d \u003cword\u003e) or (((y.type).rep) \u003d \u003cword\u003e))\nthen \u003cword\u003e\nelse \u003cbyte\u003e), range:set of (real) \u003d {min({i, j}) | i in set ((x.type).range), j in set ((y.type).range)} in is_(min({(x.val), (y.val)}), int)))","cases exhaustive obligation:(forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall mk_(i, j):(int * int) \u0026 ((((op \u003d \u003cnumgt\u003e) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumge\u003e)) or (op \u003d \u003cnumle\u003e)))))","legal function application obligation:(forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((int * int) -\u003e bool) \u003d (lambda [mk_(i, j):(int * int)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j)\n end)) in pre_(pmk_((x.val), (y.val)))))","legal function application obligation:(forall x:Int, y:Int, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((int * int) -\u003e bool) \u003d (lambda [mk_(i, j):(int * int)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j)\n end)) in (forall i in set ((x.type).range), j in set ((y.type).range) \u0026 pre_(pmk_(i, j)))))","legal function application obligation:(forall z:Int \u0026 pre_min(((z.type).range)))","legal function application obligation:(forall z:Int \u0026 pre_max(((z.type).range)))","type compatibility obligation:(forall z:Int \u0026 is_(min(((z.type).range)), int))","type compatibility obligation:(forall z:Int \u0026 is_(max(((z.type).range)), int))","legal function application obligation:(forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 pre_min({(abs (range.lower)), (abs (range.upper))})))","legal function application obligation:(forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 pre_max({(abs (range.lower)), (abs (range.upper))})))","type compatibility obligation:(forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 is_(min({(abs (range.lower)), (abs (range.upper))}), int)))","type compatibility obligation:(forall r:Real \u0026 (forall range in set ((r.type).range) \u0026 is_(max({(abs (range.lower)), (abs (range.upper))}), int)))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation:(forall x:Real, y:Real \u0026 pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})))","legal function application obligation:(forall x:Real, y:Real \u0026 pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})))","legal function application obligation:(forall x:Real, y:Real \u0026 pre_max({Xmax, Ymax}))","legal function application obligation:(forall x:Real, y:Real \u0026 let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}))","legal function application obligation:(forall x:Real, y:Real \u0026 let range:set of (Floatrng) \u003d {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))})))","legal function application obligation:(forall x:Real, y:Real \u0026 pre_min({(range.lower) | range in set ((y.type).range)}))","legal function application obligation:(forall x:Real, y:Real \u0026 (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) \u003d\u003e pre_max({(range.upper) | range in set ((y.type).range)})))","non-zero obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e (forall xrange in set ((x.type).range), yrange in set ((y.type).range) \u0026 ((yrange.upper) \u003c\u003e 0))))","non-zero obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e (forall xrange in set ((x.type).range), yrange in set ((y.type).range) \u0026 ((yrange.lower) \u003c\u003e 0))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_max({Xmax, Ymax})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e pre_min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in pre_max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in (forall r in set range \u0026 pre_max({(abs (r.lower)), (abs (r.upper))}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)}))))","non-zero obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e ((Ymin ** 2) \u003c\u003e 0))))","non-zero obligation:(forall x:Real, y:Real \u0026 ((not (((((1 - ((y.type).relerr)) * min({(range.lower) | range in set ((y.type).range)})) - ((y.type).abserr)) \u003c\u003d 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | range in set ((y.type).range)})) + ((y.type).abserr)) \u003e\u003d 0))) \u003d\u003e let range:set of (Floatrng) \u003d {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | xrange in set ((x.type).range), yrange in set ((y.type).range)}, Xmax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((x.type).range)})), Ymax:real \u003d max((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})), XYmax:real \u003d max({Xmax, Ymax}), Ymin:real \u003d min((dunion {{(abs (range.lower)), (abs (range.upper))} | range in set ((y.type).range)})) in ((not (max({max({(abs (r.lower)), (abs (r.upper))}) | r in set range}) \u003e\u003d maxint)) \u003d\u003e let As:real \u003d ((((((Xmax * Ymax) * max({((x.type).relerr), ((y.type).relerr)})) + (Ymax * ((x.type).abserr))) + (Xmax * ((y.type).abserr))) / (Ymin ** 2)) + (epsilon_t * XYmax)), fl:Flavdom \u003d fl_div(((x.type).fl), ((y.type).fl)) in ((y.val) \u003c\u003e 0))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({(x.val), (y.val)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).abserr), ((y.type).abserr)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_max({(xr.lower), (yr.lower)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_max({(xr.upper), (yr.upper)}))))","type compatibility obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(max({(xr.lower), (yr.lower)}), int))))","type compatibility obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(max({(xr.upper), (yr.upper)}), int))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_min({(x.val), (y.val)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).abserr), ((y.type).abserr)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e pre_max({((x.type).relerr), ((y.type).relerr)})))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_min({(xr.lower), (yr.lower)}))))","legal function application obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 pre_min({(xr.upper), (yr.upper)}))))","type compatibility obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(min({(xr.lower), (yr.lower)}), int))))","type compatibility obligation:(forall x:Real, y:Real \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall xr in set ((x.type).range), yr in set ((y.type).range) \u0026 is_(min({(xr.upper), (yr.upper)}), int))))","type compatibility obligation:(forall r:Real \u0026 (is_((r.val), int) \u003d\u003e is_((r.val), int)))","cases exhaustive obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e (forall mk_(i, j):(real * real) \u0026 ((((op \u003d \u003cnumgt\u003e) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumle\u003e)) or (op \u003d \u003cnumge\u003e)))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_(pmk_((x.val), (y.val)))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_max(xrange)))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in pre_min(yrange)))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_(pmk_(max(xrange), min(yrange))))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_max(xrange))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((max(xrange) \u003c min(yrange)) \u003d\u003e pre_min(yrange))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_(pmk_(max(yrange), min(xrange)))))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_max(yrange)))))","legal function application obligation:(forall x:Real, y:Real, op:CompOp \u0026 ((not (((x.type).fl) \u003c\u003e ((y.type).fl))) \u003d\u003e let p:((real * real) -\u003e bool) \u003d (lambda [mk_(i, j):(real * real)] \u0026 (cases op :\n\u003cnumgt\u003e -\u003e (i \u003e j),\n\u003cnumlt\u003e -\u003e (i \u003c j),\n\u003cnumle\u003e -\u003e (i \u003c\u003d j),\n\u003cnumge\u003e -\u003e (i \u003e\u003d j)\n end)), xrange:set of (int) \u003d (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | range in set ((x.type).range)}), yrange:set of (int) \u003d (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | range in set ((y.type).range)}) in ((not (max(xrange) \u003c min(yrange))) \u003d\u003e ((min(xrange) \u003e max(yrange)) \u003d\u003e pre_min(xrange)))))","legal function application obligation:(forall r:Real \u0026 pre_min({(range.lower) | range in set ((r.type).range)}))","type compatibility obligation:(forall r:Real \u0026 let m:real \u003d ((min({(range.lower) | range in set ((r.type).range)}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in is_(m, int))","type compatibility obligation:(forall r:Real \u0026 let m:real \u003d ((min({(range.lower) | range in set ((r.type).range)}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in is_(m, int))","legal function application obligation:(forall r:Real \u0026 pre_max({(range.upper) | range in set ((r.type).range)}))","type compatibility obligation:(forall r:Real \u0026 let m:real \u003d ((max({(range.upper) | range in set ((r.type).range)}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in is_(m, int))","type compatibility obligation:(forall r:Real \u0026 let m:real \u003d ((max({(range.upper) | range in set ((r.type).range)}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in is_(m, int))","non-zero obligation:(forall mk_Real(r, f):Real \u0026 ((not (r \u003d 0)) \u003d\u003e (r \u003c\u003e 0)))","type compatibility obligation:(forall r:Real \u0026 is_(((r.type).abserr), int))","type compatibility obligation:(forall r:Real \u0026 is_(((r.type).abserr), int))","type compatibility obligation:(forall r:Real \u0026 is_(((r.type).relerr), int))","type compatibility obligation:(forall r:Real \u0026 is_(((r.type).relerr), int))","type compatibility obligation:(forall v:Component, t:CompType \u0026 (is_(v, real) \u003d\u003e is_(t, Float)))","type compatibility obligation:(forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e (is_(v, bool) \u003d\u003e is_(t, TrType))))","type compatibility obligation:(forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e ((not is_(v, bool)) \u003d\u003e is_(v, int))))","type compatibility obligation:(forall v:Component, t:CompType \u0026 ((not is_(v, real)) \u003d\u003e ((not is_(v, bool)) \u003d\u003e is_(t, IntType))))","legal sequence application obligation:(forall s:Structure, fl:Flavdom \u0026 (forall i in set (inds (s.val)) \u0026 (i in set (inds ((s.type).tps)))))","legal sequence application obligation:(forall s:Structure, fl:Flavdom \u0026 let matches:set of (nat1) \u003d {i | i in set (inds (s.val)) \u0026 ((((s.type).tps)(i).fl) \u003d fl)} in ((not ((card matches) \u003c\u003e 1)) \u003d\u003e let {i}:set of (nat1) \u003d matches in (i in set (inds (s.val)))))","legal sequence application obligation:(forall s:Structure, fl:Flavdom \u0026 let matches:set of (nat1) \u003d {i | i in set (inds (s.val)) \u0026 ((((s.type).tps)(i).fl) \u003d fl)} in ((not ((card matches) \u003c\u003e 1)) \u003d\u003e let {i}:set of (nat1) \u003d matches in (i in set (inds ((s.type).tps)))))","legal sequence application obligation:(forall v:Vector, i:int \u0026 (((i - ((v.type).lower)) + 1) in set (inds (v.val))))","type compatibility obligation:(forall v:Vector, i:int \u0026 (((((((is_((v.val)(((i - ((v.type).lower)) + 1)), Errvalue) or is_((v.val)(((i - ((v.type).lower)) + 1)), Int)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Real)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Structure)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Tr)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Union)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Vector)) or is_((v.val)(((i - ((v.type).lower)) + 1)), Void)))","type compatibility obligation:(forall v:VectorType \u0026 (((((v.type).upper) - ((v.type).lower)) + 1) \u003e\u003d 0))","type compatibility obligation:(forall vs:VectorValue \u0026 ((((((is_((conc vs), seq1 of (Errvalue)) or is_((conc vs), seq1 of (Int))) or is_((conc vs), seq1 of (Real))) or is_((conc vs), seq1 of (StructValue))) or is_((conc vs), seq1 of (Tr))) or is_((conc vs), seq1 of (VectorValue))) or is_((conc vs), seq1 of (Void))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_sum((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_sum((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realplus((hd v), s)\nelse intplus((hd v), s))), Void)))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_product((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_product((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmult((hd v), s)\nelse intmult((hd v), s))), Void)))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_all((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_((hd v), Tr))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_all((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_(b, Tr))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_all((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_and((hd v), b))), Void)))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_some((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_((hd v), Tr))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let b:Expressible_value \u003d vector_some((tl v)) in ((not (b \u003d \u003cerr\u003e)) \u003d\u003e is_(b, Tr))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let b:Expressible_value \u003d vector_some((tl v)) in (if (b \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse tr_or((hd v), b))), Void)))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_max((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_max((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmax((hd v), s)\nelse intmax((hd v), s))), Void)))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_((hd v), Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e (is_((hd v), Real) \u003d\u003e is_(s, Real)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_((hd v), Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 ((not ((len v) \u003d 1)) \u003d\u003e let s:Expressible_value \u003d vector_min((tl v)) in ((not (s \u003d \u003cerr\u003e)) \u003d\u003e ((not is_((hd v), Real)) \u003d\u003e is_(s, Int)))))","type compatibility obligation:(forall v:VectorValue \u0026 (((((((is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Errvalue) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Int)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Real)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Structure)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Tr)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Union)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Vector)) or is_((if ((len v) \u003d 1)\nthen (hd v)\nelse let s:Expressible_value \u003d vector_min((tl v)) in (if (s \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelseif is_((hd v), Real)\nthen realmin((hd v), s)\nelse intmin((hd v), s))), Void)))","type compatibility obligation:(forall v1:Vector, v2:Vector \u0026 let type:Expressible_type \u003d (if tleq(((v1.type).type), ((v2.type).type))\nthen ((v2.type).type)\nelse ((v1.type).type)), lower:int \u003d ((v1.type).lower), upper:int \u003d (((((v1.type).upper) + ((v2.type).upper)) - ((v2.type).lower)) + 1), fl:Flavdom \u003d ((v1.type).fl), vec:seq of ((Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d ((v1.val) ^ (v2.val)) in let new_type:VectorType \u003d mk_VectorType(lower, upper, type, fl) in ((((((is_(vec, seq1 of (Errvalue)) or is_(vec, seq1 of (Int))) or is_(vec, seq1 of (Real))) or is_(vec, seq1 of (StructValue))) or is_(vec, seq1 of (Tr))) or is_(vec, seq1 of (VectorValue))) or is_(vec, seq1 of (Void))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e is_([const_type((v.val)(i)) | i in set (inds (v.val))], seq1 of (Expressible_type)))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (((((((is_((v.val)(i), Errvalue) or is_((v.val)(i), Int)) or is_((v.val)(i), Real)) or is_((v.val)(i), Structure)) or is_((v.val)(i), Tr)) or is_((v.val)(i), Union)) or is_((v.val)(i), Vector)) or is_((v.val)(i), Void))))))","legal sequence application obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds (v.val)))))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e (is_(v, Vector) \u003d\u003e ((((((is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), Float) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), IntType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), StructureType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), TrType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), UnionType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), VectorType)) or is_(seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), VoidType)))))","legal sequence application obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds (v.val))))))))","legal sequence application obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e (forall i in set (inds (v.val)) \u0026 (i in set (inds ((v.type).tps))))))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e (is_(v, Structure) \u003d\u003e is_([const_type(construct_ev((v.val)(i), ((v.type).tps)(i))) | i in set (inds (v.val))], seq1 of (CompType))))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e ((not is_(v, Structure)) \u003d\u003e ((not is_(v, Union)) \u003d\u003e ((not (v \u003d \u003cerr\u003e)) \u003d\u003e (is_(v, Real) \u003d\u003e is_((if is_((v.val), int)\nthen (v.val)\nelse (floor ((v.val) + 0.5))), int))))))))","type compatibility obligation:(forall v:Expressible_value \u0026 ((not is_(v, Void)) \u003d\u003e ((not is_(v, Vector)) \u003d\u003e ((not is_(v, Structure)) \u003d\u003e ((not is_(v, Union)) \u003d\u003e ((not (v \u003d \u003cerr\u003e)) \u003d\u003e ((not is_(v, Real)) \u003d\u003e ((not is_(v, Int)) \u003d\u003e (is_((v.val), bool) and is_({(v.val)}, set of (bool)))))))))))","cases exhaustive obligation:(forall type:Expressible_type, flav:Flavdom \u0026 (((((((exists mk_VoidType(fl):Expressible_type \u0026 (type \u003d mk_VoidType(fl))) or (exists mk_TrType(r, f):Expressible_type \u0026 (type \u003d mk_TrType(r, f)))) or (exists mk_Float(r, a, re, f):Expressible_type \u0026 (type \u003d mk_Float(r, a, re, f)))) or (exists mk_IntType(rep, r, f):Expressible_type \u0026 (type \u003d mk_IntType(rep, r, f)))) or (exists mk_VectorType(l, u, t, f):Expressible_type \u0026 (type \u003d mk_VectorType(l, u, t, f)))) or (exists mk_UnionType(tps, fl):Expressible_type \u0026 (type \u003d mk_UnionType(tps, fl)))) or (exists mk_StructureType(tps, fl):Expressible_type \u0026 (type \u003d mk_StructureType(tps, fl)))))","legal function application obligation:(forall t1:Float, t2:Float \u0026 pre_max({(t1.abserr), (t2.abserr)}))","legal function application obligation:(forall t1:Float, t2:Float \u0026 pre_max({(t1.relerr), (t2.relerr)}))","type compatibility obligation:(forall t1:VectorType, t2:VectorType \u0026 ((not (((t1.lower) \u003c\u003e (t2.lower)) or (((t1.upper) \u003c\u003e (t2.upper)) or (lub((t1.type), (t2.type)) \u003d \u003cerr\u003e)))) \u003d\u003e ((((((is_(lub((t1.type), (t2.type)), Float) or is_(lub((t1.type), (t2.type)), IntType)) or is_(lub((t1.type), (t2.type)), StructureType)) or is_(lub((t1.type), (t2.type)), TrType)) or is_(lub((t1.type), (t2.type)), UnionType)) or is_(lub((t1.type), (t2.type)), VectorType)) or is_(lub((t1.type), (t2.type)), VoidType))))","legal sequence application obligation:(forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e (forall i in set (inds (t1.tps)) \u0026 (i in set (inds (t1.tps)))))))","legal sequence application obligation:(forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e (forall i in set (inds (t1.tps)) \u0026 (i in set (inds (t2.tps)))))))","type compatibility obligation:(forall t1:StructureType, t2:StructureType \u0026 ((not ((len (t1.tps)) \u003c\u003e (len (t2.tps)))) \u003d\u003e ((not (exists i in set (inds (t1.tps)) \u0026 (lub((t1.tps)(i), (t2.tps)(i)) \u003d \u003cerr\u003e))) \u003d\u003e is_([lub((t1.tps)(i), (t2.tps)(i)) | i in set (inds (t1.tps))], seq1 of (CompType)))))","type compatibility obligation:(forall t1:UnionType, t2:UnionType \u0026 ((not ((card (t1.tps)) \u003c\u003e (card (t2.tps)))) \u003d\u003e let lub:(Errvalue | Expressible_type) \u003d setlub(((t1.tps) union (t2.tps))) in ((not (lub \u003d \u003cerr\u003e)) \u003d\u003e ((not is_(lub, UnionType)) \u003d\u003e ((((is_(lub, Float) or is_(lub, IntType)) or is_(lub, TrType)) or is_(lub, VoidType)) and is_({lub}, set of ((Float | IntType | TrType | VoidType))))))))","type compatibility obligation:(forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(lub(tps(1), tps(2)), Float) or is_(lub(tps(1), tps(2)), IntType)) or is_(lub(tps(1), tps(2)), StructureType)) or is_(lub(tps(1), tps(2)), TrType)) or is_(lub(tps(1), tps(2)), UnionType)) or is_(lub(tps(1), tps(2)), VectorType)) or is_(lub(tps(1), tps(2)), VoidType)))))","type compatibility obligation:(forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(seqlub((tl tps)), Float) or is_(seqlub((tl tps)), IntType)) or is_(seqlub((tl tps)), StructureType)) or is_(seqlub((tl tps)), TrType)) or is_(seqlub((tl tps)), UnionType)) or is_(seqlub((tl tps)), VectorType)) or is_(seqlub((tl tps)), VoidType)))))","legal sequence application obligation:(forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e (1 in set (inds tps)))))","legal sequence application obligation:(forall tps:seq1 of (Expressible_type) \u0026 ((not ((len tps) \u003d 1)) \u003d\u003e ((not (lub(tps(1), tps(2)) \u003d \u003cerr\u003e)) \u003d\u003e (2 in set (inds tps)))))","type compatibility obligation:(forall s:set of (Expressible_type) \u0026 ((exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e)) \u003d\u003e ((forall t in set s \u0026 (is_(t, TrType) or (is_(t, IntType) or (is_(t, Float) or is_(t, VoidType))))) \u003d\u003e let t1:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, TrType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, TrType)}, t2:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, IntType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, IntType)}, t3:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, Float) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, Float)}, t4:set of ((Errvalue | Expressible_type)) \u003d {setlub({t\u0027 | t\u0027 in set s \u0026 (is_(t\u0027, VoidType) and ((t.fl) \u003d (t\u0027.fl)))}) | t in set s \u0026 is_(t, VoidType)} in ((not ((exists t, t\u0027 in set (dunion {t1, t2, t3, t4}) \u0026 ((t.fl) \u003d (t\u0027.fl))) or (exists t in set (dunion {t1, t2, t3}), mk_VoidType(f) in set t4 \u0026 ((t.fl) \u003d f)))) \u003d\u003e is_((((t1 union t2) union t3) union t4), set of ((Float | IntType | TrType | VoidType)))))))","let be st existence obligation:(forall s:set of (Expressible_type) \u0026 ((not (exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e))) \u003d\u003e (exists t in set s \u0026 true)))","type compatibility obligation:(forall s:set of (Expressible_type) \u0026 ((not (exists t1, t2 in set s \u0026 (lub(t1, t2) \u003d \u003cerr\u003e))) \u003d\u003e (forall t in set s \u0026 ((not (s \u003d {t})) \u003d\u003e ((((((is_(setlub((s \\ {t})), Float) or is_(setlub((s \\ {t})), IntType)) or is_(setlub((s \\ {t})), StructureType)) or is_(setlub((s \\ {t})), TrType)) or is_(setlub((s \\ {t})), UnionType)) or is_(setlub((s \\ {t})), VectorType)) or is_(setlub((s \\ {t})), VoidType))))))","let be st existence obligation:(forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e (is_(t2, TrType) \u003d\u003e (exists z in set (power {0, 1}) \u0026 ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))))))))","legal function application obligation:(forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e pre_max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t2.range)}))))))))))","legal function application obligation:(forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e (forall mk_Floatrng(lower, upper) in set (t2.range) \u0026 pre_max({lower, upper})))))))))))","legal function application obligation:(forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e pre_max({(abs max({lower, upper})) | mk_Floatrng(lower, upper) in set (t1.range)}))))))))))","legal function application obligation:(forall t1:Expressible_type, t2:Expressible_type \u0026 ((not (lub(t1, t2) \u003d t1)) \u003d\u003e (fleq(t1, t2) \u003d\u003e ((not (is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) \u003d\u003e (((1 in set z) and (false in set (t2.range))) \u003d\u003e (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))) or (is_(t1, IntType) and (z subset (t1.range)))))) \u003d\u003e ((not ((is_(t2, IntType) and (((t2.rep) \u003d \u003cbyte\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)}))))) or (is_(t1, IntType) and (((t1.rep) \u003d \u003cword\u003e) and ((t2.range) subset (t1.range)))))) \u003d\u003e ((not (is_(t2, IntType) and (((t2.rep) \u003d \u003cword\u003e) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})))))) \u003d\u003e (is_(t2, Float) \u003d\u003e (is_(t1, Float) \u003d\u003e (((dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t2.range)}) subset (dunion {{lower, ... ,upper} | mk_Floatrng(lower, upper) in set (t1.range)})) \u003d\u003e (forall mk_Floatrng(lower, upper) in set (t1.range) \u0026 pre_max({lower, upper})))))))))))","legal map application obligation:(forall l:Location, s:Store \u0026 (l in set (dom s)))","legal function application obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_(multi_update((tl ls))((tl vs))(s ++ {(hd ls) |-\u003e (hd vs)})))))","legal function application obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_(multi_update((tl ls))(tl vs)))))","legal function application obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e pre_multi_update((tl ls)))))","non-empty sequence obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (ls \u003c\u003e []))))","non-empty sequence obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (vs \u003c\u003e []))))","non-empty sequence obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (ls \u003c\u003e []))))","non-empty sequence obligation:(forall ls:seq of (Location), vs:seq of (Storable_value), s:Store \u0026 (((len ls) \u003d (len vs)) \u003d\u003e ((not (ls \u003d [])) \u003d\u003e (vs \u003c\u003e []))))","legal map application obligation:(forall i:Id, mk_(m, l):Env \u0026 (i in set (dom m)))","non-empty sequence obligation:(forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","legal function application obligation:(forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(multi_update_env((tl s))update_env(id)(v)(e))))","non-empty sequence obligation:(forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in (s \u003c\u003e [])))","legal function application obligation:(forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(update_env(id)(v)e)))","legal function application obligation:(forall s:seq of ((Id * Denotable_value)), e:Env \u0026 ((not (s \u003d [])) \u003d\u003e let mk_(id, v):(Id * Denotable_value) \u003d (hd s) in pre_(update_env(id)v)))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds formals)))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds params)))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e (forall i in set (inds formals) \u0026 (i in set (inds formals)))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 (i in set (inds formals))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 (((formals(i).fl) \u003d {}) \u003d\u003e (i in set (inds params)))))))","type compatibility obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (((((((is_((params(i).val), Errvalue) or is_((params(i).val), Int)) or is_((params(i).val), Real)) or is_((params(i).val), Structure)) or is_((params(i).val), Tr)) or is_((params(i).val), Union)) or is_((params(i).val), Vector)) or is_((params(i).val), Void)))))))","type compatibility obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e ((((((is_(replace_flavour((params(i).type), (formals(i).fl)), Float) or is_(replace_flavour((params(i).type), (formals(i).fl)), IntType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), StructureType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), TrType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), UnionType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), VectorType)) or is_(replace_flavour((params(i).type), (formals(i).fl)), VoidType)))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds params)))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds params)))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e (forall i in set (inds params) \u0026 ((not ((formals(i).fl) \u003d {})) \u003d\u003e (i in set (inds formals)))))))","legal function application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in pre_(multi_update_env([mk_((formals(i).id), vals(i)) | i in set (inds vals)])e))))","type compatibility obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in is_([mk_((formals(i).id), vals(i)) | i in set (inds vals)], seq of ((Id * Denotable_value))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in (forall i in set (inds vals) \u0026 (i in set (inds formals))))))","legal sequence application obligation:(forall formals:seq of (Formal_elt), params:Param, e:Env \u0026 ((not ((len formals) \u003c\u003e (len params))) \u003d\u003e let lubs_eq:seq of (bool) \u003d [(lub((formals(i).rep), (params(i).type)) \u003d (formals(i).rep)) | i in set (inds formals)] in ((not (false in set (elems lubs_eq))) \u003d\u003e let vals:seq of (Expressible_value) \u003d [(if ((formals(i).fl) \u003d {})\nthen params(i)\nelse widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","non-empty sequence obligation:(forall ts:seq of (Time) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","non-empty sequence obligation:(forall ts:seq of (Time) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","let be st existence obligation:(forall tp:Expressible_type \u0026 (exists val:Expressible_value \u0026 (lub(const_type(val), tp) \u003d tp)))","type compatibility obligation:(forall tp:Expressible_type \u0026 (forall val:Expressible_value \u0026 ((((((is_(const_type(val), Float) or is_(const_type(val), IntType)) or is_(const_type(val), StructureType)) or is_(const_type(val), TrType)) or is_(const_type(val), UnionType)) or is_(const_type(val), VectorType)) or is_(const_type(val), VoidType))))","type compatibility obligation:(forall tp:Expressible_type \u0026 (forall val:Expressible_value \u0026 ((lub(const_type(val), tp) \u003d tp) \u003d\u003e (((((((is_(const_type(val), Errvalue) or is_(const_type(val), Int)) or is_(const_type(val), Real)) or is_(const_type(val), Structure)) or is_(const_type(val), Tr)) or is_(const_type(val), Union)) or is_(const_type(val), Vector)) or is_(const_type(val), Void)))))","legal function application obligation:(forall mk_Program(expr):Program, l:Location, sto:Store \u0026 pre_(eval_Expression(expr)(empty_env(l))mk_PState(sto, zerot)))","legal function application obligation:(forall mk_Program(expr):Program, l:Location, sto:Store \u0026 pre_(eval_Expression(expr)empty_env(l)))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in pre_(eval_Operation(expr)(env)ps))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in pre_(eval_Operation(expr)env))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Operation(op) \u003d expr) \u003d\u003e let mk_Operation(op) \u003d expr in is_(expr, Operation))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in pre_(eval_InnerLoop(expr)(env)ps)))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in pre_(eval_InnerLoop(expr)env)))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_InnerLoop(l) \u003d expr) \u003d\u003e let mk_InnerLoop(l) \u003d expr in is_(expr, InnerLoop)))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in pre_(eval_Assignment(expr)(env)ps))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in pre_(eval_Assignment(expr)env))))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assignment(a) \u003d expr) \u003d\u003e let mk_Assignment(a) \u003d expr in is_(expr, Assignment))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in pre_(eval_Scope(expr)(env)ps)))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in pre_(eval_Scope(expr)env)))))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Scope(s) \u003d expr) \u003d\u003e let mk_Scope(s) \u003d expr in is_(expr, Scope)))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in pre_(eval_GuardedScope(expr)(env)ps))))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in pre_(eval_GuardedScope(expr)env))))))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_GuardedScope(d, i, o) \u003d expr) \u003d\u003e let mk_GuardedScope(d, i, o) \u003d expr in is_(expr, GuardedScope))))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in pre_(eval_Assertion(expr)(env)ps)))))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in pre_(eval_Assertion(expr)env)))))))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_Assertion(exp, tp) \u003d expr) \u003d\u003e let mk_Assertion(exp, tp) \u003d expr in is_(expr, Assertion)))))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in pre_(eval_TimedExpression(expr)(env)ps))))))))))","legal function application obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in pre_(eval_TimedExpression(expr)env))))))))))","type compatibility obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 ((not (exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Operation(op) \u003d expr))) \u003d\u003e ((not (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_InnerLoop(l) \u003d expr))) \u003d\u003e ((not (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assignment(a) \u003d expr))) \u003d\u003e ((not (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Scope(s) \u003d expr))) \u003d\u003e ((not (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_GuardedScope(d, i, o) \u003d expr))) \u003d\u003e ((not (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (mk_Assertion(exp, tp) \u003d expr))) \u003d\u003e (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 ((mk_TimedExpression(t) \u003d expr) \u003d\u003e let mk_TimedExpression(t) \u003d expr in is_(expr, TimedExpression))))))))))","cases exhaustive obligation:(forall mk_Expression(expr):Expression, env:Env, ps:PState \u0026 (((((((exists mk_Operation(op):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Operation(op))) or (exists mk_InnerLoop(l):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_InnerLoop(l)))) or (exists mk_Assignment(a):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Assignment(a)))) or (exists mk_Scope(s):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Scope(s)))) or (exists mk_GuardedScope(d, i, o):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_GuardedScope(d, i, o)))) or (exists mk_Assertion(exp, tp):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_Assertion(exp, tp)))) or (exists mk_TimedExpression(t):(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) \u0026 (expr \u003d mk_TimedExpression(t)))))","legal function application obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in pre_(eval_MonOperation(op)(e)ps))))","legal function application obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in pre_(eval_MonOperation(op)e))))","type compatibility obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 ((mk_MonOperation(mo) \u003d op) \u003d\u003e let mk_MonOperation(mo) \u003d op in is_(op, MonOperation))))","legal function application obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in pre_(eval_BinaryOperation(op)(e)ps)))))","legal function application obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in pre_(eval_BinaryOperation(op)e)))))","type compatibility obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((not (exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (mk_MonOperation(mo) \u003d op))) \u003d\u003e (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 ((mk_BinaryOperation(l, bo, r) \u003d op) \u003d\u003e let mk_BinaryOperation(l, bo, r) \u003d op in is_(op, BinaryOperation)))))","cases exhaustive obligation:(forall mk_Operation(op):Operation, e:Env, ps:PState \u0026 ((exists mk_MonOperation(mo):(BinaryOperation | MonOperation) \u0026 (op \u003d mk_MonOperation(mo))) or (exists mk_BinaryOperation(l, bo, r):(BinaryOperation | MonOperation) \u0026 (op \u003d mk_BinaryOperation(l, bo, r)))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_MonOpMonOperand(opr, opnd) \u003d mo) \u003d\u003e let mk_MonOpMonOperand(opr, opnd) \u003d mo in pre_(eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)ps))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_MonOpMonOperand(opr, opnd) \u003d mo) \u003d\u003e let mk_MonOpMonOperand(opr, opnd) \u003d mo in pre_(eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))e))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_VectorOperation(v, m, op) \u003d mo) \u003d\u003e let mk_VectorOperation(v, m, op) \u003d mo in pre_(eval_VectorOperation(mk_VectorOperation(v, m, op))(e)ps)))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_VectorOperation(v, m, op) \u003d mo) \u003d\u003e let mk_VectorOperation(v, m, op) \u003d mo in pre_(eval_VectorOperation(mk_VectorOperation(v, m, op))e)))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e ((not (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_VectorOperation(v, m, op) \u003d mo))) \u003d\u003e (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_Value(v) \u003d mo) \u003d\u003e let mk_Value(v) \u003d mo in pre_(eval_Value(mk_Value(v))(e)ps))))))","legal function application obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 ((not (exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_MonOpMonOperand(opr, opnd) \u003d mo))) \u003d\u003e ((not (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mk_VectorOperation(v, m, op) \u003d mo))) \u003d\u003e (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 ((mk_Value(v) \u003d mo) \u003d\u003e let mk_Value(v) \u003d mo in pre_(eval_Value(mk_Value(v))e))))))","cases exhaustive obligation:(forall mk_MonOperation(mo):MonOperation, e:Env, ps:PState \u0026 (((exists mk_MonOpMonOperand(opr, opnd):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_MonOpMonOperand(opr, opnd))) or (exists mk_VectorOperation(v, m, op):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_VectorOperation(v, m, op)))) or (exists mk_Value(v):(MonOpMonOperand | Value | VectorOperation) \u0026 (mo \u003d mk_Value(v)))))","legal function application obligation:(forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 pre_(eval_MonOperation(opnd)(e)ps))","legal function application obligation:(forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 pre_(eval_MonOperation(opnd)e))","legal function application obligation:(forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (\u003cnumabs\u003e \u003d opr)) \u003d\u003e ((not (\u003cunaryminus\u003e \u003d opr)) \u003d\u003e ((not (\u003cnot\u003e \u003d opr)) \u003d\u003e (exists mk_CompileTimeOp(o):MonOp \u0026 ((mk_CompileTimeOp(o) \u003d opr) \u003d\u003e let mk_CompileTimeOp(o) \u003d opr in pre_(eval_CompileTimeOp(opr)x))))))))","type compatibility obligation:(forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (\u003cnumabs\u003e \u003d opr)) \u003d\u003e ((not (\u003cunaryminus\u003e \u003d opr)) \u003d\u003e ((not (\u003cnot\u003e \u003d opr)) \u003d\u003e (exists mk_CompileTimeOp(o):MonOp \u0026 ((mk_CompileTimeOp(o) \u003d opr) \u003d\u003e let mk_CompileTimeOp(o) \u003d opr in is_(opr, CompileTimeOp))))))))","cases exhaustive obligation:(forall mk_MonOpMonOperand(opr, opnd):MonOpMonOperand, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(opnd)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((((((((((opr \u003d \u003cnumabs\u003e) or (opr \u003d \u003cunaryminus\u003e)) or (opr \u003d \u003cnot\u003e)) or (exists mk_CompileTimeOp(o):MonOp \u0026 (opr \u003d mk_CompileTimeOp(o)))) or (opr \u003d \u003cdiscard\u003e)) or (opr \u003d \u003cround\u003e)) or (opr \u003d \u003codd\u003e)) or (opr \u003d \u003cfloat\u003e)) or (opr \u003d \u003cmantissa\u003e)) or (opr \u003d \u003cexponent\u003e))))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Tr))) \u003d\u003e is_(val, Tr)))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((\u003cinf\u003e \u003d op) \u003d\u003e is_(val, Real))))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((\u003csup\u003e \u003d op) \u003d\u003e is_(val, Real)))))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((\u003cabsonly\u003e \u003d op) \u003d\u003e is_(val, Real))))))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((\u003crelonly\u003e \u003d op) \u003d\u003e is_(val, Real)))))))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((not (\u003crelonly\u003e \u003d op)) \u003d\u003e ((\u003cabserr\u003e \u003d op) \u003d\u003e is_(val, Real))))))))","type compatibility obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((not (\u003cinf\u003e \u003d op)) \u003d\u003e ((not (\u003csup\u003e \u003d op)) \u003d\u003e ((not (\u003cabsonly\u003e \u003d op)) \u003d\u003e ((not (\u003crelonly\u003e \u003d op)) \u003d\u003e ((not (\u003cabserr\u003e \u003d op)) \u003d\u003e ((\u003crelerr\u003e \u003d op) \u003d\u003e is_(val, Real)))))))))","cases exhaustive obligation:(forall mk_CompileTimeOp(op):CompileTimeOp, mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e ((((((op \u003d \u003cinf\u003e) or (op \u003d \u003csup\u003e)) or (op \u003d \u003cabsonly\u003e)) or (op \u003d \u003crelonly\u003e)) or (op \u003d \u003cabserr\u003e)) or (op \u003d \u003crelerr\u003e))))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Real)))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Int)))","type compatibility obligation:(forall mk_EST_value(val, sto, time):EST_value \u0026 ((not (not is_(val, Real))) \u003d\u003e is_(val, Int)))","legal function application obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(mo)(e)ps))","legal function application obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(mo)e))","legal function application obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e pre_(eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))(mult)e))))","legal function application obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e pre_(eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))mult))))","type compatibility obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e ((not (mult \u003d nil)) \u003d\u003e is_(mult, Multiple))))","cases exhaustive obligation:(forall mk_VectorOperation(vo, mo, mult):VectorOperation, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_MonOperation(mo)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let v:EST_value \u003d (if (mult \u003d nil)\nthen x\nelse eval_VectorMult(mu(x, sto |-\u003e (ps.sto)))(mult)(e)) in ((not ((v.val) \u003d \u003cerr\u003e)) \u003d\u003e (((((((vo \u003d \u003csum\u003e) or (vo \u003d \u003cproduct\u003e)) or (vo \u003d \u003cvecmax\u003e)) or (vo \u003d \u003cvecmin\u003e)) or (vo \u003d \u003call\u003e)) or (vo \u003d \u003csome\u003e)) or (vo \u003d \u003cflatten\u003e)))))","value binding obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 (exists mk_Vector(val, type):Expressible_value \u0026 (mk_Vector(val, type) \u003d est_val)))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 is_(est_val, Vector))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in pre_(eval_Operation(op)(e)mk_PState(sto, time)))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in pre_(eval_Operation(op)e))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in pre_(eval_Operation(to_p)(e)mk_PState(sto, (b1.time))))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in pre_(eval_Operation(to_p)e))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e pre_min({((b1.val).val), ((b2.val).val)}))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e ((is_(((b1.val).val), real) and is_(((b2.val).val), real)) and is_({((b1.val).val), ((b2.val).val)}, set of (real))))))","legal function application obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e pre_max({((b1.val).val), ((b2.val).val)}))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e ((is_(((b1.val).val), real) and is_(((b2.val).val), real)) and is_({((b1.val).val), ((b2.val).val)}, set of (real))))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(lower, int)))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(upper, int)))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(lower, int)))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e is_(upper, int)))))","type compatibility obligation:(forall mk_EST_value(est_val, sto, time):EST_value, mk_Multiple(op, to_p):Multiple, e:Env \u0026 let mk_Vector(val, type):Expressible_value \u003d est_val in let b1:EST_value \u003d eval_Operation(op)(e)(mk_PState(sto, time)) in let b2:EST_value \u003d eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (((card (((b1.val).type).range)) \u003c\u003e 1) or ((card (((b2.val).type).range)) \u003c\u003e 1))) \u003d\u003e let lower:real \u003d min({((b1.val).val), ((b2.val).val)}), upper:real \u003d max({((b1.val).val), ((b2.val).val)}) in ((not ((lower \u003c (type.lower)) or ((type.upper) \u003c upper))) \u003d\u003e let new_val:VectorValue \u003d vector_subv(val, lower, upper), new_type:VectorType \u003d mk_VectorType(lower, upper, (type.type), (type.fl)) in is_((upper - lower), int)))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 ((mk_NumOp(opr) \u003d op) \u003d\u003e let mk_NumOp(opr) \u003d op in pre_(eval_NumOp(bo)(e)ps))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 ((mk_NumOp(opr) \u003d op) \u003d\u003e let mk_NumOp(opr) \u003d op in pre_(eval_NumOp(bo)e))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((\u003cnumgt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((\u003cnumgt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((\u003cnumlt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps)))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((\u003cnumlt\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e)))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((\u003cnumge\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((\u003cnumge\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((\u003cnumle\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)(e)ps)))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((\u003cnumle\u003e \u003d op) \u003d\u003e pre_(eval_CompOp(bo)e)))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)(e)ps))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)e))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)(e)ps)))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e pre_(eval_BoolOp(bo)e)))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((\u003cEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)(e)ps))))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((\u003cEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)e))))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((\u003cNEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)(e)ps)))))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((\u003cNEQ\u003e \u003d op) \u003d\u003e pre_(eval_EqOp(bo)e)))))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((not (\u003cNEQ\u003e \u003d op)) \u003d\u003e ((\u003cconcat\u003e \u003d op) \u003d\u003e pre_(eval_Concat(bo)(e)ps))))))))))))","legal function application obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((not (exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(opr) \u003d op))) \u003d\u003e ((not (\u003cnumgt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumlt\u003e \u003d op)) \u003d\u003e ((not (\u003cnumge\u003e \u003d op)) \u003d\u003e ((not (\u003cnumle\u003e \u003d op)) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((not (\u003cor\u003e \u003d op)) \u003d\u003e ((not (\u003cEQ\u003e \u003d op)) \u003d\u003e ((not (\u003cNEQ\u003e \u003d op)) \u003d\u003e ((\u003cconcat\u003e \u003d op) \u003d\u003e pre_(eval_Concat(bo)e))))))))))))","cases exhaustive obligation:(forall bo:BinaryOperation, e:Env, ps:PState \u0026 let mk_BinaryOp(op):BinaryOp \u003d (bo.opr) in ((((((((((exists mk_NumOp(opr):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (op \u003d mk_NumOp(opr))) or (op \u003d \u003cnumgt\u003e)) or (op \u003d \u003cnumlt\u003e)) or (op \u003d \u003cnumge\u003e)) or (op \u003d \u003cnumle\u003e)) or (op \u003d \u003cand\u003e)) or (op \u003d \u003cor\u003e)) or (op \u003d \u003cEQ\u003e)) or (op \u003d \u003cNEQ\u003e)) or (op \u003d \u003cconcat\u003e)))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","value binding obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e (exists mk_VoidType(f):(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u0026 (mk_VoidType(f) \u003d ((a2.val).type)))))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e is_(((a2.val).type), VoidType)))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (exists mk_NumOp(op):(\u003creplaceflav\u003e | BoolOp | CompOp | EqOp | NumOp | VecBinOp) \u0026 (mk_NumOp(op) \u003d opr))) \u003d\u003e ((\u003creplaceflav\u003e \u003d opr) \u003d\u003e ((((a2.val) \u003c\u003e \u003cerr\u003e) and is_((a2.val), Void)) \u003d\u003e let mk_VoidType(f):(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((a2.val).type) in ((((((is_(replace_flavour(((a1.val).type), f), Float) or is_(replace_flavour(((a1.val).type), f), IntType)) or is_(replace_flavour(((a1.val).type), f), StructureType)) or is_(replace_flavour(((a1.val).type), f), TrType)) or is_(replace_flavour(((a1.val).type), f), UnionType)) or is_(replace_flavour(((a1.val).type), f), VectorType)) or is_(replace_flavour(((a1.val).type), f), VoidType))))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a1.val), Int)))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a2.val), Int)))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e (((is_(opr, \u003cnumge\u003e) or is_(opr, \u003cnumgt\u003e)) or is_(opr, \u003cnumle\u003e)) or is_(opr, \u003cnumlt\u003e))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a1.val), Real))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a2.val), Real))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(opr), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e (((is_(opr, \u003cnumge\u003e) or is_(opr, \u003cnumgt\u003e)) or is_(opr, \u003cnumle\u003e)) or is_(opr, \u003cnumlt\u003e)))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e is_((a1.val), Tr)))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e is_((a2.val), Tr)))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((is_((a1.val), Tr) and is_((a2.val), Tr)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a1.val), Real))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e is_((a2.val), Real))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((is_((a1.val), Real) and is_((a2.val), Real)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e)))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a1.val), Int)))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e is_((a2.val), Int)))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((is_((a1.val), Int) and is_((a2.val), Int)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e))))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e is_((a1.val), Void))))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e is_((a2.val), Void))))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (is_((a1.val), Tr) and is_((a2.val), Tr))) \u003d\u003e ((not (is_((a1.val), Real) and is_((a2.val), Real))) \u003d\u003e ((not (is_((a1.val), Int) and is_((a2.val), Int))) \u003d\u003e ((is_((a1.val), Void) and is_((a2.val), Void)) \u003d\u003e (is_(op, \u003cEQ\u003e) or is_(op, \u003cNEQ\u003e)))))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e is_((a1.val), Tr))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((\u003cand\u003e \u003d op) \u003d\u003e is_((a2.val), Tr))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e is_((a1.val), Tr)))))","type compatibility obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((not (\u003cand\u003e \u003d op)) \u003d\u003e ((\u003cor\u003e \u003d op) \u003d\u003e is_((a2.val), Tr)))))","cases exhaustive obligation:(forall mk_BinaryOperation(left, mk_BinaryOp(op), right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a2.val), Tr) and is_((a2.val), Tr)))) \u003d\u003e ((op \u003d \u003cand\u003e) or (op \u003d \u003cor\u003e))))","legal function application obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)(e)ps))","legal function application obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 pre_(eval_MonOperation(left)e))","legal function application obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)(e)mu(ps, time |-\u003e (a1.time))))","legal function application obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in pre_(eval_MonOperation(right)e))","type compatibility obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_((a1.val), Vector))))","type compatibility obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_((a2.val), Vector))))","type compatibility obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_(((a1.val).type), VectorType))))","type compatibility obligation:(forall mk_BinaryOperation(left, op, right):BinaryOperation, e:Env, ps:PState \u0026 let a1:EST_value \u003d eval_MonOperation(left)(e)(ps) in let a2:EST_value \u003d eval_MonOperation(right)(e)(mu(ps, time |-\u003e (a1.time))) in ((not (not (is_((a1.val), Vector) and is_((a2.val), Vector)))) \u003d\u003e ((not (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))) \u003d\u003e is_(((a2.val).type), VectorType))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_ConstantValue(c) \u003d val) \u003d\u003e let mk_ConstantValue(c) \u003d val in pre_(eval_ConstantValue(mk_ConstantValue(c))ps))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_NamedValue(n) \u003d val) \u003d\u003e let mk_NamedValue(n) \u003d val in pre_(eval_NamedValue(mk_NamedValue(n))(e)ps)))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_NamedValue(n) \u003d val) \u003d\u003e let mk_NamedValue(n) \u003d val in pre_(eval_NamedValue(mk_NamedValue(n))e)))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_VectorVal(v) \u003d val) \u003d\u003e let mk_VectorVal(v) \u003d val in pre_(eval_VectorVal(mk_VectorVal(v))(e)ps))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_VectorVal(v) \u003d val) \u003d\u003e let mk_VectorVal(v) \u003d val in pre_(eval_VectorVal(mk_VectorVal(v))e))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_StructureValue(s) \u003d val) \u003d\u003e let mk_StructureValue(s) \u003d val in pre_(eval_StructureValue(mk_StructureValue(s))(e)ps)))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_StructureValue(s) \u003d val) \u003d\u003e let mk_StructureValue(s) \u003d val in pre_(eval_StructureValue(mk_StructureValue(s))e)))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Sequence(s) \u003d val) \u003d\u003e let mk_Sequence(s) \u003d val in pre_(eval_Sequence(mk_Sequence(s))(e)ps))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Sequence(s) \u003d val) \u003d\u003e let mk_Sequence(s) \u003d val in pre_(eval_Sequence(mk_Sequence(s))e))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Call(id, acts) \u003d val) \u003d\u003e let mk_Call(id, acts) \u003d val in pre_(eval_Call(mk_Call(id, acts))(e)ps)))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Call(id, acts) \u003d val) \u003d\u003e let mk_Call(id, acts) \u003d val in pre_(eval_Call(mk_Call(id, acts))e)))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in pre_(eval_Conditional(val)(e)ps))))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in pre_(eval_Conditional(val)e))))))))))","type compatibility obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Conditional(c) \u003d val) \u003d\u003e let mk_Conditional(c) \u003d val in is_(val, Conditional))))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in pre_(eval_Widening(val)(e)ps)))))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in pre_(eval_Widening(val)e)))))))))))","type compatibility obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_Widening(exp, t) \u003d val) \u003d\u003e let mk_Widening(exp, t) \u003d val in is_(val, Widening)))))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in pre_(eval_OuterLoop(val)(e)ps))))))))))))","legal function application obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in pre_(eval_OuterLoop(val)e))))))))))))","type compatibility obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 ((not (exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_ConstantValue(c) \u003d val))) \u003d\u003e ((not (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_NamedValue(n) \u003d val))) \u003d\u003e ((not (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_VectorVal(v) \u003d val))) \u003d\u003e ((not (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_StructureValue(s) \u003d val))) \u003d\u003e ((not (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Sequence(s) \u003d val))) \u003d\u003e ((not (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Call(id, acts) \u003d val))) \u003d\u003e ((not (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Conditional(c) \u003d val))) \u003d\u003e ((not (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (mk_Widening(exp, t) \u003d val))) \u003d\u003e (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 ((mk_OuterLoop(l) \u003d val) \u003d\u003e let mk_OuterLoop(l) \u003d val in is_(val, OuterLoop))))))))))))","cases exhaustive obligation:(forall mk_Value(val):Value, e:Env, ps:PState \u0026 (((((((((exists mk_ConstantValue(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_ConstantValue(c))) or (exists mk_NamedValue(n):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_NamedValue(n)))) or (exists mk_VectorVal(v):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_VectorVal(v)))) or (exists mk_StructureValue(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_StructureValue(s)))) or (exists mk_Sequence(s):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Sequence(s)))) or (exists mk_Call(id, acts):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Call(id, acts)))) or (exists mk_Conditional(c):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Conditional(c)))) or (exists mk_Widening(exp, t):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_Widening(exp, t)))) or (exists mk_OuterLoop(l):(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) \u0026 (val \u003d mk_OuterLoop(l)))))","legal sequence application obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","legal sequence application obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","type compatibility obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in is_([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)], seq1 of (Expressible_type)))))))))","legal sequence application obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in (forall i in set (inds s) \u0026 (i in set (inds s))))))))))","type compatibility obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in ((((((is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), Float) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), IntType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), StructureType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), TrType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), UnionType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), VectorType)) or is_(seqlub([mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {}) | i in set (inds s)]), VoidType)))))))))","type compatibility obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Ascii_string(s) \u003d cv) \u003d\u003e let mk_Ascii_string(s) \u003d cv in ((((((is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Errvalue)) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Int))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Real))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (StructValue))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Tr))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (VectorValue))) or is_([mk_Int(ascii(s(i)), mk_IntType(\u003cbyte\u003e, {ascii(s(i))}, {})) | i in set (inds s)], seq1 of (Void))))))))))","type compatibility obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 ((not (exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_IntegerDenotation(z) \u003d cv))) \u003d\u003e ((not (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_FloatingDenotation(r) \u003d cv))) \u003d\u003e ((not (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_BooleanDenotation(b) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_Char(c) \u003d cv))) \u003d\u003e ((not (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (mk_Ascii_string(s) \u003d cv))) \u003d\u003e (exists mk_Flavouring(fl):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 ((mk_Flavouring(fl) \u003d cv) \u003d\u003e let mk_Flavouring(fl) \u003d cv in is_(cv, Flavouring)))))))))","cases exhaustive obligation:(forall mk_ConstantValue(cv):ConstantValue, ps:PState \u0026 (((((((exists mk_IntegerDenotation(z):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_IntegerDenotation(z))) or (exists mk_FloatingDenotation(r):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_FloatingDenotation(r)))) or (exists mk_BooleanDenotation(b):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_BooleanDenotation(b)))) or (exists mk_Ascii_Char(c):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Ascii_Char(c)))) or (exists mk_Ascii_string(s):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Ascii_string(s)))) or (exists mk_Flavouring(fl):(\u003cskip\u003e | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) \u0026 (cv \u003d mk_Flavouring(fl)))) or (cv \u003d \u003cskip\u003e)))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in pre_(eval_FlavourExtract(nv)(e)ps))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in pre_(eval_FlavourExtract(nv)e))))","type compatibility obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourExtract(n, fl) \u003d nv) \u003d\u003e let mk_FlavourExtract(n, fl) \u003d nv in is_(nv, FlavourExtract))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in pre_(eval_FlavourStrip(nv)(e)ps)))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in pre_(eval_FlavourStrip(nv)e)))))","type compatibility obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_FlavourStrip(n, fl) \u003d nv) \u003d\u003e let mk_FlavourStrip(n, fl) \u003d nv in is_(nv, FlavourStrip)))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in pre_(eval_VectorExtract(nv)(e)ps))))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in pre_(eval_VectorExtract(nv)e))))))","type compatibility obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorExtract(n, i) \u003d nv) \u003d\u003e let mk_VectorExtract(n, i) \u003d nv in is_(nv, VectorExtract))))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in pre_(eval_VectorTrimming(nv)(e)ps)))))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in pre_(eval_VectorTrimming(nv)e)))))))","type compatibility obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 ((mk_VectorTrimming(n, t, i) \u003d nv) \u003d\u003e let mk_VectorTrimming(n, t, i) \u003d nv in is_(nv, VectorTrimming)))))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e pre_(eval_Identifier(nv)(e)ps))))))","legal function application obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e pre_(eval_Identifier(nv)e))))))","type compatibility obligation:(forall mk_NamedValue(nv):NamedValue, e:Env, ps:PState \u0026 ((not (exists mk_FlavourExtract(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourExtract(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_FlavourStrip(n, fl):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_FlavourStrip(n, fl) \u003d nv))) \u003d\u003e ((not (exists mk_VectorExtract(n, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorExtract(n, i) \u003d nv))) \u003d\u003e ((not (exists mk_VectorTrimming(n, t, i):(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) \u0026 (mk_VectorTrimming(n, t, i) \u003d nv))) \u003d\u003e is_(nv, token))))))","legal function application obligation:(forall id:Id, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((id in set (dom m)) \u003d\u003e (exists mk_Location(l):Denotable_value \u0026 ((mk_Location(l) \u003d access_env(id)(mk_(m, l))) \u003d\u003e let mk_Location(l) \u003d access_env(id)(mk_(m, l)) in pre_(access(mk_Location(l))sto)))))","cases exhaustive obligation:(forall id:Id, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((id in set (dom m)) \u003d\u003e ((exists mk_Location(l):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Location(l))) or (exists mk_Storable_value(v):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Storable_value(v))))))","legal function application obligation:(forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)(e)ps))","legal function application obligation:(forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)e))","type compatibility obligation:(forall mk_FlavourExtract(nv, fl):FlavourExtract, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e is_((n.val), Structure)))","non-empty sequence obligation:(forall mk_Flavouring(fls):Flavouring \u0026 ((not (fls \u003d [])) \u003d\u003e (fls \u003c\u003e [])))","non-empty sequence obligation:(forall mk_Flavouring(fls):Flavouring \u0026 ((not (fls \u003d [])) \u003d\u003e (fls \u003c\u003e [])))","type compatibility obligation:(forall mk_Flavour(name, index):Flavour \u0026 is_(index, rat))","legal function application obligation:(forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)(e)ps))","legal function application obligation:(forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 pre_(eval_NamedValue(nv)e))","type compatibility obligation:(forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e is_((n.val), Structure)))","type compatibility obligation:(forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e let n\u0027:Expressible_value \u003d comp_extract((n.val), f) in is_(((n\u0027.type).tps), seq1 of (CompType))))","type compatibility obligation:(forall mk_FlavourStrip(nv, fl):FlavourStrip, e:Env, ps:PState \u0026 let n:EST_value \u003d eval_NamedValue(nv)(e)(ps), f:Flavdom \u003d eval_Flavouring(fl) in ((not (not is_((n.val), Structure))) \u003d\u003e let n\u0027:Expressible_value \u003d comp_extract((n.val), f) in is_((n\u0027.val), seq1 of (Component))))","legal function application obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(n)(e)ps))","legal function application obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 pre_(eval_NamedValue(n)e))","legal function application obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e pre_(eval_Operation(i)(e)mu(ps, time |-\u003e (x.time)))))","legal function application obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e pre_(eval_Operation(i)e)))","type compatibility obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let index:EST_value \u003d eval_Operation(i)(e)(mu(ps, time |-\u003e (x.time))), length:int \u003d (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in ((not (not is_((index.val), Int))) \u003d\u003e ((not (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))) \u003d\u003e is_((x.val), Vector)))))","type compatibility obligation:(forall mk_VectorExtract(n, i):VectorExtract, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_NamedValue(n)(e)(ps) in ((not (not is_((x.val), Vector))) \u003d\u003e let index:EST_value \u003d eval_Operation(i)(e)(mu(ps, time |-\u003e (x.time))), length:int \u003d (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in ((not (not is_((index.val), Int))) \u003d\u003e ((not (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))) \u003d\u003e is_(((index.val).val), int)))))","legal function application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 pre_(eval_NamedValue(name)(e)ps))","legal function application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 pre_(eval_NamedValue(name)e))","legal function application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e pre_(eval_CompileTimeValue(ctv)e)))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003e\u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val)))))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((vec.val).val)(i), real))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((v.val).val), real))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((\u003cgtvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val))))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003c\u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val))))))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((vec.val).val)(i), real)))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 is_(((v.val).val), real)))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((\u003cltvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val)))))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((not (\u003cltvalue\u003e \u003d to_p)) \u003d\u003e ((\u003catvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 ((((vec.val).val)(i) \u003d ((v.val).val)) \u003d\u003e (i in set (inds ((vec.val).val)))))))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e ((not (\u003cgtvalue\u003e \u003d to_p)) \u003d\u003e ((not (\u003cltvalue\u003e \u003d to_p)) \u003d\u003e ((\u003catvalue\u003e \u003d to_p) \u003d\u003e (forall i in set (inds ((vec.val).val)) \u0026 (i in set (inds ((vec.val).val))))))))))","cases exhaustive obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e (((to_p \u003d \u003cgtvalue\u003e) or (to_p \u003d \u003cltvalue\u003e)) or (to_p \u003d \u003catvalue\u003e)))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e is_([const_type(new_v(i)) | i in set (inds new_v)], seq1 of (Expressible_type))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e (forall i in set (inds new_v) \u0026 (((((((is_(new_v(i), Errvalue) or is_(new_v(i), Int)) or is_(new_v(i), Real)) or is_(new_v(i), Structure)) or is_(new_v(i), Tr)) or is_(new_v(i), Union)) or is_(new_v(i), Vector)) or is_(new_v(i), Void)))))))","legal sequence application obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e (forall i in set (inds new_v) \u0026 (i in set (inds new_v)))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e let new_l:int \u003d (((vec.val).type).lower), new_u:int \u003d (((((vec.val).type).lower) + (len new_v)) - 1), new_t:(Errvalue | Expressible_type) \u003d seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl:Flavdom \u003d (((vec.val).type).fl) in ((((((is_(new_t, Float) or is_(new_t, IntType)) or is_(new_t, StructureType)) or is_(new_t, TrType)) or is_(new_t, UnionType)) or is_(new_t, VectorType)) or is_(new_t, VoidType))))))","type compatibility obligation:(forall mk_VectorTrimming(name, to_p, ctv):VectorTrimming, e:Env, ps:PState \u0026 let vec:EST_value \u003d eval_NamedValue(name)(e)(ps) in ((not ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))) \u003d\u003e let v:EST_value \u003d eval_CompileTimeValue(ctv)(e) in ((not (not (is_((v.val), Real) or is_((v.val), Int)))) \u003d\u003e let new_v:seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) \u003d (cases to_p :\n\u003cgtvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003e\u003d ((v.val).val))],\n\u003cltvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003c\u003d ((v.val).val))],\n\u003catvalue\u003e -\u003e [((vec.val).val)(i) | i in set (inds ((vec.val).val)) \u0026 (((vec.val).val)(i) \u003d ((v.val).val))]\n end) in ((not (new_v \u003d [])) \u003d\u003e let new_l:int \u003d (((vec.val).type).lower), new_u:int \u003d (((((vec.val).type).lower) + (len new_v)) - 1), new_t:(Errvalue | Expressible_type) \u003d seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl:Flavdom \u003d (((vec.val).type).fl) in ((((((is_(new_v, seq1 of (Errvalue)) or is_(new_v, seq1 of (Int))) or is_(new_v, seq1 of (Real))) or is_(new_v, seq1 of (StructValue))) or is_(new_v, seq1 of (Tr))) or is_(new_v, seq1 of (VectorValue))) or is_(new_v, seq1 of (Void)))))))","legal map application obligation:(forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 (forall id in set (dom m) \u0026 (id in set (dom m))))","legal function application obligation:(forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 let locs:set of (Id) \u003d {id | id in set (dom m) \u0026 is_(m(id), Location)} in let new_m:map (Id) to (Denotable_value) \u003d (locs \u003c-: m) in let new_env:(map (Id) to (Denotable_value) * Location) \u003d mk_(new_m, l) in pre_(eval_Operation(op)(new_env)mk_PState({|-\u003e}, zerot)))","legal function application obligation:(forall mk_CompileTimeValue(op):CompileTimeValue, mk_(m, l):Env \u0026 let locs:set of (Id) \u003d {id | id in set (dom m) \u0026 is_(m(id), Location)} in let new_m:map (Id) to (Denotable_value) \u003d (locs \u003c-: m) in let new_env:(map (Id) to (Denotable_value) * Location) \u003d mk_(new_m, l) in pre_(eval_Operation(op)new_env))","legal function application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))(e)mk_PState((ps.sto), zerot))))","legal function application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))e)))","legal sequence application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 (i in set (inds ops))))","legal sequence application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))","legal sequence application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (forall i in set (inds vals) \u0026 (i in set (inds vals))))","type compatibility obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e is_([(val(i).type) | i in set (inds val)], seq1 of (Expressible_type))))","legal sequence application obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e (forall i in set (inds val) \u0026 (i in set (inds val)))))","type compatibility obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([(val(i).type) | i in set (inds val)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))","type compatibility obligation:(forall mk_VectorVal(ops):VectorVal, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val:seq of (Expressible_value) \u003d [(vals(i).val) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]) in ((not (\u003cerr\u003e in set (elems val))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([(val(i).type) | i in set (inds val)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let tp:VectorType \u003d mk_VectorType(1, (len val), type, {}) in ((((((is_(val, seq1 of (Errvalue)) or is_(val, seq1 of (Int))) or is_(val, seq1 of (Real))) or is_(val, seq1 of (StructValue))) or is_(val, seq1 of (Tr))) or is_(val, seq1 of (VectorValue))) or is_(val, seq1 of (Void))))))","legal function application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))(e)mk_PState((ps.sto), zerot))))","legal function application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 pre_(eval_Operation(ops(i))e)))","legal sequence application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 (forall i in set (inds ops) \u0026 (i in set (inds ops))))","legal sequence application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","legal sequence application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","legal sequence application obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e (forall i in set (inds vals) \u0026 (i in set (inds vals))))))","type compatibility obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e let tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [((vals(i).val).type) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]), comps:seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) \u003d [((vals(i).val).val) | i in set (inds vals)] in is_(tps, seq1 of (CompType)))))","type compatibility obligation:(forall mk_StructureValue(ops):StructureValue, e:Env, ps:PState \u0026 let vals:seq of (EST_value) \u003d [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in ((not (exists val in set (elems vals) \u0026 (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))) \u003d\u003e ((not (exists v1, v2 in set (elems vals) \u0026 fleq(((v1.val).type), ((v2.val).type)))) \u003d\u003e let tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [((vals(i).val).type) | i in set (inds vals)], time:Time \u003d dtplus([(vals(i).time) | i in set (inds vals)]), comps:seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) \u003d [((vals(i).val).val) | i in set (inds vals)] in let type:StructureType \u003d mk_StructureType(tps, {}) in is_(comps, seq1 of (Component)))))","legal function application obligation:(forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 pre_(eval_Expression((hd exprs))(e)ps))","legal function application obligation:(forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 pre_(eval_Expression((hd exprs))e))","legal function application obligation:(forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression((hd exprs))(e)(ps) in ((not ((len exprs) \u003d 1)) \u003d\u003e (is_((x.val), Void) \u003d\u003e pre_(eval_Sequence(mk_Sequence((tl exprs)))(e)mk_PState((x.sto), (x.time))))))","legal function application obligation:(forall mk_Sequence(exprs):Sequence, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression((hd exprs))(e)(ps) in ((not ((len exprs) \u003d 1)) \u003d\u003e (is_((x.val), Void) \u003d\u003e pre_(eval_Sequence(mk_Sequence((tl exprs)))e))))","legal function application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e pre_(access_env(id)mk_(m, l))))","value binding obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e (exists mk_Proc(p):Denotable_value \u0026 (mk_Proc(p) \u003d pp)))))","type compatibility obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e is_(pp, Proc))))","legal function application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in pre_(eval_Acts(acts)(mk_(m, l))mk_PState(sto, time)))))","legal function application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in pre_(eval_Acts(acts)mk_(m, l)))))","legal function application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e pre_(p([(params(i).val) | i in set (inds params)])mk_PState(sto, (params((len params)).time)))))))","legal function application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e pre_(p[(params(i).val) | i in set (inds params)])))))","legal sequence application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e (forall i in set (inds params) \u0026 (i in set (inds params)))))))","legal sequence application obligation:(forall mk_Call(id, acts):Call, mk_(m, l):Env, mk_PState(sto, time):PState \u0026 ((not (id not in set (dom m))) \u003d\u003e let pp:Denotable_value \u003d access_env(id)(mk_(m, l)) in ((not (not is_(pp, Proc))) \u003d\u003e let mk_Proc(p):Denotable_value \u003d pp in let params:seq of (EST_value) \u003d eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems params)})) \u003d\u003e ((len params) in set (inds params))))))","legal function application obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e pre_(eval_Operation((hd ops))(e)ps)))","legal function application obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e pre_(eval_Operation((hd ops))e)))","non-empty sequence obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e (ops \u003c\u003e [])))","legal function application obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in pre_(eval_Acts((tl ops))(e)mk_PState((ps.sto), (x.time)))))","legal function application obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in pre_(eval_Acts((tl ops))e)))","non-empty sequence obligation:(forall ops:seq of (Operation), e:Env, ps:PState \u0026 ((not (ops \u003d [])) \u003d\u003e let x:EST_value \u003d eval_Operation((hd ops))(e)(ps) in (ops \u003c\u003e [])))","legal function application obligation:(forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Type(dest_type)e)))","type compatibility obligation:(forall mk_Widening(expr, dest_type):Widening, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type), dt:(Errvalue | Expressible_type) \u003d eval_Type(dest_type)(e) in ((not (dt \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(dt, Float) or is_(dt, IntType)) or is_(dt, StructureType)) or is_(dt, TrType)) or is_(dt, UnionType)) or is_(dt, VectorType)) or is_(dt, VoidType)))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_PrimitiveType(p) \u003d tp) \u003d\u003e let mk_PrimitiveType(p) \u003d tp in pre_(eval_PrimitiveType(tp)e))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_PrimitiveType(p) \u003d tp) \u003d\u003e let mk_PrimitiveType(p) \u003d tp in is_(tp, PrimitiveType))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_VecType(range, tpe) \u003d tp) \u003d\u003e let mk_VecType(range, tpe) \u003d tp in pre_(eval_VecType(tp)e)))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_VecType(range, tpe) \u003d tp) \u003d\u003e let mk_VecType(range, tpe) \u003d tp in is_(tp, VecType)))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_StrucType(tps) \u003d tp) \u003d\u003e let mk_StrucType(tps) \u003d tp in pre_(eval_StrucType(tp)e))))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_StrucType(tps) \u003d tp) \u003d\u003e let mk_StrucType(tps) \u003d tp in is_(tp, StrucType))))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_FlavouredType(fl, tpe) \u003d tp) \u003d\u003e let mk_FlavouredType(fl, tpe) \u003d tp in pre_(eval_FlavouredType(tp)e)))))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_FlavouredType(fl, tpe) \u003d tp) \u003d\u003e let mk_FlavouredType(fl, tpe) \u003d tp in is_(tp, FlavouredType)))))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_UnionTp(tps) \u003d tp) \u003d\u003e let mk_UnionTp(tps) \u003d tp in pre_(eval_UnionTp(tp)e))))))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_UnionTp(tps) \u003d tp) \u003d\u003e let mk_UnionTp(tps) \u003d tp in is_(tp, UnionTp))))))))","legal function application obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_UnionTp(tps) \u003d tp))) \u003d\u003e (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_TypeName(id) \u003d tp) \u003d\u003e let mk_TypeName(id) \u003d tp in pre_(eval_TypeName(tp)e)))))))))","type compatibility obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((not (exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_PrimitiveType(p) \u003d tp))) \u003d\u003e ((not (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_VecType(range, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_StrucType(tps) \u003d tp))) \u003d\u003e ((not (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_FlavouredType(fl, tpe) \u003d tp))) \u003d\u003e ((not (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (mk_UnionTp(tps) \u003d tp))) \u003d\u003e (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 ((mk_TypeName(id) \u003d tp) \u003d\u003e let mk_TypeName(id) \u003d tp in is_(tp, TypeName)))))))))","cases exhaustive obligation:(forall mk_Type(tp):Type, e:Env \u0026 ((((((exists mk_PrimitiveType(p):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_PrimitiveType(p))) or (exists mk_VecType(range, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_VecType(range, tpe)))) or (exists mk_StrucType(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_StrucType(tps)))) or (exists mk_FlavouredType(fl, tpe):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_FlavouredType(fl, tpe)))) or (exists mk_UnionTp(tps):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_UnionTp(tps)))) or (exists mk_TypeName(id):(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) \u0026 (tp \u003d mk_TypeName(id)))))","legal function application obligation:(forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 (is_(pt, Number) \u003d\u003e pre_(eval_Number(pt)e)))","legal function application obligation:(forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e (is_(pt, FloatType) \u003d\u003e pre_(eval_FloatType(pt)e))))","legal function application obligation:(forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e ((not is_(pt, FloatType)) \u003d\u003e pre_(eval_VoidValType(pt)e))))","type compatibility obligation:(forall mk_PrimitiveType(pt):PrimitiveType, e:Env \u0026 ((not is_(pt, Number)) \u003d\u003e ((not is_(pt, FloatType)) \u003d\u003e is_(pt, Flavouring))))","legal function application obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 (forall r in set (elems range) \u0026 pre_(eval_Range(r)e)))","enumeration map injectivity obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))))","legal map application obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e let m:map (nat) to (bool) \u003d {0 |-\u003e false, 1 |-\u003e true} in (forall v in set (dunion ranges) \u0026 (v in set (dom m)))))))","type compatibility obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e let m:map (nat) to (bool) \u003d {0 |-\u003e false, 1 |-\u003e true} in (forall v in set (dunion ranges) \u0026 (v \u003e\u003d 0))))))","type compatibility obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e is_((dunion ranges), set of (int)))))))","type compatibility obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation:(forall mk_Number(rep, range):Number, e:Env \u0026 let ranges:set of ((Errvalue | set of (int))) \u003d {eval_Range(r)(e) | r in set (elems range)} in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e is_((dunion ranges), set of (int)))))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((lower \u003c\u003e nil) \u003d\u003e pre_(eval_CompileTimeValue(lower)e))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((lower \u003c\u003e nil) \u003d\u003e is_(lower, CompileTimeValue))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((not ((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int)))) \u003d\u003e ((upper \u003c\u003e nil) \u003d\u003e pre_(eval_CompileTimeValue(upper)e)))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not ((lower \u003d nil) and (upper \u003d nil))) \u003d\u003e ((not ((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int)))) \u003d\u003e ((upper \u003c\u003e nil) \u003d\u003e is_(upper, CompileTimeValue)))))","finite set obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((0 \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x))))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e is_(((eval_CompileTimeValue(upper)(e).val).val), real))))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e pre_(eval_CompileTimeValue(upper)e))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((lower \u003d nil) \u003d\u003e (forall x:int \u0026 ((0 \u003c\u003d x) \u003d\u003e is_(upper, CompileTimeValue))))))","finite set obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d maxint)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x)))))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 is_(((eval_CompileTimeValue(lower)(e).val).val), real))))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 pre_(eval_CompileTimeValue(lower)e))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((upper \u003d nil) \u003d\u003e (forall x:int \u0026 is_(lower, CompileTimeValue))))))","finite set obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (exists finmap1:map (nat) to (int) \u0026 (forall x:int \u0026 (((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) and (x \u003c\u003d ((eval_CompileTimeValue(upper)(e).val).val))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x)))))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 is_(((eval_CompileTimeValue(lower)(e).val).val), real))))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 pre_(eval_CompileTimeValue(lower)e))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 is_(lower, CompileTimeValue))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e is_(((eval_CompileTimeValue(upper)(e).val).val), real)))))))","legal function application obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e pre_(eval_CompileTimeValue(upper)e)))))))","type compatibility obligation:(forall mk_Range(lower, upper):Range, e:Env \u0026 ((not (((lower \u003d nil) and (upper \u003d nil)) or (((lower \u003c\u003e nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper \u003c\u003e nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))) \u003d\u003e ((not (lower \u003d nil)) \u003d\u003e ((not (upper \u003d nil)) \u003d\u003e (forall x:int \u0026 ((((eval_CompileTimeValue(lower)(e).val).val) \u003c\u003d x) \u003d\u003e is_(upper, CompileTimeValue)))))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not ((abserr \u003d nil) and (relerr \u003d nil))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (abserr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(abserr)e))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (abserr \u003d nil)) \u003d\u003e is_(abserr, CompileTimeValue))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (relerr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(relerr)e))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e ((not (relerr \u003d nil)) \u003d\u003e is_(relerr, CompileTimeValue))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_min(eval_Range(range)(e))))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(eval_Range(range)(e), set of (real))))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e)))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_max(eval_Range(range)(e))))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(eval_Range(range)(e), set of (real))))))","legal function application obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 pre_(eval_Range(range)e)))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(min(eval_Range(range)(e)), int)))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e (forall range in set (elems ranges) \u0026 is_(max(eval_Range(range)(e)), int)))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e is_((abse.val), real))))","type compatibility obligation:(forall mk_FloatType(ranges, abserr, relerr):FloatType, e:Env \u0026 ((not (((abserr \u003d nil) and (relerr \u003d nil)) or (exists range in set (elems ranges) \u0026 (eval_Range(range)(e) \u003d \u003cerr\u003e)))) \u003d\u003e let abse:(Expressible_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(abserr)(e).val)), rele:(Expressible_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))\nelse (eval_CompileTimeValue(relerr)(e).val)) in ((not (not (is_(abse, Real) and is_(rele, Real)))) \u003d\u003e is_((rele.val), real))))","legal function application obligation:(forall mk_StrucType(tps):StrucType, e:Env \u0026 (forall i in set (inds tps) \u0026 pre_(eval_Type(tps(i))e)))","legal sequence application obligation:(forall mk_StrucType(tps):StrucType, e:Env \u0026 (forall i in set (inds tps) \u0026 (i in set (inds tps))))","type compatibility obligation:(forall mk_StrucType(tps):StrucType, e:Env \u0026 let typs:seq of ((Errvalue | Expressible_type)) \u003d [eval_Type(tps(i))(e) | i in set (inds tps)] in ((not (exists tp in set (elems typs) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))) \u003d\u003e ((not (exists tp1, tp2 in set (elems typs) \u0026 ((tp1 \u003c\u003e tp2) and ((tp1.fl) \u003d (tp2.fl))))) \u003d\u003e is_(typs, seq1 of (CompType)))))","legal function application obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 pre_(eval_Type(tp)e)))","legal function application obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 pre_(eval_Range(range)e)))","legal function application obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_min(nrange))))","type compatibility obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real)))))","legal function application obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_max(nrange))))","type compatibility obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real)))))","type compatibility obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(min(nrange), int))))","type compatibility obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(max(nrange), int))))","type compatibility obligation:(forall mk_VecType(range, tp):VecType \u0026 (forall e:(unresolved DEFAULT`Env) \u0026 let typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e), nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not ((typ \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e ((((((is_(typ, Float) or is_(typ, IntType)) or is_(typ, StructureType)) or is_(typ, TrType)) or is_(typ, UnionType)) or is_(typ, VectorType)) or is_(typ, VoidType)))))","legal function application obligation:(forall mk_FlavouredType(fl, tp):FlavouredType, e:Env \u0026 pre_(eval_Type(tp)e))","cases exhaustive obligation:(forall mk_FlavouredType(fl, tp):FlavouredType, e:Env \u0026 let flavour:Flavdom \u003d eval_Flavouring(fl), typ:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (typ \u003d \u003cerr\u003e)) \u003d\u003e (((((((exists mk_VoidType(t):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_VoidType(t))) or (exists mk_TrType(range, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_TrType(range, fl)))) or (exists mk_IntType(rep, range, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(range, abse, rele, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_Float(range, abse, rele, fl)))) or (exists mk_VectorType(lower, upper, tp, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_VectorType(lower, upper, tp, fl)))) or (exists mk_StructureType(tps, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_StructureType(tps, fl)))) or (exists mk_UnionType(tps, fl):(Errvalue | Expressible_type) \u0026 (typ \u003d mk_UnionType(tps, fl))))))","legal function application obligation:(forall mk_UnionTp(tps):UnionTp, e:Env \u0026 (forall i in set (inds tps) \u0026 pre_(eval_Type(tps(i))e)))","legal sequence application obligation:(forall mk_UnionTp(tps):UnionTp, e:Env \u0026 (forall i in set (inds tps) \u0026 (i in set (inds tps))))","type compatibility obligation:(forall mk_UnionTp(tps):UnionTp, e:Env \u0026 let typs:set of ((Errvalue | Expressible_type)) \u003d {eval_Type(tps(i))(e) | i in set (inds tps)} in ((not (exists tp in set typs \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))) \u003d\u003e ((not (exists t1, t2 in set typs \u0026 fleq(t1, t2))) \u003d\u003e is_(typs, set of ((Float | IntType | TrType | VoidType))))))","cases exhaustive obligation:(forall mk_TypeName(id):TypeName, mk_(m, l):Env \u0026 ((id in set (dom m)) \u003d\u003e (((((exists mk_Location(l):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Location(l))) or (exists mk_Storable_value(v):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Storable_value(v)))) or (exists mk_Proc(p):Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d mk_Proc(p)))) or (access_env(id)(mk_(m, l)) \u003d \u003cerr\u003e)) or (exists t:Denotable_value \u0026 (access_env(id)(mk_(m, l)) \u003d t)))))","type compatibility obligation:(forall mk_TypeName(id):TypeName, mk_(m, l):Env \u0026 (is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Errvalue) or (is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Expressible_type) and ((((((is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), Float) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), IntType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), StructureType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), TrType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), UnionType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), VectorType)) or is_((if (id in set (dom m))\nthen (cases access_env(id)(mk_(m, l)) :\nmk_Location(l) -\u003e \u003cerr\u003e,\nmk_Storable_value(v) -\u003e \u003cerr\u003e,\nmk_Proc(p) -\u003e \u003cerr\u003e,\n\u003cerr\u003e -\u003e \u003cerr\u003e,\nt -\u003e t\n end)\nelse \u003cerr\u003e), VoidType)))))","legal function application obligation:(forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 (is_(s, SimpleScope) \u003d\u003e pre_(eval_SimpleScope(s)(e)ps)))","legal function application obligation:(forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 (is_(s, SimpleScope) \u003d\u003e pre_(eval_SimpleScope(s)e)))","legal function application obligation:(forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e pre_(eval_PackageScope(s)(e)ps)))","legal function application obligation:(forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e pre_(eval_PackageScope(s)e)))","type compatibility obligation:(forall mk_Scope(s):Scope, e:Env, ps:PState \u0026 ((not is_(s, SimpleScope)) \u003d\u003e is_(s, PackageScope)))","legal function application obligation:(forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in pre_(eval_Decls(decls)old_env_st))","value binding obligation:(forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(new_env, new_sto):EnvState \u0026 (mk_(new_env, new_sto) \u003d new_env_st))))","type compatibility obligation:(forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(new_env_st, (Env * PState))))","legal function application obligation:(forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(new_env, new_sto):EnvState \u003d new_env_st in pre_(eval_Expression(expr)(new_env)new_sto)))","legal function application obligation:(forall mk_SimpleScope(decls, expr):SimpleScope, e:Env, ps:PState \u0026 let old_env_st:(Env * PState) \u003d mk_(e, ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(old_env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(new_env, new_sto):EnvState \u003d new_env_st in pre_(eval_Expression(expr)new_env)))","legal function application obligation:(forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e pre_(eval_Decls((tl decls))eval_Declaration((hd decls))(env_st)))))","non-empty sequence obligation:(forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e (decls \u003c\u003e []))))","legal function application obligation:(forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e pre_(eval_Declaration((hd decls))env_st))))","non-empty sequence obligation:(forall decls:seq of (Declaration), env_st:EnvState \u0026 ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e ((not (decls \u003d [])) \u003d\u003e (decls \u003c\u003e []))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 (exists mk_ImportDecl(id, tp):Declaration \u0026 ((mk_ImportDecl(id, tp) \u003d decl) \u003d\u003e let mk_ImportDecl(id, tp) \u003d decl in pre_(eval_ImportDecl(decl)env_st))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 (exists mk_ImportDecl(id, tp):Declaration \u0026 ((mk_ImportDecl(id, tp) \u003d decl) \u003d\u003e let mk_ImportDecl(id, tp) \u003d decl in is_(decl, ImportDecl))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e (exists mk_ExportDecl(id, expr):Declaration \u0026 ((mk_ExportDecl(id, expr) \u003d decl) \u003d\u003e let mk_ExportDecl(id, expr) \u003d decl in pre_(eval_ExportDecl(decl)env_st)))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e (exists mk_ExportDecl(id, expr):Declaration \u0026 ((mk_ExportDecl(id, expr) \u003d decl) \u003d\u003e let mk_ExportDecl(id, expr) \u003d decl in is_(decl, ExportDecl)))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_LetDecl(l):Declaration \u0026 ((mk_LetDecl(l) \u003d decl) \u003d\u003e let mk_LetDecl(l) \u003d decl in pre_(eval_LetDecl(decl)env_st))))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_LetDecl(l):Declaration \u0026 ((mk_LetDecl(l) \u003d decl) \u003d\u003e let mk_LetDecl(l) \u003d decl in is_(decl, LetDecl))))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e (exists mk_VarDecl(id, expr):Declaration \u0026 ((mk_VarDecl(id, expr) \u003d decl) \u003d\u003e let mk_VarDecl(id, expr) \u003d decl in pre_(eval_VarDecl(decl)env_st)))))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e (exists mk_VarDecl(id, expr):Declaration \u0026 ((mk_VarDecl(id, expr) \u003d decl) \u003d\u003e let mk_VarDecl(id, expr) \u003d decl in is_(decl, VarDecl)))))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 ((mk_ProcDec(nls, ph, expr) \u003d decl) \u003d\u003e let mk_ProcDec(nls, ph, expr) \u003d decl in pre_(eval_ProcDec(decl)env_st))))))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 ((mk_ProcDec(nls, ph, expr) \u003d decl) \u003d\u003e let mk_ProcDec(nls, ph, expr) \u003d decl in is_(decl, ProcDec))))))))","legal function application obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (mk_ProcDec(nls, ph, expr) \u003d decl))) \u003d\u003e (exists mk_TypeDec(id, type):Declaration \u0026 ((mk_TypeDec(id, type) \u003d decl) \u003d\u003e let mk_TypeDec(id, type) \u003d decl in pre_(eval_TypeDec(decl)env_st)))))))))","type compatibility obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((not (exists mk_ImportDecl(id, tp):Declaration \u0026 (mk_ImportDecl(id, tp) \u003d decl))) \u003d\u003e ((not (exists mk_ExportDecl(id, expr):Declaration \u0026 (mk_ExportDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_LetDecl(l):Declaration \u0026 (mk_LetDecl(l) \u003d decl))) \u003d\u003e ((not (exists mk_VarDecl(id, expr):Declaration \u0026 (mk_VarDecl(id, expr) \u003d decl))) \u003d\u003e ((not (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (mk_ProcDec(nls, ph, expr) \u003d decl))) \u003d\u003e (exists mk_TypeDec(id, type):Declaration \u0026 ((mk_TypeDec(id, type) \u003d decl) \u003d\u003e let mk_TypeDec(id, type) \u003d decl in is_(decl, TypeDec)))))))))","cases exhaustive obligation:(forall decl:Declaration, env_st:EnvState \u0026 ((((((exists mk_ImportDecl(id, tp):Declaration \u0026 (decl \u003d mk_ImportDecl(id, tp))) or (exists mk_ExportDecl(id, expr):Declaration \u0026 (decl \u003d mk_ExportDecl(id, expr)))) or (exists mk_LetDecl(l):Declaration \u0026 (decl \u003d mk_LetDecl(l)))) or (exists mk_VarDecl(id, expr):Declaration \u0026 (decl \u003d mk_VarDecl(id, expr)))) or (exists mk_ProcDec(nls, ph, expr):Declaration \u0026 (decl \u003d mk_ProcDec(nls, ph, expr)))) or (exists mk_TypeDec(id, type):Declaration \u0026 (decl \u003d mk_TypeDec(id, type)))))","legal function application obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Type(tp)e))","type compatibility obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value(val))(ps.sto))))","legal function application obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value(val))))","type compatibility obligation:(forall mk_ImportDecl(id, tp):ImportDecl, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let val:Expressible_value \u003d choose(type), mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_(val, Int) or is_(val, Real)) or is_(val, Structure)) or is_(val, Tr)) or is_(val, Union)) or is_(val, Vector)) or is_(val, Void))))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value((x.val)))(ps.sto))))","legal function application obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value((x.val)))))","type compatibility obligation:(forall mk_ExportDecl(id, expr):ExportDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_((x.val), Int) or is_((x.val), Real)) or is_((x.val), Structure)) or is_((x.val), Tr)) or is_((x.val), Union)) or is_((x.val), Vector)) or is_((x.val), Void))))","legal function application obligation:(forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 (is_(decl, SimpleLetDecl) \u003d\u003e pre_(eval_SimpleLetDecl(decl)es)))","legal function application obligation:(forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 ((not is_(decl, SimpleLetDecl)) \u003d\u003e pre_(eval_StrucLetDecl(decl)es)))","type compatibility obligation:(forall mk_LetDecl(decl):LetDecl, es:EnvState \u0026 ((not is_(decl, SimpleLetDecl)) \u003d\u003e is_(decl, StrucLetDecl)))","legal function application obligation:(forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)((x.val))e)))","legal function application obligation:(forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)(x.val))))","type compatibility obligation:(forall mk_SimpleLetDecl(id, expr):SimpleLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e is_((x.val), Errvalue)))","legal function application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal sequence application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds ids))))))","type compatibility obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (is_(((x.val).val)(i), bool) or is_(((x.val).val)(i), real))))))","legal sequence application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds ((x.val).val)))))))","legal sequence application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ids) \u0026 (i in set (inds (((x.val).type).tps)))))))","legal function application obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let id_vals:seq of ((Id * Expressible_value)) \u003d [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in pre_(multi_update_env(id_vals)e))))","type compatibility obligation:(forall mk_StrucLetDecl(ids, expr):StrucLetDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ids) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let id_vals:seq of ((Id * Expressible_value)) \u003d [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in is_(id_vals, seq of ((Id * Denotable_value))))))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)(l)n_e)))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update_env(id)l)))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)(mk_Storable_value((x.val)))(ps.sto))))","legal function application obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in pre_(update(l)mk_Storable_value((x.val)))))","type compatibility obligation:(forall mk_VarDecl(id, expr):VarDecl, mk_(e, ps):EnvState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let mk_(l, n_e):(Location * Env) \u003d reserve_locn(e) in ((((((is_((x.val), Int) or is_((x.val), Real)) or is_((x.val), Structure)) or is_((x.val), Tr)) or is_((x.val), Union)) or is_((x.val), Vector)) or is_((x.val), Void))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 pre_(eval_NonLocals(nls)(e)ps))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 pre_(eval_NonLocals(nls)e))","type compatibility obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 is_(nls, NonLocals))","value binding obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, ns):EnvState \u0026 (mk_(ne, ns) \u003d env_st))))","type compatibility obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(env_st, (Env * PState))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in pre_(eval_Formals(formals)e)))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 pre_(instantiate_formals(fls)(a)ne))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 pre_(instantiate_formals(fls)a))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Expression(expr)(nn_e)nps))))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Expression(expr)nn_e))))))","type compatibility obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in (forall a:(unresolved DEFAULT`Param) \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (forall nps:(unresolved DEFAULT`PState) \u0026 ((not (nn_e \u003d \u003cerr\u003e)) \u003d\u003e is_(nn_e, (map (Id) to (Denotable_value) * Location)))))))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in let pr:Proc \u003d mk_Proc((lambda [a:(unresolved DEFAULT`Param)] \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (lambda [nps:(unresolved DEFAULT`PState)] \u0026 (if (nn_e \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(nn_e)(nps) in (if (((x.val) \u003c\u003e \u003cerr\u003e) and ((is_((x.val), Void) and (((x.val).type) \u003d mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) \u003d {Phi}))))\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse x))))) in pre_(update_env(id)(pr)e)))","legal function application obligation:(forall mk_ProcDec(nls, ph, expr):ProcDec, mk_(e, ps):EnvState \u0026 let env_st:EnvState \u003d eval_NonLocals(nls)(e)(ps) in ((not (env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_ProcHeading(id, formals):ProcHeading \u003d ph, mk_(ne, ns):EnvState \u003d env_st in let fls:seq of (Formal_elt) \u003d eval_Formals(formals)(e) in let pr:Proc \u003d mk_Proc((lambda [a:(unresolved DEFAULT`Param)] \u0026 let nn_e:(Env | Errvalue) \u003d instantiate_formals(fls)(a)(ne) in (lambda [nps:(unresolved DEFAULT`PState)] \u0026 (if (nn_e \u003d \u003cerr\u003e)\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse let x:EST_value \u003d eval_Expression(expr)(nn_e)(nps) in (if (((x.val) \u003c\u003e \u003cerr\u003e) and ((is_((x.val), Void) and (((x.val).type) \u003d mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) \u003d {Phi}))))\nthen mk_EST_value(\u003cerr\u003e, (nps.sto), zerot)\nelse x))))) in pre_(update_env(id)pr)))","legal function application obligation:(forall mk_NonLocals(ids, decls):NonLocals, mk_(m, l):Env, ps:PState \u0026 let ids_map:(map (?) to (?) | map (Id) to (Denotable_value)) \u003d (if (ids \u003d nil)\nthen {|-\u003e}\nelse ((elems ids) \u003c: m)) in ((not (decls \u003d nil)) \u003d\u003e pre_(eval_Decls(decls)mk_(mk_(ids_map, l), ps))))","type compatibility obligation:(forall mk_NonLocals(ids, decls):NonLocals, mk_(m, l):Env, ps:PState \u0026 let ids_map:(map (?) to (?) | map (Id) to (Denotable_value)) \u003d (if (ids \u003d nil)\nthen {|-\u003e}\nelse ((elems ids) \u003c: m)) in ((not (decls \u003d nil)) \u003d\u003e is_(decls, seq of (Declaration))))","legal function application obligation:(forall fls:seq of (Formal), e:Env \u0026 (forall i in set (inds fls) \u0026 pre_(eval_Formal(fls(i))e)))","legal sequence application obligation:(forall fls:seq of (Formal), e:Env \u0026 (forall i in set (inds fls) \u0026 (i in set (inds fls))))","legal function application obligation:(forall mk_Formal(id, rep, fl):Formal, e:Env \u0026 pre_(eval_Representation(rep)e))","type compatibility obligation:(forall mk_Formal(id, rep, fl):Formal, e:Env \u0026 let n_rep:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), n_fl:Flavdom \u003d eval_Flavouring(fl) in ((((((is_(n_rep, Float) or is_(n_rep, IntType)) or is_(n_rep, StructureType)) or is_(n_rep, TrType)) or is_(n_rep, UnionType)) or is_(n_rep, VectorType)) or is_(n_rep, VoidType)))","legal function application obligation:(forall rep:Representation, e:Env \u0026 (exists mk_PrimitiveRep(p):Representation \u0026 ((mk_PrimitiveRep(p) \u003d rep) \u003d\u003e let mk_PrimitiveRep(p) \u003d rep in pre_(eval_PrimitiveRep(rep)e))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 (exists mk_PrimitiveRep(p):Representation \u0026 ((mk_PrimitiveRep(p) \u003d rep) \u003d\u003e let mk_PrimitiveRep(p) \u003d rep in is_(rep, PrimitiveRep))))","legal function application obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e (exists mk_StrucRep(rs):Representation \u0026 ((mk_StrucRep(rs) \u003d rep) \u003d\u003e let mk_StrucRep(rs) \u003d rep in pre_(eval_StrucRep(rep)e)))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e (exists mk_StrucRep(rs):Representation \u0026 ((mk_StrucRep(rs) \u003d rep) \u003d\u003e let mk_StrucRep(rs) \u003d rep in is_(rep, StrucRep)))))","legal function application obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e (exists mk_VecRep(range, r):Representation \u0026 ((mk_VecRep(range, r) \u003d rep) \u003d\u003e let mk_VecRep(range, r) \u003d rep in pre_(eval_VecRep(rep)e))))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e (exists mk_VecRep(range, r):Representation \u0026 ((mk_VecRep(range, r) \u003d rep) \u003d\u003e let mk_VecRep(range, r) \u003d rep in is_(rep, VecRep))))))","legal function application obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e (exists mk_UnionRep(rs):Representation \u0026 ((mk_UnionRep(rs) \u003d rep) \u003d\u003e let mk_UnionRep(rs) \u003d rep in pre_(eval_UnionRep(rep)e)))))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e (exists mk_UnionRep(rs):Representation \u0026 ((mk_UnionRep(rs) \u003d rep) \u003d\u003e let mk_UnionRep(rs) \u003d rep in is_(rep, UnionRep)))))))","legal function application obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e (exists mk_FlavouredRep(f, r):Representation \u0026 ((mk_FlavouredRep(f, r) \u003d rep) \u003d\u003e let mk_FlavouredRep(f, r) \u003d rep in pre_(eval_FlavouredRep(rep)e))))))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e (exists mk_FlavouredRep(f, r):Representation \u0026 ((mk_FlavouredRep(f, r) \u003d rep) \u003d\u003e let mk_FlavouredRep(f, r) \u003d rep in is_(rep, FlavouredRep))))))))","legal function application obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_FlavouredRep(f, r):Representation \u0026 (mk_FlavouredRep(f, r) \u003d rep))) \u003d\u003e (exists mk_Type(t):Representation \u0026 ((mk_Type(t) \u003d rep) \u003d\u003e let mk_Type(t) \u003d rep in pre_(eval_Type(rep)e)))))))))","type compatibility obligation:(forall rep:Representation, e:Env \u0026 ((not (exists mk_PrimitiveRep(p):Representation \u0026 (mk_PrimitiveRep(p) \u003d rep))) \u003d\u003e ((not (exists mk_StrucRep(rs):Representation \u0026 (mk_StrucRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_VecRep(range, r):Representation \u0026 (mk_VecRep(range, r) \u003d rep))) \u003d\u003e ((not (exists mk_UnionRep(rs):Representation \u0026 (mk_UnionRep(rs) \u003d rep))) \u003d\u003e ((not (exists mk_FlavouredRep(f, r):Representation \u0026 (mk_FlavouredRep(f, r) \u003d rep))) \u003d\u003e (exists mk_Type(t):Representation \u0026 ((mk_Type(t) \u003d rep) \u003d\u003e let mk_Type(t) \u003d rep in is_(rep, Type)))))))))","cases exhaustive obligation:(forall rep:Representation, e:Env \u0026 ((((((exists mk_PrimitiveRep(p):Representation \u0026 (rep \u003d mk_PrimitiveRep(p))) or (exists mk_StrucRep(rs):Representation \u0026 (rep \u003d mk_StrucRep(rs)))) or (exists mk_VecRep(range, r):Representation \u0026 (rep \u003d mk_VecRep(range, r)))) or (exists mk_UnionRep(rs):Representation \u0026 (rep \u003d mk_UnionRep(rs)))) or (exists mk_FlavouredRep(f, r):Representation \u0026 (rep \u003d mk_FlavouredRep(f, r)))) or (exists mk_Type(t):Representation \u0026 (rep \u003d mk_Type(t)))))","legal function application obligation:(forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 (is_(rep, NumRep) \u003d\u003e pre_(eval_NumRep(rep)e)))","legal function application obligation:(forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 ((not is_(rep, NumRep)) \u003d\u003e pre_(eval_FloatRep(rep)e)))","type compatibility obligation:(forall mk_PrimitiveRep(rep):PrimitiveRep, e:Env \u0026 ((not is_(rep, NumRep)) \u003d\u003e is_(rep, FloatRep)))","legal function application obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 ((not (range \u003d nil)) \u003d\u003e (forall r in set (elems range) \u0026 pre_(eval_Range(r)e))))","legal map application obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 (r in set (dom {0 |-\u003e false, 1 |-\u003e true}))))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 is_(r, nat)))))))","enumeration map injectivity obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((rep \u003d \u003cbit\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 (v not in set {0, 1}))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set (dunion ranges) \u0026 (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e (forall v in set (dunion ranges) \u0026 is_((abs v), real))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-bytemax, ... ,bytemax}\nelse (dunion ranges)) in (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((rep \u003d \u003cbyte\u003e) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e bytemax))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-bytemax, ... ,bytemax}\nelse (dunion ranges)) in is_(rngs, set of (int)))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-maxint, ... ,maxint}\nelse (dunion ranges)) in (is_(rep, \u003cbyte\u003e) or is_(rep, \u003cword\u003e)))))))","type compatibility obligation:(forall mk_NumRep(rep, range):NumRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}) in ((not (\u003cerr\u003e in set ranges)) \u003d\u003e ((not (rep \u003d \u003cbit\u003e)) \u003d\u003e ((not (rep \u003d \u003cbyte\u003e)) \u003d\u003e ((not (exists v in set (dunion ranges) \u0026 ((abs v) \u003e maxint))) \u003d\u003e let rngs:(? | Errvalue | set of (int)) \u003d (if (range \u003d nil)\nthen {-maxint, ... ,maxint}\nelse (dunion ranges)) in is_(rngs, set of (int)))))))","legal function application obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (range \u003d nil)) \u003d\u003e (forall r in set (elems range) \u0026 pre_(eval_Range(r)e))))","legal function application obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (abserr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(abserr)e)))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (abserr \u003d nil)) \u003d\u003e is_(abserr, CompileTimeValue)))","legal function application obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (relerr \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue(relerr)e)))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 ((not (relerr \u003d nil)) \u003d\u003e is_(relerr, CompileTimeValue)))","legal function application obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 pre_min(r)))))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(r, set of (real))))))","legal function application obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 pre_max(r)))))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(r, set of (real))))))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(min(r), int)))))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e ((not (range \u003d nil)) \u003d\u003e (forall r in set ranges \u0026 is_(max(r), int)))))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e let rngs:set of (Floatrng) \u003d (if (range \u003d nil)\nthen {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}\nelse {mk_Floatrng(min(r), max(r)) | r in set ranges}) in is_(((abse.val).val), real)))","type compatibility obligation:(forall mk_FloatRep(range, abserr, relerr):FloatRep, e:Env \u0026 let ranges:(set of ((Errvalue | set of (int))) | {}) \u003d (if (range \u003d nil)\nthen {}\nelse {eval_Range(r)(e) | r in set (elems range)}), abse:(EST_value | Real) \u003d (if (abserr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(abserr)(e)), rele:(EST_value | Real) \u003d (if (relerr \u003d nil)\nthen mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))\nelse eval_CompileTimeValue(relerr)(e)) in ((not ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (\u003cerr\u003e in set ranges))) \u003d\u003e let rngs:set of (Floatrng) \u003d (if (range \u003d nil)\nthen {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}\nelse {mk_Floatrng(min(r), max(r)) | r in set ranges}) in is_(((rele.val).val), real)))","legal function application obligation:(forall mk_StrucRep(reps):StrucRep, e:Env \u0026 (forall i in set (inds reps) \u0026 pre_(eval_Representation(reps(i))e)))","legal sequence application obligation:(forall mk_StrucRep(reps):StrucRep, e:Env \u0026 (forall i in set (inds reps) \u0026 (i in set (inds reps))))","type compatibility obligation:(forall mk_StrucRep(reps):StrucRep, e:Env \u0026 let tps:seq of ((Errvalue | Expressible_type)) \u003d [eval_Representation(reps(i))(e) | i in set (inds reps)] in ((not (exists tp in set (elems tps) \u0026 (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))) \u003d\u003e ((not (exists tp1, tp2 in set (elems tps) \u0026 fleq(tp1, tp2))) \u003d\u003e is_(tps, seq1 of (CompType)))))","legal function application obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 pre_(eval_Range(range)e))","legal function application obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 pre_(eval_Representation(rep)e))","legal function application obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_min(nrange)))","type compatibility obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real))))","legal function application obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e pre_max(nrange)))","type compatibility obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(nrange, set of (real))))","type compatibility obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(min(nrange), int)))","type compatibility obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e is_(max(nrange), int)))","type compatibility obligation:(forall mk_VecRep(range, rep):VecRep, e:Env \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e), type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e) in ((not ((type \u003d \u003cerr\u003e) or (nrange \u003d \u003cerr\u003e))) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation:(forall mk_UnionRep(reps):UnionRep, e:Env \u0026 (forall rep in set (elems reps) \u0026 pre_(eval_Representation(rep)e)))","type compatibility obligation:(forall mk_UnionRep(reps):UnionRep, e:Env \u0026 let tps:set of ((Errvalue | Expressible_type)) \u003d {eval_Representation(rep)(e) | rep in set (elems reps)} in ((not (exists tp in set tps \u0026 (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))) \u003d\u003e ((not (exists tp1, tp2 in set tps \u0026 fleq(tp1, tp2))) \u003d\u003e is_(tps, set of ((Float | IntType | TrType | VoidType))))))","legal function application obligation:(forall mk_FlavouredRep(fl, rep):FlavouredRep, e:Env \u0026 pre_(eval_Representation(rep)e))","type compatibility obligation:(forall mk_FlavouredRep(fl, rep):FlavouredRep, e:Env \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Representation(rep)(e), flav:Flavdom \u003d eval_Flavouring(fl) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))","legal function application obligation:(forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 pre_(eval_Type(tp)e))","legal function application obligation:(forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)(type)e)))","legal function application obligation:(forall mk_TypeDec(id, tp):TypeDec, mk_(e, ps):EnvState \u0026 let type:(Errvalue | Expressible_type) \u003d eval_Type(tp)(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e pre_(update_env(id)type)))","legal function application obligation:(forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in pre_(eval_Decls(decls)env_st))","value binding obligation:(forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(mk_(nm, nl), nps):EnvState \u0026 (mk_(mk_(nm, nl), nps) \u003d new_env_st))))","type compatibility obligation:(forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e is_(new_env_st, (Env * PState))))","legal function application obligation:(forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(mk_(nm, nl), nps):EnvState \u003d new_env_st in ((not (not ((elems ids) subset ((dom nm) \\ (dom m))))) \u003d\u003e let ne:(map (Id) to (Denotable_value) * Location) \u003d mk_((((elems ids) union (dom m)) \u003c: nm), nl) in pre_(eval_Expression(expr)(ne)nps))))","legal function application obligation:(forall mk_PackageScope(ids, decls, expr):PackageScope, mk_(m, l):Env, ps:PState \u0026 let env_st:((map (Id) to (Denotable_value) * Location) * PState) \u003d mk_(mk_(m, l), ps) in let new_env_st:EnvState \u003d eval_Decls(decls)(env_st) in ((not (new_env_st \u003d \u003cerr\u003e)) \u003d\u003e let mk_(mk_(nm, nl), nps):EnvState \u003d new_env_st in ((not (not ((elems ids) subset ((dom nm) \\ (dom m))))) \u003d\u003e let ne:(map (Id) to (Denotable_value) * Location) \u003d mk_((((elems ids) union (dom m)) \u003c: nm), nl) in pre_(eval_Expression(expr)ne))))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)(true)(e)ps))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)(true)e))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 pre_(eval_GuardedDeclarations(decls)true))","value binding obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u0026 (mk_(ne, nps, val) \u003d g_decl))))","type compatibility obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e is_(g_decl, (Env * PState * bool))))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(incl)(ne)nps)))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(incl)ne)))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(outcl)(ne)nps)))","legal function application obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in pre_(eval_Sequence(outcl)ne)))","type compatibility obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in let in_val:EST_value \u003d eval_Sequence(incl)(ne)(nps), out_val:EST_value \u003d eval_Sequence(outcl)(ne)(nps) in ((not (((in_val.val) \u003d \u003cerr\u003e) or ((out_val.val) \u003d \u003cerr\u003e))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((in_val.val).type), ((out_val.val).type)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e (val \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","type compatibility obligation:(forall mk_GuardedScope(decls, incl, outcl):GuardedScope, e:Env, ps:PState \u0026 let g_decl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDeclarations(decls)(true)(e)(ps) in ((not (g_decl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, val):((Env * PState * bool) | Errvalue) \u003d g_decl in let in_val:EST_value \u003d eval_Sequence(incl)(ne)(nps), out_val:EST_value \u003d eval_Sequence(outcl)(ne)(nps) in ((not (((in_val.val) \u003d \u003cerr\u003e) or ((out_val.val) \u003d \u003cerr\u003e))) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((in_val.val).type), ((out_val.val).type)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not val) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","legal function application obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 pre_(eval_GuardedDecl((hd decls))(e)ps))","legal function application obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 pre_(eval_GuardedDecl((hd decls))e))","value binding obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u0026 (mk_(ne, nps, tr) \u003d gdcl)))))","type compatibility obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e is_(gdcl, (Env * PState * bool)))))","legal function application obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))((b and tr))(ne)nps))))","legal function application obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))((b and tr))ne))))","legal function application obligation:(forall decls:seq1 of (GuardedDeclaration), b:bool, e:Env, ps:PState \u0026 let gdcl:((Env * PState * bool) | Errvalue) \u003d eval_GuardedDecl((hd decls))(e)(ps) in ((not ((len decls) \u003d 1)) \u003d\u003e ((not (gdcl \u003d \u003cerr\u003e)) \u003d\u003e let mk_(ne, nps, tr):((Env * PState * bool) | Errvalue) \u003d gdcl in pre_(eval_GuardedDeclarations((tl decls))(b and tr)))))","legal function application obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 (is_(decl, WhereDecl) \u003d\u003e pre_(eval_WhereDecl(decl)(e)ps)))","legal function application obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 (is_(decl, WhereDecl) \u003d\u003e pre_(eval_WhereDecl(decl)e)))","legal function application obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e pre_(eval_Declaration(decl)mk_(e, ps))))","type compatibility obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e (((((is_(decl, ExportDecl) or is_(decl, ImportDecl)) or is_(decl, LetDecl)) or is_(decl, ProcDec)) or is_(decl, TypeDec)) or is_(decl, VarDecl))))","value binding obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e let d:EnvState \u003d eval_Declaration(decl)(mk_(e, ps)) in ((not (d \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(ne, nps):EnvState \u0026 (mk_(ne, nps) \u003d d)))))","type compatibility obligation:(forall decl:GuardedDeclaration, e:Env, ps:PState \u0026 ((not is_(decl, WhereDecl)) \u003d\u003e let d:EnvState \u003d eval_Declaration(decl)(mk_(e, ps)) in ((not (d \u003d \u003cerr\u003e)) \u003d\u003e is_(d, (Env * PState)))))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(type)(((x.val).type))e)))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(type)((x.val).type))))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)((x.val))e)))))","legal function application obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)(x.val))))))","type compatibility obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e is_((x.val), Errvalue)))))","type compatibility obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e ((not (id \u003d nil)) \u003d\u003e is_(id, token)))))","type compatibility obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e let env:Env \u003d (if (id \u003d nil)\nthen e\nelse update_env(id)((x.val))(e)) in let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))))","type compatibility obligation:(forall mk_WhereDecl(type, expr, id):WhereDecl, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(type)(((x.val).type))(e) in ((not (\u003cerr\u003e \u003d t)) \u003d\u003e let env:Env \u003d (if (id \u003d nil)\nthen e\nelse update_env(id)((x.val))(e)) in let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(xt, Float) or is_(xt, IntType)) or is_(xt, StructureType)) or is_(xt, TrType)) or is_(xt, UnionType)) or is_(xt, VectorType)) or is_(xt, VoidType))))))","legal function application obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(tp)(((x.val).type))e)))","legal function application obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_SkeletonType(tp)((x.val).type))))","type compatibility obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e (tleq(type, ((x.val).type)) \u003d\u003e ((((((is_(xt, Float) or is_(xt, IntType)) or is_(xt, StructureType)) or is_(xt, TrType)) or is_(xt, UnionType)) or is_(xt, VectorType)) or is_(xt, VoidType)))))))","type compatibility obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e (tleq(type, ((x.val).type)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","type compatibility obligation:(forall mk_Assertion(expr, tp):Assertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tp)(((x.val).type))(e) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let xt:(Errvalue | Expressible_type) \u003d const_type((x.val)) in ((not (\u003cerr\u003e \u003d xt)) \u003d\u003e ((not (not (tleq(type, ((x.val).type)) and tleq(xt, type)))) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType)))))))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 (is_(cond, IfThenOnly) \u003d\u003e pre_(eval_IfThenOnly(cond)(e)ps)))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 (is_(cond, IfThenOnly) \u003d\u003e pre_(eval_IfThenOnly(cond)e)))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e (is_(cond, IfThenElse) \u003d\u003e pre_(eval_IfThenElse(cond)(e)ps))))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e (is_(cond, IfThenElse) \u003d\u003e pre_(eval_IfThenElse(cond)e))))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e pre_(eval_CaseExpr(cond)(e)ps))))","legal function application obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e pre_(eval_CaseExpr(cond)e))))","type compatibility obligation:(forall mk_Conditional(cond):Conditional, e:Env, ps:PState \u0026 ((not is_(cond, IfThenOnly)) \u003d\u003e ((not is_(cond, IfThenElse)) \u003d\u003e is_(cond, CaseExpr))))","legal function application obligation:(forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)(e)ps))","legal function application obligation:(forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)e))","legal function application obligation:(forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Sequence(action)(e)mu(ps, time |-\u003e tplus((cond.time), t_if))))","legal function application obligation:(forall mk_IfThenOnly(prop, action):IfThenOnly, e:Env, ps:PState \u0026 pre_(eval_Sequence(action)e))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)(e)ps))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 pre_(eval_Expression(prop)e))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(thenaction)(e)ps)))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(thenaction)e)))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(elseaction)(e)ps)))","legal function application obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e pre_(eval_Sequence(elseaction)e)))","type compatibility obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e let then_x:EST_value \u003d eval_Sequence(thenaction)(e)(ps), else_x:EST_value \u003d eval_Sequence(elseaction)(e)(ps) in let type:(Errvalue | Expressible_type) \u003d lub(((then_x.val).type), ((else_x.val).type)) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e (((cond.val).val) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation:(forall mk_IfThenElse(prop, thenaction, elseaction):IfThenElse, e:Env, ps:PState \u0026 let cond:EST_value \u003d eval_Expression(prop)(e)(ps) in ((not (not is_((cond.val), Tr))) \u003d\u003e let then_x:EST_value \u003d eval_Sequence(thenaction)(e)(ps), else_x:EST_value \u003d eval_Sequence(elseaction)(e)(ps) in let type:(Errvalue | Expressible_type) \u003d lub(((then_x.val).type), ((else_x.val).type)) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not ((cond.val).val)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)ps))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)((x.val))(e)mu(ps, time |-\u003e (x.time)))))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)((x.val))e)))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in pre_(eval_Limbs(limbs)(x.val))))","legal sequence application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e ((len ls) in set (inds ls)))))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in pre_(eval_Sequence(outlimb)(e)mu(ps, time |-\u003e (v.time))))))","legal function application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in pre_(eval_Sequence(outlimb)e))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in ((not (outlimb \u003d nil)) \u003d\u003e let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in is_(outlimb, Sequence))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e is_({((v.val).type) | mk_(t, v) in set (elems pats)}, set of (Expressible_type)))))))","legal sequence application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 (let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t) \u003d\u003e (i in set (inds pats))))))))))","legal sequence application obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 (i in set (inds pats)))))))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in (forall i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in ((((((is_(x_type, Float) or is_(x_type, IntType)) or is_(x_type, StructureType)) or is_(x_type, TrType)) or is_(x_type, UnionType)) or is_(x_type, VectorType)) or is_(x_type, VoidType)))))))))","non-empty sequence obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in (matches \u003c\u003e [])))))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in is_((mv.time), (nat * nat))))))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in (((((((is_((mv.val), Errvalue) or is_((mv.val), Int)) or is_((mv.val), Real)) or is_((mv.val), Structure)) or is_((mv.val), Tr)) or is_((mv.val), Union)) or is_((mv.val), Vector)) or is_((mv.val), Void))))))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))))","type compatibility obligation:(forall mk_CaseExpr(expr, limbs, outlimb):CaseExpr, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e let type_x:(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) \u003d ((x.val).type) in let ls:seq1 of ((Expressible_type * EST_value)) \u003d eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-\u003e (x.time))) in let os:([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) \u003d (if (outlimb \u003d nil)\nthen []\nelse let mk_(t, v):(Expressible_type * EST_value) \u003d ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-\u003e (v.time))))]) in let pats:seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d (ls ^ os) in ((not (exists mk_(t, v) in set (elems pats) \u0026 ((v.val) \u003d \u003cerr\u003e))) \u003d\u003e let patlub:(Errvalue | Expressible_type) \u003d setlub({t | mk_(t, v) in set (elems pats)}) in ((not (patlub \u003d \u003cerr\u003e)) \u003d\u003e ((not (lub(type_x, patlub) \u003c\u003e patlub)) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d setlub({((v.val).type) | mk_(t, v) in set (elems pats)}) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let x_type:(Errvalue | Expressible_type) \u003d const_type((x.val)) in let matches:seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) \u003d [pats(i) | i in set (inds pats) \u0026 let mk_(t, v):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d pats(i) in (lub(x_type, t) \u003d t)] in let mk_(mt, mv):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) \u003d (hd matches) in let time:Time \u003d dtplus([(mv.time), t_const_type, t_widen_type]) in is_((mv.sto), map (Location) to (Storable_value))))))))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))(x)(e)ps))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))(x)e))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Limb((hd limbs))x))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))(x)(e)mu(ps, time |-\u003e (v.time)))))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))(x)e)))","legal function application obligation:(forall limbs:seq1 of (CaseLimb), x:Expressible_value, e:Env, ps:PState \u0026 let mk_(t, v):(Expressible_type * EST_value) \u003d eval_Limb((hd limbs))(x)(e)(ps) in ((not ((len limbs) \u003d 1)) \u003d\u003e pre_(eval_Limbs((tl limbs))x)))","legal function application obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)(x)(e)ps))","legal function application obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)(x)e))","legal function application obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_Tester(test)x))","value binding obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u0026 (mk_(type, env, tm) \u003d t))))","type compatibility obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e is_(t, (Expressible_type * Env * Time))))","legal function application obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Sequence(sequ)(env)mu(ps, time |-\u003e tm))))","legal function application obligation:(forall mk_CaseLimb(test, sequ):CaseLimb, x:Expressible_value, e:Env, ps:PState \u0026 let t:((Expressible_type * Env * Time) | Errvalue) \u003d eval_Tester(test)(x)(e)(ps) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(type, env, tm):((Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Sequence(sequ)env)))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in pre_(eval_SkeletonType(tester)((x.type))e))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in pre_(eval_SkeletonType(tester)(x.type)))))","type compatibility obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (exists mk_SkeletonType(t):Tester \u0026 ((mk_SkeletonType(t) \u003d tester) \u003d\u003e let mk_SkeletonType(t) \u003d tester in is_(tester, SkeletonType))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)(x)(e)ps)))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)(x)e)))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in pre_(eval_StrucTest(tester)x)))))","type compatibility obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e (exists mk_StrucTest(s):Tester \u0026 ((mk_StrucTest(s) \u003d tester) \u003d\u003e let mk_StrucTest(s) \u003d tester in is_(tester, StrucTest)))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)(x)(e)ps))))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)(x)e))))))","legal function application obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in pre_(eval_NonStrucTest(tester)x))))))","type compatibility obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 ((not (exists mk_SkeletonType(t):Tester \u0026 (mk_SkeletonType(t) \u003d tester))) \u003d\u003e ((not (exists mk_StrucTest(s):Tester \u0026 (mk_StrucTest(s) \u003d tester))) \u003d\u003e (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 ((mk_NonStrucTest(id, tp, fl) \u003d tester) \u003d\u003e let mk_NonStrucTest(id, tp, fl) \u003d tester in is_(tester, NonStrucTest))))))","cases exhaustive obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (((exists mk_SkeletonType(t):Tester \u0026 (tester \u003d mk_SkeletonType(t))) or (exists mk_StrucTest(s):Tester \u0026 (tester \u003d mk_StrucTest(s)))) or (exists mk_NonStrucTest(id, tp, fl):Tester \u0026 (tester \u003d mk_NonStrucTest(id, tp, fl)))))","type compatibility obligation:(forall tester:Tester, x:Expressible_value, e:Env, ps:PState \u0026 (is_((cases tester :\nmk_SkeletonType(t) -\u003e let nt:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tester)((x.type))(e) in (if (nt \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(nt, e, (ps.time))),\nmk_StrucTest(s) -\u003e eval_StrucTest(tester)(x)(e)(ps),\nmk_NonStrucTest(id, tp, fl) -\u003e eval_NonStrucTest(tester)(x)(e)(ps)\n end), (Expressible_type * Env * Time)) or is_((cases tester :\nmk_SkeletonType(t) -\u003e let nt:(Errvalue | Expressible_type) \u003d eval_SkeletonType(tester)((x.type))(e) in (if (nt \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(nt, e, (ps.time))),\nmk_StrucTest(s) -\u003e eval_StrucTest(tester)(x)(e)(ps),\nmk_NonStrucTest(id, tp, fl) -\u003e eval_NonStrucTest(tester)(x)(e)(ps)\n end), Errvalue)))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_Type(t) \u003d skel) \u003d\u003e let mk_Type(t) \u003d skel in pre_(eval_Type(skel)e))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_Type(t) \u003d skel) \u003d\u003e let mk_Type(t) \u003d skel in is_(skel, Type))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in pre_(eval_NumSkel(skel)(t)e)))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in pre_(eval_NumSkel(skel)t)))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_NumSkel(r, er) \u003d skel) \u003d\u003e let mk_NumSkel(r, er) \u003d skel in is_(skel, NumSkel)))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in pre_(eval_StrucSkel(skel)(t)e))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in pre_(eval_StrucSkel(skel)t))))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_StrucSkel(s) \u003d skel) \u003d\u003e let mk_StrucSkel(s) \u003d skel in is_(skel, StrucSkel))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in pre_(eval_FlavSkel(skel)(t)e)))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in pre_(eval_FlavSkel(skel)t)))))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_FlavSkel(s, fl) \u003d skel) \u003d\u003e let mk_FlavSkel(s, fl) \u003d skel in is_(skel, FlavSkel)))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in pre_(eval_VecSkel(skel)(t)e))))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in pre_(eval_VecSkel(skel)t))))))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_VecSkel(s) \u003d skel) \u003d\u003e let mk_VecSkel(s) \u003d skel in is_(skel, VecSkel))))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in pre_(eval_UnionSkel(skel)(t)e)))))))))","legal function application obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in pre_(eval_UnionSkel(skel)t)))))))))","type compatibility obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((not (exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_Type(t) \u003d skel))) \u003d\u003e ((not (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_NumSkel(r, er) \u003d skel))) \u003d\u003e ((not (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_StrucSkel(s) \u003d skel))) \u003d\u003e ((not (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_FlavSkel(s, fl) \u003d skel))) \u003d\u003e ((not (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (mk_VecSkel(s) \u003d skel))) \u003d\u003e (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 ((mk_UnionSkel(s) \u003d skel) \u003d\u003e let mk_UnionSkel(s) \u003d skel in is_(skel, UnionSkel)))))))))","cases exhaustive obligation:(forall mk_SkeletonType(skel):SkeletonType, t:Expressible_type, e:Env \u0026 ((((((exists mk_Type(t):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_Type(t))) or (exists mk_NumSkel(r, er):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_NumSkel(r, er)))) or (exists mk_StrucSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_StrucSkel(s)))) or (exists mk_FlavSkel(s, fl):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_FlavSkel(s, fl)))) or (exists mk_VecSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_VecSkel(s)))) or (exists mk_UnionSkel(s):(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) \u0026 (skel \u003d mk_UnionSkel(s)))))","legal function application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e ((not (ranges \u003d nil)) \u003d\u003e (forall r in set (elems ranges) \u0026 pre_(eval_Range(r)e)))))","legal map application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 (v in set (dom {0 |-\u003e false, 1 |-\u003e true})))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_(v, nat))))))))","enumeration map injectivity obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (exists mk_TrType(range, fl):Expressible_type \u0026 ((mk_TrType(range, fl) \u003d x_type) \u003d\u003e let mk_TrType(range, fl) \u003d x_type in ((not (not ((dunion rngs) subset {0, 1}))) \u003d\u003e (forall v in set (dunion rngs) \u0026 (forall m1, m2 in set {{0 |-\u003e false}, {1 |-\u003e true}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((rep \u003d \u003cbyte\u003e) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((not ((rep \u003d \u003cbyte\u003e) and (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d bytemax)))) \u003d\u003e (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e (exists mk_IntType(rep, range, fl):Expressible_type \u0026 ((mk_IntType(rep, range, fl) \u003d x_type) \u003d\u003e let mk_IntType(rep, range, fl) \u003d x_type in ((not (((rep \u003d \u003cbyte\u003e) and (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d bytemax))) or (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint)))) \u003d\u003e is_((dunion rngs), set of (int)))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in (forall v in set (dunion rngs) \u0026 is_((abs v), real)))))))))","legal function application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.abserr) \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue((errors.abserr))e))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.abserr) \u003d nil)) \u003d\u003e is_((errors.abserr), CompileTimeValue))))))))))","legal function application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.relerr) \u003d nil)) \u003d\u003e pre_(eval_CompileTimeValue((errors.relerr))e))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e ((not ((errors.relerr) \u003d nil)) \u003d\u003e is_((errors.relerr), CompileTimeValue))))))))))","legal function application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 pre_min(r)))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(r, set of (real))))))))))))","legal function application obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 pre_max(r)))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(r, set of (real))))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(min(r), int)))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e (forall r in set rngs \u0026 is_(max(r), int)))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e is_(abserr, real))))))))))","type compatibility obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e ((not (exists mk_TrType(range, fl):Expressible_type \u0026 (mk_TrType(range, fl) \u003d x_type))) \u003d\u003e ((not (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (mk_IntType(rep, range, fl) \u003d x_type))) \u003d\u003e (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 ((mk_Float(rs, abse, rele, fl) \u003d x_type) \u003d\u003e let mk_Float(rs, abse, rele, fl) \u003d x_type in ((not (exists v in set (dunion rngs) \u0026 ((abs v) \u003e\u003d maxint))) \u003d\u003e let abserr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.abserr) \u003d nil)\nthen abse\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))), relerr:(\u003cerr\u003e | \u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real) \u003d (if ((errors.relerr) \u003d nil)\nthen rele\nelse let v1:Expressible_value \u003d (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse (v1.val))) in ((not (not (is_(abserr, real) and is_(relerr, real)))) \u003d\u003e is_(relerr, real))))))))))","cases exhaustive obligation:(forall mk_NumSkel(ranges, errors):NumSkel, x_type:Expressible_type, e:Env \u0026 ((not (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))) \u003d\u003e let rngs:(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) \u003d (if (ranges \u003d nil)\nthen (if is_(x_type, Float)\nthen {{l, ... ,u} | mk_Floatrng(l, u) in set (x_type.range)}\nelse {(x_type.range)})\nelse {eval_Range(r)(e) | r in set (elems ranges)}) in ((not (\u003cerr\u003e in set rngs)) \u003d\u003e (((exists mk_TrType(range, fl):Expressible_type \u0026 (x_type \u003d mk_TrType(range, fl))) or (exists mk_IntType(rep, range, fl):Expressible_type \u0026 (x_type \u003d mk_IntType(rep, range, fl)))) or (exists mk_Float(rs, abse, rele, fl):Expressible_type \u0026 (x_type \u003d mk_Float(rs, abse, rele, fl)))))))","legal sequence application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 (i in set (inds comps))))))","legal sequence application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((comps(i) \u003d \u003cnil\u003e) \u003d\u003e (i in set (inds (x_type.tps))))))))","legal function application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_SkeletonType(comps(i))((x_type.tps)(i))e))))))","legal function application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_SkeletonType(comps(i))(x_type.tps)(i)))))))","type compatibility obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e is_(comps(i), SkeletonType))))))","legal sequence application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e (i in set (inds comps)))))))","legal sequence application obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e (forall i in set (inds comps) \u0026 ((not (comps(i) \u003d \u003cnil\u003e)) \u003d\u003e (i in set (inds (x_type.tps))))))))","type compatibility obligation:(forall mk_StrucSkel(comps):StrucSkel, x_type:Expressible_type, e:Env \u0026 ((not (not is_(x_type, StructureType))) \u003d\u003e ((not (struc_length(x_type) \u003c\u003e (len comps))) \u003d\u003e let t:seq of ((CompType | Errvalue | Expressible_type)) \u003d [(if (comps(i) \u003d \u003cnil\u003e)\nthen (x_type.tps)(i)\nelse eval_SkeletonType(comps(i))((x_type.tps)(i))(e)) | i in set (inds comps)] in ((not (exists tp in set (elems t) \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or is_(tp, Float)))))) \u003d\u003e is_(t, seq1 of (CompType))))))","legal function application obligation:(forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)(x_type)e))","legal function application obligation:(forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)x_type))","type compatibility obligation:(forall mk_FlavSkel(skel, fl):FlavSkel, x_type:Expressible_type, e:Env \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e), f:Flavdom \u003d eval_Flavouring(fl) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))","legal function application obligation:(forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)(x_type)e))","legal function application obligation:(forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 pre_(eval_SkeletonType(skel)x_type))","type compatibility obligation:(forall mk_VecSkel(skel):VecSkel, x_type:Expressible_type, e:Env \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)(x_type)(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_VectorType(l, u, tp, fl):Expressible_type \u0026 ((mk_VectorType(l, u, tp, fl) \u003d x_type) \u003d\u003e let mk_VectorType(l, u, tp, fl) \u003d x_type in ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType))))))","comprehension map injectivity obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (forall m1, m2 in set {{skel |-\u003e fl} | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","finite map obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (exists finmap1:map (nat) to (map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom)) \u0026 (forall skel in set (elems skels), fl:Flavdom \u0026 ((fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d {skel |-\u003e fl}))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 (forall skel in set (elems skels), fl:Flavdom \u0026 ((not (exists mk_FlavSkel(skel, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(skel, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))","comprehension map injectivity obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e (forall m1, m2 in set {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)(tp)e)))))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)tp)))))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in is_(skel, FlavSkel)))))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in pre_(eval_FlavouredType(skel)e))))))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in is_(skel, FlavouredType))))))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e pre_(eval_VoidValType(skel)e)))))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 ((fls(skel) \u003d x_fls(tp)) \u003d\u003e ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))))))","legal map application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 (skel in set (dom fls)))))))","legal map application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e (forall skel in set (elems skels), tp in set (x_type.tps) \u0026 (tp in set (dom x_fls)))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e (is_(x_type, UnionType) \u003d\u003e let x_fls:(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) \u003d (merge {{mk_VoidType(f) |-\u003e f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-\u003e fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-\u003e fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-\u003e fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in ((not (not ((rng fls) subset (rng x_fls)))) \u003d\u003e let tps:set of ((Errvalue | Expressible_type)) \u003d {(cases skel :\nmk_FlavSkel(s, f) -\u003e eval_FlavSkel(skel)(tp)(e),\nmk_FlavouredType(f, t) -\u003e eval_FlavouredType(skel)(e)\nothers eval_VoidValType(skel)(e)\n end) | skel in set (elems skels), tp in set (x_type.tps) \u0026 (fls(skel) \u003d x_fls(tp))} in ((not (exists tp in set tps \u0026 (not (is_(tp, TrType) or (is_(tp, IntType) or (is_(tp, Float) or is_(tp, VoidType))))))) \u003d\u003e is_(tps, set of ((Float | IntType | TrType | VoidType))))))))","unique existence binding obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e (exists1 s in set (elems skels) \u0026 (fls(s) \u003d fl))))))","legal map application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e (forall s in set (elems skels) \u0026 (s in set (dom fls)))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)(x_type)e)))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in pre_(eval_FlavSkel(skel)x_type)))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavSkel(s, f) \u003d skel) \u003d\u003e let mk_FlavSkel(s, f) \u003d skel in is_(skel, FlavSkel)))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in pre_(eval_FlavouredType(skel)e))))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 ((mk_FlavouredType(f, t) \u003d skel) \u003d\u003e let mk_FlavouredType(f, t) \u003d skel in is_(skel, FlavouredType))))))))","legal function application obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e pre_(eval_VoidValType(skel)e)))))))","type compatibility obligation:(forall mk_UnionSkel(skels):UnionSkel, x_type:Expressible_type, e:Env \u0026 let fls:map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) \u003d {skel |-\u003e fl | skel in set (elems skels), fl:Flavdom \u0026 (fl \u003d (cases skel :\nmk_FlavSkel(skel, f) -\u003e eval_Flavouring(f),\nmk_FlavouredType(f, t) -\u003e eval_Flavouring(f)\nothers eval_Flavouring(skel)\n end))} in ((not ((card (dom fls)) \u003c\u003e (card (rng fls)))) \u003d\u003e ((not is_(x_type, UnionType)) \u003d\u003e let fl:(Flavdom | VoidType) \u003d (if is_(x_type, VoidType)\nthen x_type\nelse (x_type.fl)) in ((not (fl not in set (rng fls))) \u003d\u003e let skel:(FlavSkel | FlavouredType | VoidValType) \u003d (iota s in set (elems skels) \u0026 (fls(s) \u003d fl)) in ((not (exists mk_FlavSkel(s, f):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavSkel(s, f) \u003d skel))) \u003d\u003e ((not (exists mk_FlavouredType(f, t):(FlavSkel | FlavouredType | VoidValType) \u0026 (mk_FlavouredType(f, t) \u003d skel))) \u003d\u003e is_(skel, Flavouring)))))))","legal function application obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_SkeletonType(skel)((x.type))e))","legal function application obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 pre_(eval_SkeletonType(skel)(x.type)))","type compatibility obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((not (fl \u003d nil)) \u003d\u003e ((((((is_(t, Float) or is_(t, IntType)) or is_(t, StructureType)) or is_(t, TrType)) or is_(t, UnionType)) or is_(t, VectorType)) or is_(t, VoidType)))))","type compatibility obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e ((not (fl \u003d nil)) \u003d\u003e is_(fl, Flavouring))))","legal function application obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)(x)e))))","legal function application obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e pre_(update_env(id)x))))","type compatibility obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e is_(x, Errvalue))))","type compatibility obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in ((not (id \u003d nil)) \u003d\u003e is_(id, token))))","type compatibility obligation:(forall mk_NonStrucTest(id, fl, skel):NonStrucTest, x:Expressible_value, e:Env, ps:PState \u0026 (is_(let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in (if (id \u003d nil)\nthen mk_(t\u0027, e, (ps.time))\nelse mk_(t\u0027, update_env(id)(x)(e), (ps.time)))), (Expressible_type * Env * Time)) or is_(let t:(Errvalue | Expressible_type) \u003d eval_SkeletonType(skel)((x.type))(e) in (if (t \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse let t\u0027:(Errvalue | Expressible_type) \u003d (if (fl \u003d nil)\nthen t\nelse replace_flavour(t, eval_Flavouring(fl))) in (if (id \u003d nil)\nthen mk_(t\u0027, e, (ps.time))\nelse mk_(t\u0027, update_env(id)(x)(e), (ps.time)))), Errvalue)))","type compatibility obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (is_((x.val)(i), bool) or is_((x.val)(i), real))))))","legal sequence application obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (i in set (inds (x.val)))))))","legal sequence application obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e (forall i in set (inds (x.val)) \u0026 (i in set (inds ((x.type).tps)))))))","legal function application obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)(xs)(e)ps))))","legal function application obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)(xs)e))))","legal function application obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in pre_(eval_Testseq(tests)xs))))","value binding obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tps, env, time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u0026 (mk_(tps, env, time) \u003d ts))))))","type compatibility obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e is_(ts, (seq of (Expressible_type) * Env * Time))))))","type compatibility obligation:(forall mk_StrucTest(tests):StrucTest, x:Expressible_value, e:Env, ps:PState \u0026 ((not (not is_(x, Structure))) \u003d\u003e ((not (struc_length((x.type)) \u003c\u003e (len tests))) \u003d\u003e let xs:seq of (Expressible_value) \u003d [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq(tests)(xs)(e)(ps) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tps, env, time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d ts in is_(tps, seq1 of (CompType))))))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e (tests \u003c\u003e [])))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e (((hd tests) \u003d \u003cnil\u003e) \u003d\u003e (xs \u003c\u003e []))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))((hd xs))(e)ps))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))((hd xs))e))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e pre_(eval_NonStrucTest((hd tests))(hd xs)))))","type compatibility obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e is_((hd tests), NonStrucTest))))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e (tests \u003c\u003e []))))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e ((not ((hd tests) \u003d \u003cnil\u003e)) \u003d\u003e (xs \u003c\u003e []))))","value binding obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u0026 (mk_(tp, env, time) \u003d t)))))","type compatibility obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e (is_(t, ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time)) or is_(t, (Expressible_type * Env * Time))))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))((tl xs))(env)mu(ps, time |-\u003e time)))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))((tl xs))env))))","legal function application obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in pre_(eval_Testseq((tl tests))(tl xs)))))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in (tests \u003c\u003e []))))","non-empty sequence obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in (xs \u003c\u003e []))))","value binding obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-\u003e time)) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(tps, n_env, n_time):((seq of (Expressible_type) * Env * Time) | Errvalue) \u0026 (mk_(tps, n_env, n_time) \u003d ts))))))","type compatibility obligation:(forall tests:seq of ((\u003cnil\u003e | NonStrucTest)), xs:seq of (Expressible_value), e:Env, ps:PState \u0026 ((not (tests \u003d [])) \u003d\u003e let t:(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d (if ((hd tests) \u003d \u003cnil\u003e)\nthen mk_(((hd xs).type), e, (ps.time))\nelse eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in ((not (t \u003d \u003cerr\u003e)) \u003d\u003e let mk_(tp, env, time):(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) \u003d t in let ts:((seq of (Expressible_type) * Env * Time) | Errvalue) \u003d eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-\u003e time)) in ((not (ts \u003d \u003cerr\u003e)) \u003d\u003e is_(ts, (seq of (Expressible_type) * Env * Time))))))","legal function application obligation:(forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 (is_(oul, OuterIntLoop) \u003d\u003e pre_(eval_OuterIntLoop(oul)(e)ps)))","legal function application obligation:(forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 (is_(oul, OuterIntLoop) \u003d\u003e pre_(eval_OuterIntLoop(oul)e)))","legal function application obligation:(forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e pre_(eval_OuterVecLoop(oul)(e)ps)))","legal function application obligation:(forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e pre_(eval_OuterVecLoop(oul)e)))","type compatibility obligation:(forall mk_OuterLoop(oul):OuterLoop, e:Env, ps:PState \u0026 ((not is_(oul, OuterIntLoop)) \u003d\u003e is_(oul, OuterVecLoop)))","legal function application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 pre_(eval_Range(range)e))","legal function application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))mu(ps, time |-\u003e zerot)))))","legal function application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(eval_Sequence(actns)update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e)))))","legal function application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))e))))","legal function application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set nrange \u0026 pre_(update_env(id)mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {})))))))","type compatibility obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e is_([((vec_elems(i).val).type) | i in set (inds vec_elems)], seq1 of (Expressible_type)))))","legal sequence application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((is_(type, StructureType) or is_(type, VectorType)) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","legal sequence application obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((not (is_(type, StructureType) or is_(type, VectorType))) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","type compatibility obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","type compatibility obligation:(forall mk_OuterIntLoop(mk_OverRange(id, range), actns):OuterIntLoop, e:Env, ps:PState \u0026 let nrange:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in ((not (nrange \u003d \u003cerr\u003e)) \u003d\u003e let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(\u003cword\u003e, {i}, {}))))(e))(mu(ps, time |-\u003e zerot)) | i in set nrange] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(vec_val, seq1 of (Errvalue)) or is_(vec_val, seq1 of (Int))) or is_(vec_val, seq1 of (Real))) or is_(vec_val, seq1 of (StructValue))) or is_(vec_val, seq1 of (Tr))) or is_(vec_val, seq1 of (VectorValue))) or is_(vec_val, seq1 of (Void)))))))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)(e)ps))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)e))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set (inds idvs) \u0026 (i in set (inds idvs)))))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 pre_(multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))e))))","type compatibility obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 is_(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])), seq of ((Id * Denotable_value))))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e (forall i:nat \u0026 (forall j in set (inds idvs) \u0026 (j in set (inds idvs))))))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(eval_Sequence(actions)(new_env(i))mu(ps, time |-\u003e zerot)))))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(eval_Sequence(actions)new_env(i)))))","legal function application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (forall i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val)) \u0026 pre_(new_envi))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in (1 in set (inds idvs))))","type compatibility obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e is_([((vec_elems(i).val).type) | i in set (inds vec_elems)], seq1 of (Expressible_type)))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))","type compatibility obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e ((((((is_(type, Float) or is_(type, IntType)) or is_(type, StructureType)) or is_(type, TrType)) or is_(type, UnionType)) or is_(type, VectorType)) or is_(type, VoidType))))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in ((is_(type, StructureType) or is_(type, VectorType)) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","legal sequence application obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in ((not (is_(type, StructureType) or is_(type, VectorType))) \u003d\u003e (forall i in set (inds vec_elems) \u0026 (i in set (inds vec_elems))))))))","type compatibility obligation:(forall mk_OuterVecLoop(ovs, actions):OuterVecLoop, e:Env, ps:PState \u0026 let idvs:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (idvs \u003d \u003cerr\u003e)) \u003d\u003e let time1:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(i) in t | i in set (inds idvs)]), new_env:(nat -\u003e Env) \u003d (lambda [i:nat] \u0026 multi_update_env(([let mk_(id, v, t):(Id * Vector * Time) \u003d idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) \u003d nil)\nthen []\nelse [mk_((ovs.cnt), i)])))(e)) in let vec_elems:seq of (EST_value) \u003d [eval_Sequence(actions)(new_env(i))(mu(ps, time |-\u003e zerot)) | i in set let mk_(i1, v, t):(Id * Vector * Time) \u003d idvs(1) in (inds (v.val))] in ((not (\u003cerr\u003e in set {(x.val) | x in set (elems vec_elems)})) \u003d\u003e let type:(Errvalue | Expressible_type) \u003d seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time:Time \u003d dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in ((not (type \u003d \u003cerr\u003e)) \u003d\u003e let new_tp:VectorType \u003d mk_VectorType(1, (len vec_elems), type, {}) in let vec_val:(seq of ((\u003cnil\u003e | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) \u003d (if (is_(type, StructureType) or is_(type, VectorType))\nthen [((vec_elems(i).val).val) | i in set (inds vec_elems)]\nelse [(vec_elems(i).val) | i in set (inds vec_elems)]) in ((((((is_(vec_val, seq1 of (Errvalue)) or is_(vec_val, seq1 of (Int))) or is_(vec_val, seq1 of (Real))) or is_(vec_val, seq1 of (StructValue))) or is_(vec_val, seq1 of (Tr))) or is_(vec_val, seq1 of (VectorValue))) or is_(vec_val, seq1 of (Void)))))))","legal sequence application obligation:(forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 (i in set (inds (ovs.ovv)))))","legal function application obligation:(forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in pre_(eval_Operation(val)(e)mu(ps, time |-\u003e zerot))))","legal function application obligation:(forall ovs:OverVectors, e:Env, ps:PState \u0026 (forall i in set (inds (ovs.ovv)) \u0026 let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in pre_(eval_Operation(val)e)))","legal sequence application obligation:(forall ovs:OverVectors, e:Env, ps:PState \u0026 let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (forall i in set (inds indices) \u0026 (i in set (inds indices))))","type compatibility obligation:(forall ovs:OverVectors, e:Env, ps:PState \u0026 (is_(let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists i in set (inds indices) \u0026 let mk_(id, v, t):(Id * Expressible_value * Time) \u003d indices(i) in (not is_(v, Vector)))\nthen \u003cerr\u003e\nelse indices), Errvalue) or is_(let indices:seq of ((Id * Expressible_value * Time)) \u003d [let mk_OverVector(id, val):OverVector \u003d (ovs.ovv)(i) in let x:EST_value \u003d eval_Operation(val)(e)(mu(ps, time |-\u003e zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists i in set (inds indices) \u0026 let mk_(id, v, t):(Id * Expressible_value * Time) \u003d indices(i) in (not is_(v, Vector)))\nthen \u003cerr\u003e\nelse indices), seq1 of ((Id * Vector * Time)))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in pre_(eval_IntLoop(innerl)(e)ps))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in pre_(eval_IntLoop(innerl)e))))","type compatibility obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_IntLoop(inc, actions) \u003d innerl) \u003d\u003e let mk_IntLoop(inc, actions) \u003d innerl in is_(innerl, IntLoop))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in pre_(eval_VecLoop(innerl)(e)ps)))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in pre_(eval_VecLoop(innerl)e)))))","type compatibility obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_VecLoop(ovs, actions) \u003d innerl) \u003d\u003e let mk_VecLoop(ovs, actions) \u003d innerl in is_(innerl, VecLoop)))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in pre_(eval_TimeLoop(innerl)(e)ps))))))","legal function application obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in pre_(eval_TimeLoop(innerl)e))))))","type compatibility obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 ((not (exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_IntLoop(inc, actions) \u003d innerl))) \u003d\u003e ((not (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (mk_VecLoop(ovs, actions) \u003d innerl))) \u003d\u003e (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 ((mk_TimeLoop(time, actions) \u003d innerl) \u003d\u003e let mk_TimeLoop(time, actions) \u003d innerl in is_(innerl, TimeLoop))))))","cases exhaustive obligation:(forall mk_InnerLoop(innerl):InnerLoop, e:Env, ps:PState \u0026 (((exists mk_IntLoop(inc, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_IntLoop(inc, actions))) or (exists mk_VecLoop(ovs, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_VecLoop(ovs, actions)))) or (exists mk_TimeLoop(time, actions):(IntLoop | TimeLoop | VecLoop) \u0026 (innerl \u003d mk_TimeLoop(time, actions)))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 pre_(eval_InnerControl(inc)(e)ps))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 pre_(eval_InnerControl(inc)e))","value binding obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e (exists mk_(id, range):((Id * seq of (int)) | Errvalue) \u0026 (mk_(id, range) \u003d idrng))))","type compatibility obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e is_(idrng, (Id * seq of (int)))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))e))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(update_env(id)mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {})))))))","legal sequence application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 ((x.i) in set (inds range)))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in pre_(eval_SeqIterate(actions)(new_env)x))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in pre_(eval_SeqIterate(actions)new_env))))","legal function application obligation:(forall mk_IntLoop(inc, actions):IntLoop, e:Env, ps:PState \u0026 let idrng:((Id * seq of (int)) | Errvalue) \u003d eval_InnerControl(inc)(e)(ps) in ((not (idrng \u003d \u003cerr\u003e)) \u003d\u003e let mk_(id, range):((Id * seq of (int)) | Errvalue) \u003d idrng in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let new_env:Env \u003d update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(\u003cword\u003e, (elems range), {}))))(e) in eval_SeqIterate(actions)(new_env)(x)) in pre_(NIterate(f, (len range))mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time)), 1))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 (exists mk_OverRange(cnt, range):InnerControl \u0026 ((mk_OverRange(cnt, range) \u003d inc) \u003d\u003e let mk_OverRange(cnt, range) \u003d inc in pre_(eval_Range(range)e))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(from_b)(e)ps)))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(from_b)e)))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(to_b)(e)ps)))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in pre_(eval_Operation(to_b)e)))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((inc \u003d nil) \u003d\u003e is_(((b1.val).val), real)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((inc \u003d nil) \u003d\u003e is_(((b2.val).val), real)))))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e pre_(eval_Operation(inc)(e)ps)))))))","legal function application obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e pre_(eval_Operation(inc)e)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e ((not (inc \u003d nil)) \u003d\u003e is_(inc, Operation)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v3, real)))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v2, real)))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not (not is_((b3.val), Int))) \u003d\u003e (is_((b3.val), Int) \u003d\u003e (forall v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 is_(v1, real)))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 (((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val)))) \u003d\u003e is_(((b1.val).val), real)))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 (((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val)))) \u003d\u003e is_((b3.val), real)))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_((b3.val), real)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_(((b2.val).val), real)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e is_(((b1.val).val), real)))))))","non-zero obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e ((b3.val) \u003c\u003e 0)))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_((b3.val), real))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_(((b2.val).val), real))))))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((not (exists mk_OverRange(cnt, range):InnerControl \u0026 (mk_OverRange(cnt, range) \u003d inc))) \u003d\u003e (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 ((mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc) \u003d\u003e let mk_PartialRange(cnt, from_b, to_b, inc) \u003d inc in let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in ((not (not (is_((b1.val), Int) and is_((b2.val), Int)))) \u003d\u003e let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in ((not ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))) \u003d\u003e (forall alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 is_(((b1.val).val), real))))))))","cases exhaustive obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 ((exists mk_OverRange(cnt, range):InnerControl \u0026 (inc \u003d mk_OverRange(cnt, range))) or (exists mk_PartialRange(cnt, from_b, to_b, inc):InnerControl \u0026 (inc \u003d mk_PartialRange(cnt, from_b, to_b, inc)))))","type compatibility obligation:(forall inc:InnerControl, e:Env, ps:PState \u0026 (is_((cases inc :\nmk_OverRange(cnt, range) -\u003e let r:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (r \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(cnt, [x | x in set r])),\nmk_PartialRange(cnt, from_b, to_b, inc) -\u003e let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen \u003cerr\u003e\nelse let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))\nthen \u003cerr\u003e\nelse let r:seq of (real) \u003d [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 ((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))\n end), (Id * seq of (int))) or is_((cases inc :\nmk_OverRange(cnt, range) -\u003e let r:(Errvalue | set of (int)) \u003d eval_Range(range)(e) in (if (r \u003d \u003cerr\u003e)\nthen \u003cerr\u003e\nelse mk_(cnt, [x | x in set r])),\nmk_PartialRange(cnt, from_b, to_b, inc) -\u003e let b1:EST_value \u003d eval_Operation(from_b)(e)(ps), b2:EST_value \u003d eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))\nthen \u003cerr\u003e\nelse let b3:(Expressible_value | Int) \u003d (if (inc \u003d nil)\nthen (if (((b1.val).val) \u003c\u003d ((b2.val).val))\nthen mk_Int(1, mk_IntType(\u003cbyte\u003e, {1, -1}, {}))\nelse mk_Int(-1, mk_IntType(\u003cbyte\u003e, {1, -1}, {})))\nelse (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range) \u0026 (((v2 - v1) * v3) \u003c 0))))\nthen \u003cerr\u003e\nelse let r:seq of (real) \u003d [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} \u0026 ((abs (alpha * (b3.val))) \u003c\u003d (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))\n end), Errvalue)))","legal function application obligation:(forall sequ:Sequence, e:Env, exi:EST_Iterate \u0026 ((not (((exi.expst).val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Sequence(sequ)(e)mk_PState(((exi.expst).sto), ((exi.expst).time)))))","legal function application obligation:(forall sequ:Sequence, e:Env, exi:EST_Iterate \u0026 ((not (((exi.expst).val) \u003d \u003cerr\u003e)) \u003d\u003e pre_(eval_Sequence(sequ)e)))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)(e)ps))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 pre_(eval_OverVectors(ovs)e))","legal sequence application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e (forall i in set (inds indices) \u0026 (i in set (inds indices)))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 pre_(multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])e))))","type compatibility obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 is_([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)], seq of ((Id * Denotable_value))))))","legal sequence application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 (forall i in set (inds indices) \u0026 (i in set (inds indices))))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e pre_(update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))env)))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e pre_(update_env((ovs.cnt))mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))))))","type compatibility obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in ((not ((ovs.cnt) \u003d nil)) \u003d\u003e is_((ovs.cnt), token)))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in pre_(eval_SeqIterate(actions)(new_env)mu(x, expst |-\u003e new_expst)))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in (forall x:(unresolved DEFAULT`EST_Iterate) \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in pre_(eval_SeqIterate(actions)new_env))))","legal sequence application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-\u003e new_expst))) in (1 in set (inds indices))))","legal function application obligation:(forall mk_VecLoop(ovs, actions):VecLoop, e:Env, ps:PState \u0026 let indices:(Errvalue | seq1 of ((Id * Vector * Time))) \u003d eval_OverVectors(ovs)(e)(ps) in ((not (indices \u003d \u003cerr\u003e)) \u003d\u003e let time:Time \u003d dtplus([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in t | i in set (inds indices)]) in let f:(EST_Iterate -\u003e EST_Iterate) \u003d (lambda [x:(unresolved DEFAULT`EST_Iterate)] \u0026 let env:Env \u003d multi_update_env([let mk_(id, v, t):(Id * Vector * Time) \u003d indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst:EST_value \u003d mu((x.expst), time |-\u003e ((x.expst).time)) in let new_env:Env \u003d (if ((ovs.cnt) \u003d nil)\nthen env\nelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(\u003cword\u003e, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-\u003e new_expst))) in let mk_(-, v, -):(Id * Vector * Time) \u003d indices(1) in pre_(NIterate(f, (len (v.val)))mk_EST_Iterate(mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), tplus((ps.time), time)), 1))))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_Sequence(actions)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 pre_(eval_Sequence(actions)e))","unique existence binding obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (exists1 n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))))))","type compatibility obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall n:nat \u0026 is_(t, (nat * nat))))))","type compatibility obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) \u003d\u003e is_(t, (nat * nat)))))))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall exs:(unresolved DEFAULT`EST_value) \u0026 pre_(eval_Sequence(actions)(e)mk_PState((exs.sto), (exs.time)))))))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e (forall exs:(unresolved DEFAULT`EST_value) \u0026 pre_(eval_Sequence(actions)e)))))","legal function application obligation:(forall mk_TimeLoop(time, actions):TimeLoop, e:Env, ps:PState \u0026 let t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e), x:EST_value \u003d eval_Sequence(actions)(e)(mu(ps, time |-\u003e zerot)) in ((not ((t \u003d \u003cerr\u003e) or ((x.val) \u003d \u003cerr\u003e))) \u003d\u003e ((exists n:nat \u0026 timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t)) \u003d\u003e let its:nat \u003d (iota n:nat \u0026 (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))), f:(EST_value -\u003e EST_value) \u003d (lambda [exs:(unresolved DEFAULT`EST_value)] \u0026 eval_Sequence(actions)(e)(mk_PState((exs.sto), (exs.time)))) in pre_(Iterate(f, its)mk_EST_value(mk_Void(\u003cnil\u003e, mk_VoidType({})), (ps.sto), (ps.time))))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in pre_(eval_NvAssignment(ass)(env)ps))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in pre_(eval_NvAssignment(ass)env))))","type compatibility obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_NvAssignment(d, e) \u003d ass) \u003d\u003e let mk_NvAssignment(d, e) \u003d ass in is_(ass, NvAssignment))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in pre_(eval_MultAssignment(ass)(env)ps)))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in pre_(eval_MultAssignment(ass)env)))))","type compatibility obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_MultAssignment(d, m, e) \u003d ass) \u003d\u003e let mk_MultAssignment(d, m, e) \u003d ass in is_(ass, MultAssignment)))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in pre_(eval_StrAssignment(ass)(env)ps))))))","legal function application obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in pre_(eval_StrAssignment(ass)env))))))","type compatibility obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 ((not (exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_NvAssignment(d, e) \u003d ass))) \u003d\u003e ((not (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (mk_MultAssignment(d, m, e) \u003d ass))) \u003d\u003e (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 ((mk_StrAssignment(d, e) \u003d ass) \u003d\u003e let mk_StrAssignment(d, e) \u003d ass in is_(ass, StrAssignment))))))","cases exhaustive obligation:(forall mk_Assignment(ass):Assignment, env:Env, ps:PState \u0026 (((exists mk_NvAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_NvAssignment(d, e))) or (exists mk_MultAssignment(d, m, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_MultAssignment(d, m, e)))) or (exists mk_StrAssignment(d, e):(MultAssignment | NvAssignment | StrAssignment) \u0026 (ass \u003d mk_StrAssignment(d, e)))))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 pre_(access_env(dest)e))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(eval_Expression(expr)(e)ps)))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(eval_Expression(expr)e)))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e pre_(access(l)(ps.sto))))))","type compatibility obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e is_(l, Location)))))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e pre_(update(l)(mk_Storable_value(widen_type((x.val), (dest_val.type))))(ps.sto)))))))","legal function application obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e pre_(update(l)mk_Storable_value(widen_type((x.val), (dest_val.type)))))))))","type compatibility obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e is_(l, Location))))))","type compatibility obligation:(forall mk_NvAssignment(dest, expr):NvAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not ((x.val) \u003d \u003cerr\u003e)) \u003d\u003e ((not (cases ((x.val).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)) \u003d\u003e let mk_Storable_value(dest_val):Storable_value \u003d access(l)((ps.sto)) in (gt((dest_val.type), ((x.val).type)) \u003d\u003e ((((((is_(widen_type((x.val), (dest_val.type)), Int) or is_(widen_type((x.val), (dest_val.type)), Real)) or is_(widen_type((x.val), (dest_val.type)), Structure)) or is_(widen_type((x.val), (dest_val.type)), Tr)) or is_(widen_type((x.val), (dest_val.type)), Union)) or is_(widen_type((x.val), (dest_val.type)), Vector)) or is_(widen_type((x.val), (dest_val.type)), Void)))))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 pre_(access_env(dest)e))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e pre_(access(l)(ps.sto))))","type compatibility obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e is_(l, Location)))","value binding obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e (exists mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u0026 (mk_Vector(val, type) \u003d v)))))","type compatibility obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e is_(v, Vector))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in pre_(eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)e))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in pre_(eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))mult))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in pre_(eval_Expression(expr)(e)mk_PState((v\u0027.sto), (v\u0027.time))))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in pre_(eval_Expression(expr)e))))","type compatibility obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in is_(vmid, Vector))))))","type compatibility obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in (((is_(t_vector_concat, (nat * nat)) and is_(t_vector_concat, (nat * nat))) and is_(vector_subv, (nat * nat))) and is_(vector_subv, (nat * nat))))))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in pre_(update(l)(mk_Storable_value(new_vec))(ps.sto)))))))","legal function application obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in pre_(update(l)mk_Storable_value(new_vec)))))))","type compatibility obligation:(forall mk_MultAssignment(dest, mult, expr):MultAssignment, e:Env, ps:PState \u0026 let l:Denotable_value \u003d access_env(dest)(e) in ((not (not is_(l, Location))) \u003d\u003e let mk_Storable_value(v):Storable_value \u003d access(l)((ps.sto)) in ((not (not is_(v, Vector))) \u003d\u003e let mk_Vector(val, type):(Int | Real | Structure | Tr | Union | Vector | Void) \u003d v in let v\u0027:EST_value \u003d eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x:EST_value \u003d eval_Expression(expr)(e)(mk_PState((v\u0027.sto), (v\u0027.time))) in ((not (((v\u0027.val) \u003d \u003cerr\u003e) or (not is_((x.val), Vector)))) \u003d\u003e ((not ((((((x.val).type).upper) - (((x.val).type).lower)) \u003c\u003e ((((v\u0027.val).type).upper) - (((v\u0027.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) :\nmk_VoidType(t) -\u003e (t \u003d {Phi})\nothers ((((x.val).type).fl) \u003d {Phi})\n end)))) \u003d\u003e let vleft:Vector \u003d mk_Vector(vector_subv(val, (type.lower), ((((v\u0027.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v\u0027.val).type).lower) - 1), (type.type), (type.fl))), vmid:Expressible_value \u003d (x.val), vright:Vector \u003d mk_Vector(vector_subv(val, ((((v\u0027.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v\u0027.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec:Vector \u003d vector_concat(vector_concat(vleft, vmid), vright), new_time:Time \u003d dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in is_(l, Location))))))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 (forall i in set (inds dest) \u0026 pre_(access_env(dest(i))e)))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 (forall i in set (inds dest) \u0026 (i in set (inds dest))))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e pre_(eval_Expression(expr)(e)ps)))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e pre_(eval_Expression(expr)e)))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 pre_(access(ls(i))(ps.sto)))))))","type compatibility obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 is_(ls(i), Location))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e (forall i in set (inds ls) \u0026 (i in set (inds ls)))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in (forall i in set (inds nvals) \u0026 (i in set (inds nvals)))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in (forall i in set (inds vals) \u0026 (i in set (inds vals)))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in (forall i in set (inds (((x.val).type).tps)) \u0026 (i in set (inds (((x.val).type).tps))))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (forall i in set (inds dest_tps) \u0026 (i in set (inds dest_tps)))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (forall i in set (inds dest_tps) \u0026 (i in set (inds x_tps)))))))","type compatibility obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (is_(((x.val).val)(i), bool) or is_(((x.val).val)(i), real))))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (i in set (inds ((x.val).val)))))))))","legal sequence application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 (i in set (inds (((x.val).type).tps)))))))))","type compatibility obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e (forall i in set (inds ((x.val).val)) \u0026 ((((((is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Int) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Real)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Structure)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Tr)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Union)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Vector)) or is_(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i)), Void))))))))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_(multi_update(ls)(ys)(ps.sto)))))))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_(multi_update(ls)ys))))))","legal function application obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in pre_multi_update(ls))))))","type compatibility obligation:(forall mk_StrAssignment(dest, expr):StrAssignment, e:Env, ps:PState \u0026 let ls:seq of (Denotable_value) \u003d [access_env(dest(i))(e) | i in set (inds dest)] in ((not (exists l in set (elems ls) \u0026 (not is_(l, Location)))) \u003d\u003e let x:EST_value \u003d eval_Expression(expr)(e)(ps) in ((not (not is_((x.val), Structure))) \u003d\u003e ((not ((len ls) \u003c\u003e struc_length(((x.val).type)))) \u003d\u003e let nvals:seq of (Storable_value) \u003d [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals:seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) \u003d [let mk_Storable_value(v):Storable_value \u003d nvals(i) in v | i in set (inds nvals)] in let dest_tps:seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) \u003d [(vals(i).type) | i in set (inds vals)], x_tps:seq of (CompType) \u003d [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in ((not (exists i in set (inds dest_tps) \u0026 (not gt(dest_tps(i), x_tps(i))))) \u003d\u003e let ys:seq of (Storable_value) \u003d [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t:Time \u003d dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in is_(ls, seq of (Location)))))))","legal function application obligation:(forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 (is_(texpr, TimeTakes) \u003d\u003e pre_(eval_TimeTakes(texpr)(e)ps)))","legal function application obligation:(forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 (is_(texpr, TimeTakes) \u003d\u003e pre_(eval_TimeTakes(texpr)e)))","legal function application obligation:(forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e pre_(eval_TimeAssertion(texpr)(e)ps)))","legal function application obligation:(forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e pre_(eval_TimeAssertion(texpr)e)))","type compatibility obligation:(forall mk_TimedExpression(texpr):TimedExpression, e:Env, ps:PState \u0026 ((not is_(texpr, TimeTakes)) \u003d\u003e is_(texpr, TimeAssertion)))","legal function application obligation:(forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation:(forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_TimeTakes(expr, time):TimeTakes, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","legal function application obligation:(forall time:TimeInterval, e:Env \u0026 pre_(eval_Range(time)e))","legal function application obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not (range \u003d \u003cerr\u003e)) \u003d\u003e pre_min(range)))","type compatibility obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not (range \u003d \u003cerr\u003e)) \u003d\u003e is_(range, set of (real))))","legal function application obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e pre_min(range)))","type compatibility obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e is_(range, set of (real))))","legal function application obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e pre_max(range)))","type compatibility obligation:(forall time:TimeInterval, e:Env \u0026 let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in ((not ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))) \u003d\u003e is_(range, set of (real))))","type compatibility obligation:(forall time:TimeInterval, e:Env \u0026 (is_(let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in (if ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))\nthen \u003cerr\u003e\nelse mk_(min(range), max(range))), Errvalue) or is_(let range:(Errvalue | set of (int)) \u003d eval_Range(time)(e) in (if ((range \u003d \u003cerr\u003e) or (min(range) \u003c 0))\nthen \u003cerr\u003e\nelse mk_(min(range), max(range))), Time)))","legal function application obligation:(forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)(e)mu(ps, time |-\u003e zerot)))","legal function application obligation:(forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_Expression(expr)e))","legal function application obligation:(forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 pre_(eval_TimeInterval(time)e))","type compatibility obligation:(forall mk_TimeAssertion(expr, time):TimeAssertion, e:Env, ps:PState \u0026 let x:EST_value \u003d eval_Expression(expr)(e)(mu(ps, time |-\u003e zerot)), t:(Errvalue | Time) \u003d eval_TimeInterval(time)(e) in ((not (((x.val) \u003d \u003cerr\u003e) or (t \u003d \u003cerr\u003e))) \u003d\u003e (timeleq(t, (x.time)) \u003d\u003e is_(t, (nat * nat)))))","function compose obligation:(forall f:(EST_value -\u003e EST_value), n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003d 1)) \u003d\u003e (forall arg1:EST_value \u0026 (pre_(Iterate(f, (n - 1))arg1) \u003d\u003e pre_(fIterate(f, (n - 1))(arg1)))))))","function compose obligation:(forall f:(EST_Iterate -\u003e EST_Iterate), n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003d 1)) \u003d\u003e (forall arg1:EST_Iterate \u0026 (pre_(NIterate(f, (n - 1))arg1) \u003d\u003e pre_(fNIterate(f, (n - 1))(arg1)))))))"]