["legal map application obligation:(forall eventid:EventId, pigId:PigId \u0026 (pigId in set (dom stables)))","map compatible obligation:(forall pigID:PigId, stableController:StableController \u0026 ((pigID not in set (dom stables)) \u003d\u003e (forall ldom1 in set (dom stables), rdom2 in set (dom {pigID |-\u003e stableController}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (stables(ldom1) \u003d {pigID |-\u003e stableController}(rdom2))))))","operation establishes postcondition obligation:(forall pigID:PigId, stableController:StableController \u0026 ((pigID not in set (dom stables)) \u003d\u003e ((card (dom (stables munion {pigID |-\u003e stableController}))) \u003d ((card (dom stables)) + 1))))","operation establishes postcondition obligation:(forall pigID:PigId \u0026 ((pigID in set (dom stables)) \u003d\u003e (((card (dom ({pigID} \u003c-: stables))) + 1) \u003d (card (dom stables)))))","non-empty sequence obligation:(medicTimes \u003c\u003e [])","non-empty sequence obligation:(medicTimes \u003c\u003e [])","legal function application obligation:(forall fname:seq of (char) \u0026 pre_(((io.freadval))[(Time * seq of (inline))]fname))","map compatible obligation:(forall psens:Sensor \u0026 (forall ldom1 in set (dom sensors), rdom2 in set (dom {id |-\u003e psens}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (sensors(ldom1) \u003d {id |-\u003e psens}(rdom2)))))","type compatibility obligation:((server \u003c\u003e nil) \u003d\u003e is_(RESULT, Server))","legal map application obligation:(forall pigID:PigId, sensor:Sensor, position:Position \u0026 ((sensor in set (dom sensors)) \u003d\u003e (sensor in set (dom sensors))))","type compatibility obligation:(forall pigID:PigId, sensor:Sensor, position:Position \u0026 ((sensor in set (dom sensors)) \u003d\u003e is_(pigID, nat1)))","map compatible obligation:(forall pigID:PigId, sensor:Sensor, position:Position \u0026 ((sensor in set (dom sensors)) \u003d\u003e (forall ldom1 in set (dom pigsInSty), rdom2 in set (dom {pigPos |-\u003e pigStyId}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (pigsInSty(ldom1) \u003d {pigPos |-\u003e pigStyId}(rdom2))))))","type compatibility obligation:(forall pigID:PigId \u0026 ((exists pp in set (dom pigsInSty) \u0026 ((pp.id) \u003d pigID)) \u003d\u003e is_(pigID, nat1)))","let be st existence obligation:(forall eventId:EventId, pigId:PigId \u0026 (exists pigPos in set (dom pigsInSty) \u0026 ((pigPos.id) \u003d pigId)))","map inverse obligation:(forall eventId:EventId, pigId:PigId \u0026 is_(actuators, inmap (Actuator) to (PigStyId)))","map compatible obligation:(forall act:Actuator, sti:PigStyId \u0026 ((act not in set (dom actuators)) \u003d\u003e (forall ldom1 in set (dom actuators), rdom2 in set (dom {act |-\u003e sti}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (actuators(ldom1) \u003d {act |-\u003e sti}(rdom2))))))","type compatibility obligation:(forall act:Actuator, sti:PigStyId \u0026 ((act not in set (dom actuators)) \u003d\u003e is_((actuators munion {act |-\u003e sti}), inmap (Actuator) to (PigStyId))))","map compatible obligation:(forall sens:Sensor, sti:PigStyId \u0026 ((sens not in set (dom sensors)) \u003d\u003e (forall ldom1 in set (dom sensors), rdom2 in set (dom {sens |-\u003e sti}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (sensors(ldom1) \u003d {sens |-\u003e sti}(rdom2))))))","legal function application obligation:(forall text:seq of (char) \u0026 pre_(((file.writeval))[seq of (char)]text))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]