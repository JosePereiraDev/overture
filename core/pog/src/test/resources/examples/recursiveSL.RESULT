["type invariant satisfiable obligation:(exists g:Graph \u0026 ((dunion (rng g)) subset (dom g)))","legal function application obligation:(forall asyncg:Graph \u0026 (forall id in set (dom asyncg) \u0026 pre_TransClos(asyncg, id)))","type invariant satisfiable obligation:(exists asyncg:ASyncGraph \u0026 (forall id in set (dom asyncg) \u0026 (id not in set TransClos(asyncg, id))))","legal map application obligation:(forall g:ASyncGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (id in set (dom g))))","legal function application obligation:(forall g:ASyncGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e let children:set of (Id) \u003d g(id) in ((not (children \u003d {})) \u003d\u003e (forall c in set children \u0026 pre_Paths(g, c)))))","recursive function obligation:(forall g:ASyncGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e let children:set of (Id) \u003d g(id) in ((not (children \u003d {})) \u003d\u003e (forall c in set children \u0026 (measureTransClos(g, id) \u003e measureTransClos(g, c))))))","legal function application obligation:(forall g:ASyncGraph, id:Id \u0026 pre_TransClos(g, id))","legal function application obligation:(forall g:Graph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e pre_TransClos(g, id)))","legal map application obligation:(forall g:Graph, id:Id \u0026 (((id in set (dom g)) and (id not in set TransClos(g, id))) \u003d\u003e (id in set (dom g))))","legal map application obligation:(forall g:Graph, id:Id \u0026 (((id in set (dom g)) and (id not in set TransClos(g, id))) \u003d\u003e let children:set of (Id) \u003d g(id) in ((not ((card children) \u003c\u003e 1)) \u003d\u003e (forall parent in set (dom g) \u0026 ((parent \u003c\u003e id) \u003d\u003e (parent in set (dom g)))))))","let be st existence obligation:(forall g:Graph, id:Id \u0026 (((id in set (dom g)) and (id not in set TransClos(g, id))) \u003d\u003e let children:set of (Id) \u003d g(id) in ((not (((card children) \u003c\u003e 1) or (exists parent in set (dom g) \u0026 ((parent \u003c\u003e id) and (children subset g(parent)))))) \u003d\u003e (exists child in set children \u0026 true))))","legal function application obligation:(forall g:Graph, id:Id \u0026 (((id in set (dom g)) and (id not in set TransClos(g, id))) \u003d\u003e let children:set of (Id) \u003d g(id) in ((not (((card children) \u003c\u003e 1) or (exists parent in set (dom g) \u0026 ((parent \u003c\u003e id) and (children subset g(parent)))))) \u003d\u003e (forall child in set children \u0026 pre_LinearPath(g, child)))))","legal function application obligation:(forall g:Graph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (forall c in set g(id) \u0026 pre_TransClosAux(g, c, {}))))","legal map application obligation:(forall g:Graph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (id in set (dom g))))","legal function application obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set g(id) \u0026 pre_TransClosAux(g, c, (reached union {id}))))))","recursive function obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set g(id) \u0026 (measureGraphReached(g, id, reached) \u003e measureGraphReached(g, c, (reached union {id})))))))","legal map application obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (id in set (dom g)))))","type compatibility obligation:(forall g:Graph, -:Id, reached:set of (Id) \u0026 (((card (dom g)) - (card reached)) \u003e\u003d 0))","legal function application obligation:(forall g:AcyclicGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (forall c in set g(id) \u0026 pre_AsycDescendents(g, c))))","recursive function obligation:(forall g:AcyclicGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (forall c in set g(id) \u0026 (measureTransClos(g, id) \u003e measureTransClos(g, c)))))","legal map application obligation:(forall g:AcyclicGraph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (id in set (dom g))))","legal function application obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set g(id) \u0026 pre_Descendents(g, c, (reached union {id}))))))","recursive function obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set g(id) \u0026 (measureGraphReached(g, id, reached) \u003e measureGraphReached(g, c, (reached union {id})))))))","legal map application obligation:(forall g:Graph, id:Id, reached:set of (Id) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (id in set (dom g)))))","legal function application obligation:(forall g:Graph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (forall c in set g(id) \u0026 pre_TransClosAux(g, c, {}))))","legal map application obligation:(forall g:Graph, id:Id \u0026 ((id in set (dom g)) \u003d\u003e (id in set (dom g))))","legal function application obligation:(forall acg:Graph \u0026 (forall id in set (dom acg) \u0026 pre_AllDesc(acg, id)))","type invariant satisfiable obligation:(exists acg:AcyclicGraph \u0026 (not (exists id in set (dom acg) \u0026 (id in set AllDesc(acg, id)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e {2, 3}}, {2 |-\u003e {4}}, {3 |-\u003e {5}}, {4 |-\u003e {6}}, {5 |-\u003e {6}}, {6 |-\u003e {}}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_Graph({1 |-\u003e {2, 3}, 2 |-\u003e {4}, 3 |-\u003e {5}, 4 |-\u003e {6}, 5 |-\u003e {6}, 6 |-\u003e {}})","type invariant satisfiable obligation:(exists g:LabGraph \u0026 (UniqueArcIds(g) and (forall m in set (rng g) \u0026 ((rng m) subset (dom g)))))","legal function application obligation:(forall acg:LabGraph \u0026 (forall id in set (dom acg) \u0026 pre_AllLabDesc(acg, id)))","type invariant satisfiable obligation:(exists acg:AcyclicLabGraph \u0026 (not (exists id in set (dom acg) \u0026 (id in set AllLabDesc(acg, id)))))","legal function application obligation:(forall g:LabGraph, id:NodeId \u0026 ((id in set (dom g)) \u003d\u003e (forall c in set (rng g(id)) \u0026 pre_LabDescendents(g, c, {}))))","legal map application obligation:(forall g:LabGraph, id:NodeId \u0026 ((id in set (dom g)) \u003d\u003e (id in set (dom g))))","type compatibility obligation:(forall g:LabGraph, -:Id, reached:set of (Id) \u0026 (((card (dom g)) - (card reached)) \u003e\u003d 0))","legal function application obligation:(forall g:LabGraph, id:NodeId, reached:set of (NodeId) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set (rng g(id)) \u0026 pre_LabDescendents(g, c, (reached union {id}))))))","recursive function obligation:(forall g:LabGraph, id:NodeId, reached:set of (NodeId) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (forall c in set (rng g(id)) \u0026 (measureLabGraphReached(g, id, reached) \u003e measureLabGraphReached(g, c, (reached union {id})))))))","legal map application obligation:(forall g:LabGraph, id:NodeId, reached:set of (NodeId) \u0026 ((id in set (dom g)) \u003d\u003e ((not (id in set reached)) \u003d\u003e (id in set (dom g)))))","comprehension map injectivity obligation:(forall g:map (NodeId) to (map (ArcId) to (NodeId)) \u0026 (forall m1, m2 in set {{nid |-\u003e (dom g(nid))} | nid in set (dom g)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall g:map (NodeId) to (map (ArcId) to (NodeId)) \u0026 (forall nid in set (dom g) \u0026 (nid in set (dom g))))","legal map application obligation:(forall g:map (NodeId) to (map (ArcId) to (NodeId)) \u0026 let m:map (NodeId) to (set of (ArcId)) \u003d {nid |-\u003e (dom g(nid)) | nid in set (dom g)} in (forall nid1, nid2 in set (dom m) \u0026 ((nid1 \u003c\u003e nid2) \u003d\u003e (nid1 in set (dom m)))))","legal map application obligation:(forall g:map (NodeId) to (map (ArcId) to (NodeId)) \u0026 let m:map (NodeId) to (set of (ArcId)) \u003d {nid |-\u003e (dom g(nid)) | nid in set (dom g)} in (forall nid1, nid2 in set (dom m) \u0026 ((nid1 \u003c\u003e nid2) \u003d\u003e (nid2 in set (dom m)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {2 |-\u003e 3}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e {1 |-\u003e 2, 2 |-\u003e 3}}, {2 |-\u003e {3 |-\u003e 4}}, {3 |-\u003e {4 |-\u003e 5}}, {4 |-\u003e {5 |-\u003e 6}}, {5 |-\u003e {6 |-\u003e 6}}, {6 |-\u003e {|-\u003e}}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_LabGraph({1 |-\u003e {1 |-\u003e 2, 2 |-\u003e 3}, 2 |-\u003e {3 |-\u003e 4}, 3 |-\u003e {4 |-\u003e 5}, 4 |-\u003e {5 |-\u003e 6}, 5 |-\u003e {6 |-\u003e 6}, 6 |-\u003e {|-\u003e}})"]