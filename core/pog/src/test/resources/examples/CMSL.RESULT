["type invariant satisfiable obligation:(exists num:Angle \u0026 (num \u003c\u003d 360))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)]}, {\u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)]}, {\u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e 1}, {\u003cMissileB\u003e |-\u003e 2}, {\u003cMissileC\u003e |-\u003e 3}, {\u003cNone\u003e |-\u003e 0}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:((((inv_Angle(88) and is_(88, nat)) and (inv_Angle(70) and is_(70, nat))) and (inv_Angle(222) and is_(222, nat))) and (inv_Angle(44) and is_(44, nat)))","type compatibility obligation:((((inv_Angle(188) and is_(188, nat)) and (inv_Angle(70) and is_(70, nat))) and (inv_Angle(2) and is_(2, nat))) and (inv_Angle(44) and is_(44, nat)))","type compatibility obligation:((((inv_Angle(288) and is_(288, nat)) and (inv_Angle(170) and is_(170, nat))) and (inv_Angle(222) and is_(222, nat))) and (inv_Angle(44) and is_(44, nat)))","non-empty sequence obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e (missileInputs \u003c\u003e [])))","legal map application obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (curMis in set (dom missilePriority))))))","legal map application obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (lastMissile(magid) in set (dom missilePriority))))))","type compatibility obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (((is_(lastMissile(magid), \u003cMissileA\u003e) or is_(lastMissile(magid), \u003cMissileB\u003e)) or is_(lastMissile(magid), \u003cMissileC\u003e)) or is_(lastMissile(magid), \u003cNone\u003e))))))","legal map application obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (magid in set (dom lastMissile))))))","legal map application obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e (curMis in set (dom responseDB)))))","recursive function obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), newOutput, (lastMissile ++ {magid |-\u003e curMis}), (curTime + stepLength))))))","non-empty sequence obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (missileInputs \u003c\u003e []))))","recursive function obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))))","non-empty sequence obligation:(forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (missileInputs \u003c\u003e []))))","legal map application obligation:(forall curTime:nat, expOutput:Output, plan:Plan, magid:MagId \u0026 ((magid in set (dom expOutput)) \u003d\u003e (magid in set (dom expOutput))))","map compatible obligation:(forall curTime:nat, expOutput:Output, plan:Plan, magid:MagId \u0026 (forall ldom1 in set (dom {magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}), rdom2 in set (dom ({magid} \u003c-: expOutput)) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}(ldom1) \u003d ({magid} \u003c-: expOutput)(rdom2)))))","legal sequence application obligation:(forall output_l:seq of (OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (let mk_(-, t):OutputStep \u003d output_l(i) in (t \u003c\u003d curTime) \u003d\u003e (i in set (inds output_l)))))","legal sequence application obligation:(forall output_l:seq of (OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (i in set (inds output_l))))","legal sequence application obligation:(forall curTime:nat, response:seq of (Response) \u0026 let output:seq of (OutputStep) \u003d OutputAtTimeZero(response) in (forall i in set (inds output) \u0026 (i in set (inds output))))","non-empty sequence obligation:(forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in (absTimes \u003c\u003e []))","legal sequence application obligation:(forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 ((i - 1) in set (inds absTimes))))","legal sequence application obligation:(forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 (i in set (inds absTimes))))","non-empty sequence obligation:(forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","recursive function obligation:(forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (RespLen(ts) \u003e RespLen((tl ts)))))","non-empty sequence obligation:(forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","legal sequence application obligation:(forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e let mk_(f, t):Response \u003d (hd ts), ns:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes((tl ts)) in (forall i in set (inds ns) \u0026 (i in set (inds ns)))))"]