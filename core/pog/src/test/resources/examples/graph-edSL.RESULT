["type invariant satisfiable obligation:(exists mk_LineSegment(end1, end2):LineSegment \u0026 (end1 \u003c\u003e end2))","type invariant satisfiable obligation:(exists mk_Polygon(points):Polygon \u0026 ((len points) \u003e 2))","type invariant satisfiable obligation:(exists mk_Polyline(points):Polyline \u0026 ((len points) \u003e 1))","type invariant satisfiable obligation:(exists mk_Box(corner1, corner2):Box \u0026 (((corner1.xcoord) \u003c\u003e (corner2.xcoord)) and ((corner1.ycoord) \u003c\u003e (corner2.ycoord))))","type invariant satisfiable obligation:(exists mk_Text(frame, startpoint, string):Text \u0026 (((abs (((frame.corner1).ycoord) - ((frame.corner2).ycoord))) \u003e\u003d 20) and (point_within_box(startpoint, frame) and (((((frame.corner1).ycoord) \u003c ((frame.corner2).ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d ((frame.corner2).ycoord))) or ((((frame.corner1).ycoord) \u003e ((frame.corner2).ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d ((frame.corner1).ycoord)))))))","type invariant satisfiable obligation:(exists mk_Compound(frame, components):Compound \u0026 (forall obj in set (elems components) \u0026 object_within_box(obj, frame)))","legal sequence application obligation:(forall point:Point, polygon:Polygon \u0026 (forall index in set (inds (polygon.vertices)) \u0026 (index in set (inds (polygon.vertices)))))","legal sequence application obligation:(forall point:Point, polygon:Polygon \u0026 (forall index in set (inds (polygon.vertices)) \u0026 (((index mod (len (polygon.vertices))) + 1) in set (inds (polygon.vertices)))))","type compatibility obligation:(forall point:Point, polygon:Polygon \u0026 (forall index in set (inds (polygon.vertices)) \u0026 inv_LineSegment(mk_LineSegment((polygon.vertices)(index), (polygon.vertices)(((index mod (len (polygon.vertices))) + 1))))))","finite set obligation:(forall point:Point, polyline:Polyline \u0026 (exists finmap1:map (nat) to (nat1) \u0026 (forall i:nat1 \u0026 (((i in set (inds (polyline.vertices))) and (i \u003c\u003e (len (polyline.vertices)))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d i))))))","legal sequence application obligation:(forall point:Point, polyline:Polyline \u0026 (forall index in set {i | i:nat1 \u0026 ((i in set (inds (polyline.vertices))) and (i \u003c\u003e (len (polyline.vertices))))} \u0026 (index in set (inds (polyline.vertices)))))","legal sequence application obligation:(forall point:Point, polyline:Polyline \u0026 (forall index in set {i | i:nat1 \u0026 ((i in set (inds (polyline.vertices))) and (i \u003c\u003e (len (polyline.vertices))))} \u0026 ((index + 1) in set (inds (polyline.vertices)))))","type compatibility obligation:(forall point:Point, polyline:Polyline \u0026 (forall index in set {i | i:nat1 \u0026 ((i in set (inds (polyline.vertices))) and (i \u003c\u003e (len (polyline.vertices))))} \u0026 inv_LineSegment(mk_LineSegment((polyline.vertices)(index), (polyline.vertices)((index + 1))))))","type compatibility obligation:(forall circle:Circle, box:Box \u0026 (point_within_box(mk_Point((((circle.center).xcoord) + (circle.radius)), ((circle.center).ycoord)), box) \u003d\u003e ((((circle.center).xcoord) - (circle.radius)) \u003e\u003d 0)))","type compatibility obligation:(forall circle:Circle, box:Box \u0026 (point_within_box(mk_Point((((circle.center).xcoord) + (circle.radius)), ((circle.center).ycoord)), box) \u003d\u003e (point_within_box(mk_Point((((circle.center).xcoord) - (circle.radius)), ((circle.center).ycoord)), box) \u003d\u003e (point_within_box(mk_Point(((circle.center).xcoord), (((circle.center).ycoord) + (circle.radius))), box) \u003d\u003e ((((circle.center).ycoord) - (circle.radius)) \u003e\u003d 0)))))","type compatibility obligation:(forall ellipse:Ellipse, box:Box \u0026 (point_within_box(mk_Point((((ellipse.center).xcoord) + (ellipse.xradius)), ((ellipse.center).ycoord)), box) \u003d\u003e ((((ellipse.center).xcoord) - (ellipse.xradius)) \u003e\u003d 0)))","type compatibility obligation:(forall ellipse:Ellipse, box:Box \u0026 (point_within_box(mk_Point((((ellipse.center).xcoord) + (ellipse.xradius)), ((ellipse.center).ycoord)), box) \u003d\u003e (point_within_box(mk_Point((((ellipse.center).xcoord) - (ellipse.xradius)), ((ellipse.center).ycoord)), box) \u003d\u003e (point_within_box(mk_Point(((ellipse.center).xcoord), (((ellipse.center).ycoord) + (ellipse.yradius))), box) \u003d\u003e ((((ellipse.center).ycoord) - (ellipse.yradius)) \u003e\u003d 0)))))","function postcondition satisfiable obligation:(forall point:Point, vector:LineSegment \u0026 (exists newpoint:Point \u0026 post_copy_point(point, vector, newpoint)))","legal sequence application obligation:(forall points:seq1 of (Point), vector:LineSegment \u0026 (exists newpoints:seq1 of (Point) \u0026 (((len points) \u003d (len newpoints)) \u003d\u003e (forall i in set (inds points) \u0026 (i in set (inds newpoints))))))","legal sequence application obligation:(forall points:seq1 of (Point), vector:LineSegment \u0026 (exists newpoints:seq1 of (Point) \u0026 (((len points) \u003d (len newpoints)) \u003d\u003e (forall i in set (inds points) \u0026 (i in set (inds points))))))","function postcondition satisfiable obligation:(forall points:seq1 of (Point), vector:LineSegment \u0026 (exists newpoints:seq1 of (Point) \u0026 post_copy_points(points, vector, newpoints)))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e (is_(obj, Polygon) \u003d\u003e inv_Polygon(mk_Polygon(copy_points((obj.vertices), vector))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e (is_(obj, Polyline) \u003d\u003e inv_Polyline(mk_Polyline(copy_points((obj.vertices), vector)))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e (is_(obj, Box) \u003d\u003e inv_Box(mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Box) and (newobj \u003d mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))) \u003d\u003e (is_(obj, ArcBox) \u003d\u003e inv_Box(mk_Box(copy_point(((obj.box).corner1), vector), copy_point(((obj.box).corner2), vector)))))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Box) and (newobj \u003d mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))) \u003d\u003e ((not (is_(obj, ArcBox) and (newobj \u003d mk_ArcBox(mk_Box(copy_point(((obj.box).corner1), vector), copy_point(((obj.box).corner2), vector)), (obj.cornerradius))))) \u003d\u003e (is_(obj, Text) \u003d\u003e inv_Box(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector))))))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Box) and (newobj \u003d mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))) \u003d\u003e ((not (is_(obj, ArcBox) and (newobj \u003d mk_ArcBox(mk_Box(copy_point(((obj.box).corner1), vector), copy_point(((obj.box).corner2), vector)), (obj.cornerradius))))) \u003d\u003e (is_(obj, Text) \u003d\u003e inv_Text(mk_Text(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector)), copy_point((obj.startpoint), vector), (obj.string))))))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Box) and (newobj \u003d mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))) \u003d\u003e ((not (is_(obj, ArcBox) and (newobj \u003d mk_ArcBox(mk_Box(copy_point(((obj.box).corner1), vector), copy_point(((obj.box).corner2), vector)), (obj.cornerradius))))) \u003d\u003e ((not (is_(obj, Text) and (newobj \u003d mk_Text(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector)), copy_point((obj.startpoint), vector), (obj.string))))) \u003d\u003e (is_(obj, Compound) \u003d\u003e inv_Box(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector)))))))))))))","type compatibility obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 ((not (is_(obj, Circle) and (newobj \u003d mk_Circle(copy_point((obj.center), vector), (obj.radius))))) \u003d\u003e ((not (is_(obj, Ellipse) and (newobj \u003d mk_Ellipse(copy_point((obj.center), vector), (obj.xradius), (obj.yradius))))) \u003d\u003e ((not (is_(obj, Polygon) and (newobj \u003d mk_Polygon(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Polyline) and (newobj \u003d mk_Polyline(copy_points((obj.vertices), vector))))) \u003d\u003e ((not (is_(obj, Box) and (newobj \u003d mk_Box(copy_point((obj.corner1), vector), copy_point((obj.corner2), vector))))) \u003d\u003e ((not (is_(obj, ArcBox) and (newobj \u003d mk_ArcBox(mk_Box(copy_point(((obj.box).corner1), vector), copy_point(((obj.box).corner2), vector)), (obj.cornerradius))))) \u003d\u003e ((not (is_(obj, Text) and (newobj \u003d mk_Text(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector)), copy_point((obj.startpoint), vector), (obj.string))))) \u003d\u003e (is_(obj, Compound) \u003d\u003e inv_Compound(mk_Compound(mk_Box(copy_point(((obj.frame).corner1), vector), copy_point(((obj.frame).corner2), vector)), make_copy_objects((obj.components), vector)))))))))))))","function postcondition satisfiable obligation:(forall obj:Object, vector:LineSegment \u0026 (exists newobj:Object \u0026 post_make_copy_object(obj, vector, newobj)))","legal sequence application obligation:(forall objs:seq1 of (Object), vector:LineSegment \u0026 (exists newobjs:seq1 of (Object) \u0026 (((len newobjs) \u003d (len objs)) \u003d\u003e (forall i in set (inds objs) \u0026 (i in set (inds objs))))))","function postcondition satisfiable obligation:(forall objs:seq1 of (Object), vector:LineSegment \u0026 (exists newobjs:seq1 of (Object) \u0026 post_make_copy_objects(objs, vector, newobjs)))","operation postcondition satisfiable obligation:(forall center:Point, radius:nat1, oldstate:GraphEditor \u0026 (pre_create_circle(center, radius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_circle(center, radius, oldstate, msg, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall center:Point, xradius:nat1, yradius:nat1, oldstate:GraphEditor \u0026 (pre_create_ellipse(center, xradius, yradius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_ellipse(center, xradius, yradius, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Polygon(mk_Polygon(vertices))","type compatibility obligation:(polygon_within_box(mk_Polygon(vertices), DRAWING_AREA) \u003d\u003e inv_Polygon(mk_Polygon(vertices)))","operation postcondition satisfiable obligation:(forall vertices:seq1 of (Point), oldstate:GraphEditor \u0026 (pre_create_polygon(vertices, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_polygon(vertices, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Polyline(mk_Polyline(vertices))","type compatibility obligation:(polyline_within_box(mk_Polyline(vertices), DRAWING_AREA) \u003d\u003e inv_Polyline(mk_Polyline(vertices)))","operation postcondition satisfiable obligation:(forall vertices:seq1 of (Point), oldstate:GraphEditor \u0026 (pre_create_polyline(vertices, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_polyline(vertices, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Box(mk_Box(corner1, corner2))","type compatibility obligation:(box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) \u003d\u003e inv_Box(mk_Box(corner1, corner2)))","operation postcondition satisfiable obligation:(forall corner1:Point, corner2:Point, oldstate:GraphEditor \u0026 (pre_create_box(corner1, corner2, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_box(corner1, corner2, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Box(mk_Box(corner1, corner2))","type compatibility obligation:(box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) \u003d\u003e inv_Box(mk_Box(corner1, corner2)))","operation postcondition satisfiable obligation:(forall corner1:Point, corner2:Point, cornerradius:nat1, oldstate:GraphEditor \u0026 (pre_create_arcbox(corner1, corner2, cornerradius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_arcbox(corner1, corner2, cornerradius, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Box(mk_Box(corner1, corner2))","type compatibility obligation:(box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) \u003d\u003e (((abs ((corner1.ycoord) - (corner2.ycoord))) \u003e\u003d 20) \u003d\u003e inv_Box(mk_Box(corner1, corner2))))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (((abs ((corner1.ycoord) - (corner2.ycoord))) \u003e\u003d 20) and (point_within_box(startpoint, mk_Box(corner1, corner2)) and ((((corner1.ycoord) \u003c (corner2.ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d (corner2.ycoord))) or (((corner1.ycoord) \u003e (corner2.ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d (corner1.ycoord))))))) \u003d\u003e inv_Box(mk_Box(corner1, corner2)))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (((abs ((corner1.ycoord) - (corner2.ycoord))) \u003e\u003d 20) and (point_within_box(startpoint, mk_Box(corner1, corner2)) and ((((corner1.ycoord) \u003c (corner2.ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d (corner2.ycoord))) or (((corner1.ycoord) \u003e (corner2.ycoord)) and (((startpoint.ycoord) + ((len string) * 10)) \u003c\u003d (corner1.ycoord))))))) \u003d\u003e inv_Text(mk_Text(mk_Box(corner1, corner2), startpoint, string)))","operation postcondition satisfiable obligation:(forall corner1:Point, corner2:Point, startpoint:Point, string:seq of (char), oldstate:GraphEditor \u0026 (pre_create_text(corner1, corner2, startpoint, string, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_text(corner1, corner2, startpoint, string, oldstate, msg, oldstate, newstate))))","type compatibility obligation:inv_Box(mk_Box(corner1, corner2))","type compatibility obligation:(box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) \u003d\u003e (forall object in set (elems OBJECTS) \u0026 inv_Box(mk_Box(corner1, corner2))))","legal sequence application obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (object_within_box(OBJECTS~(i), mk_Box(corner1, corner2)) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 inv_Box(mk_Box(corner1, corner2))))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e is_([OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))], seq1 of (Object)))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e let components:seq1 of (Object) \u003d [OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))] in inv_Box(mk_Box(corner1, corner2)))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e let components:seq1 of (Object) \u003d [OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))] in inv_Compound(mk_Compound(mk_Box(corner1, corner2), components)))","legal sequence application obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e let components:seq1 of (Object) \u003d [OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))] in (forall i in set (inds OBJECTS~) \u0026 ((not object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e let components:seq1 of (Object) \u003d [OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))] in (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","type compatibility obligation:((box_within_box(mk_Box(corner1, corner2), DRAWING_AREA) and (exists object in set (elems OBJECTS) \u0026 object_within_box(object, mk_Box(corner1, corner2)))) \u003d\u003e let components:seq1 of (Object) \u003d [OBJECTS~(i) | i in set (inds OBJECTS~) \u0026 object_within_box(OBJECTS~(i), mk_Box(corner1, corner2))] in (forall i in set (inds OBJECTS~) \u0026 inv_Box(mk_Box(corner1, corner2))))","operation postcondition satisfiable obligation:(forall corner1:Point, corner2:Point, oldstate:GraphEditor \u0026 (pre_create_compound_object(corner1, corner2, oldstate) \u003d\u003e (exists msg:Message \u0026 post_create_compound_object(corner1, corner2, oldstate, msg, oldstate, newstate))))","type compatibility obligation:(point_within_box(click, DRAWING_AREA) \u003d\u003e ((object in set (elems OBJECTS)) \u003d\u003e (((((((is_(object, ArcBox) or (is_(object, Box) and (inv_Box(object) and is_(object, Box)))) or is_(object, Circle)) or (is_(object, Compound) and (inv_Compound(object) and is_(object, Compound)))) or is_(object, Ellipse)) or (is_(object, Polygon) and (inv_Polygon(object) and is_(object, Polygon)))) or (is_(object, Polyline) and (inv_Polyline(object) and is_(object, Polyline)))) or (is_(object, Text) and (inv_Text(object) and is_(object, Text))))))","finite set obligation:(point_within_box(click, DRAWING_AREA) \u003d\u003e ((object in set (elems OBJECTS)) \u003d\u003e (point_on_object(click, object) \u003d\u003e (exists finmap1:map (nat) to (nat1) \u0026 (forall index:nat1, j:nat1 \u0026 (((index in set (inds OBJECTS)) and ((index \u003c j) and (OBJECTS(j) \u003d object))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d index))))))))","legal sequence application obligation:(point_within_box(click, DRAWING_AREA) \u003d\u003e ((object in set (elems OBJECTS)) \u003d\u003e (point_on_object(click, object) \u003d\u003e (forall index:nat1, j:nat1 \u0026 ((index in set (inds OBJECTS)) \u003d\u003e ((index \u003c j) \u003d\u003e (j in set (inds OBJECTS))))))))","legal sequence application obligation:(point_within_box(click, DRAWING_AREA) \u003d\u003e ((object in set (elems OBJECTS)) \u003d\u003e (point_on_object(click, object) \u003d\u003e (forall i in set {index | index:nat1, j:nat1 \u0026 ((index in set (inds OBJECTS)) and ((index \u003c j) and (OBJECTS(j) \u003d object)))} \u0026 (i in set (inds OBJECTS))))))","operation postcondition satisfiable obligation:(forall click:Point, oldstate:GraphEditor \u0026 (pre_select_object(click, oldstate) \u003d\u003e (exists object:[Object] \u0026 post_select_object(click, oldstate, object, oldstate, newstate))))","legal sequence application obligation:((is_(object, Compound) and (object in set (elems OBJECTS))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e object) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:((is_(object, Compound) and (object in set (elems OBJECTS))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall object:Object, oldstate:GraphEditor \u0026 (pre_decompose_compound_object(object, oldstate) \u003d\u003e (exists msg:Message \u0026 post_decompose_compound_object(object, oldstate, msg, oldstate, newstate))))","legal sequence application obligation:((object in set (elems OBJECTS)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e object) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:((object in set (elems OBJECTS)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall object:Object, oldstate:GraphEditor \u0026 (pre_delete_object(object, oldstate) \u003d\u003e (exists newstate:GraphEditor \u0026 post_delete_object(object, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall object:Object, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_move_object(object, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_move_object(object, vector, oldstate, msg, oldstate, newstate))))","legal sequence application obligation:(((object in set (elems OBJECTS)) and ((not is_(object, Compound)) and object_within_box(make_copy_object(object, vector), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e object) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((object in set (elems OBJECTS)) and ((not is_(object, Compound)) and object_within_box(make_copy_object(object, vector), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall object:Object, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_move_simple_object(object, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_move_simple_object(object, vector, oldstate, msg, oldstate, newstate))))","legal sequence application obligation:(((compound in set (elems OBJECTS)) and object_within_box(make_copy_object((compound.frame), vector), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS) \u0026 ((OBJECTS(i) \u003c\u003e compound) \u003d\u003e (i in set (inds OBJECTS)))))","legal sequence application obligation:(((compound in set (elems OBJECTS)) and object_within_box(make_copy_object((compound.frame), vector), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS) \u0026 (i in set (inds OBJECTS))))","operation postcondition satisfiable obligation:(forall compound:Compound, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_move_compound_object(compound, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_move_compound_object(compound, vector, oldstate, msg, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall object:Object, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_copy_object(object, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_copy_object(object, vector, oldstate, msg, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall object:Object, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_copy_simple_object(object, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_copy_simple_object(object, vector, oldstate, msg, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall compound:Compound, vector:LineSegment, oldstate:GraphEditor \u0026 (pre_copy_compound_object(compound, vector, oldstate) \u003d\u003e (exists msg:Message \u0026 post_copy_compound_object(compound, vector, oldstate, msg, oldstate, newstate))))","legal sequence application obligation:(((circle in set (elems OBJECTS)) and circle_within_box(mk_Circle((circle.center), new_radius), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e circle) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((circle in set (elems OBJECTS)) and circle_within_box(mk_Circle((circle.center), new_radius), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall circle:Circle, new_radius:nat1, oldstate:GraphEditor \u0026 (pre_resize_circle(circle, new_radius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_circle(circle, new_radius, oldstate, msg, oldstate, newstate))))","legal sequence application obligation:(((ellipse in set (elems OBJECTS)) and ellipse_within_box(mk_Ellipse((ellipse.center), new_xradius, new_yradius), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e ellipse) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((ellipse in set (elems OBJECTS)) and ellipse_within_box(mk_Ellipse((ellipse.center), new_xradius, new_yradius), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall ellipse:Ellipse, new_xradius:nat1, new_yradius:nat1, oldstate:GraphEditor \u0026 (pre_resize_ellipse(ellipse, new_xradius, new_yradius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_ellipse(ellipse, new_xradius, new_yradius, oldstate, msg, oldstate, newstate))))","type compatibility obligation:((polygon in set (elems OBJECTS)) \u003d\u003e (((len new_vertices) \u003d (len (polygon.vertices))) \u003d\u003e inv_Polygon(mk_Polygon(new_vertices))))","type compatibility obligation:(((polygon in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polygon.vertices))) and polygon_within_box(mk_Polygon(new_vertices), DRAWING_AREA))) \u003d\u003e inv_Polygon(mk_Polygon(new_vertices)))","legal sequence application obligation:(((polygon in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polygon.vertices))) and polygon_within_box(mk_Polygon(new_vertices), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e polygon) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((polygon in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polygon.vertices))) and polygon_within_box(mk_Polygon(new_vertices), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall polygon:Polygon, new_vertices:seq1 of (Point), oldstate:GraphEditor \u0026 (pre_resize_polygon(polygon, new_vertices, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_polygon(polygon, new_vertices, oldstate, msg, oldstate, newstate))))","type compatibility obligation:((polyline in set (elems OBJECTS)) \u003d\u003e (((len new_vertices) \u003d (len (polyline.vertices))) \u003d\u003e inv_Polyline(mk_Polyline(new_vertices))))","type compatibility obligation:(((polyline in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polyline.vertices))) and polyline_within_box(mk_Polyline(new_vertices), DRAWING_AREA))) \u003d\u003e inv_Polyline(mk_Polyline(new_vertices)))","legal sequence application obligation:(((polyline in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polyline.vertices))) and polyline_within_box(mk_Polyline(new_vertices), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e polyline) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((polyline in set (elems OBJECTS)) and (((len new_vertices) \u003d (len (polyline.vertices))) and polyline_within_box(mk_Polyline(new_vertices), DRAWING_AREA))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall polyline:Polyline, new_vertices:seq1 of (Point), oldstate:GraphEditor \u0026 (pre_resize_polyline(polyline, new_vertices, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_polyline(polyline, new_vertices, oldstate, msg, oldstate, newstate))))","type compatibility obligation:((box in set (elems OBJECTS)) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","type compatibility obligation:(((box in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","legal sequence application obligation:(((box in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e box) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((box in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall box:Box, new_corner1:Point, new_corner2:Point, oldstate:GraphEditor \u0026 (pre_resize_box(box, new_corner1, new_corner2, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_box(box, new_corner1, new_corner2, oldstate, msg, oldstate, newstate))))","type compatibility obligation:((arcbox in set (elems OBJECTS)) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","type compatibility obligation:(((arcbox in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","legal sequence application obligation:(((arcbox in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e arcbox) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((arcbox in set (elems OBJECTS)) and box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA)) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall arcbox:ArcBox, new_corner1:Point, new_corner2:Point, new_corner_radius:nat1, oldstate:GraphEditor \u0026 (pre_resize_arcbox(arcbox, new_corner1, new_corner2, new_corner_radius, oldstate) \u003d\u003e (exists msg:Message \u0026 post_resize_arcbox(arcbox, new_corner1, new_corner2, new_corner_radius, oldstate, msg, oldstate, newstate))))","type compatibility obligation:((text in set (elems OBJECTS)) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","type compatibility obligation:((text in set (elems OBJECTS)) \u003d\u003e (box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA) \u003d\u003e (((abs ((new_corner1.ycoord) - (new_corner2.ycoord))) \u003e\u003d 20) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))))","type compatibility obligation:(((text in set (elems OBJECTS)) and (box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA) and (((abs ((new_corner1.ycoord) - (new_corner2.ycoord))) \u003e\u003d 20) and (point_within_box(new_start_point, mk_Box(new_corner1, new_corner2)) and ((((new_corner1.ycoord) \u003c (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner2.ycoord))) or (((new_corner1.ycoord) \u003e (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner1.ycoord)))))))) \u003d\u003e inv_Box(mk_Box(new_corner1, new_corner2)))","type compatibility obligation:(((text in set (elems OBJECTS)) and (box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA) and (((abs ((new_corner1.ycoord) - (new_corner2.ycoord))) \u003e\u003d 20) and (point_within_box(new_start_point, mk_Box(new_corner1, new_corner2)) and ((((new_corner1.ycoord) \u003c (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner2.ycoord))) or (((new_corner1.ycoord) \u003e (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner1.ycoord)))))))) \u003d\u003e inv_Text(mk_Text(mk_Box(new_corner1, new_corner2), new_start_point, new_string)))","legal sequence application obligation:(((text in set (elems OBJECTS)) and (box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA) and (((abs ((new_corner1.ycoord) - (new_corner2.ycoord))) \u003e\u003d 20) and (point_within_box(new_start_point, mk_Box(new_corner1, new_corner2)) and ((((new_corner1.ycoord) \u003c (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner2.ycoord))) or (((new_corner1.ycoord) \u003e (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner1.ycoord)))))))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 ((OBJECTS~(i) \u003c\u003e text) \u003d\u003e (i in set (inds OBJECTS~)))))","legal sequence application obligation:(((text in set (elems OBJECTS)) and (box_within_box(mk_Box(new_corner1, new_corner2), DRAWING_AREA) and (((abs ((new_corner1.ycoord) - (new_corner2.ycoord))) \u003e\u003d 20) and (point_within_box(new_start_point, mk_Box(new_corner1, new_corner2)) and ((((new_corner1.ycoord) \u003c (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner2.ycoord))) or (((new_corner1.ycoord) \u003e (new_corner2.ycoord)) and (((new_start_point.ycoord) + ((len new_string) * 10)) \u003c\u003d (new_corner1.ycoord)))))))) \u003d\u003e (forall i in set (inds OBJECTS~) \u0026 (i in set (inds OBJECTS~))))","operation postcondition satisfiable obligation:(forall text:Text, new_corner1:Point, new_corner2:Point, new_start_point:Point, new_string:seq of (char), oldstate:GraphEditor \u0026 (pre_edit_text(text, new_corner1, new_corner2, new_start_point, new_string, oldstate) \u003d\u003e (exists msg:Message \u0026 post_edit_text(text, new_corner1, new_corner2, new_start_point, new_string, oldstate, msg, oldstate, newstate))))"]