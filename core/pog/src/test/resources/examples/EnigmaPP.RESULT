["state invariant holds obligation:(forall pa:seq of (char) \u0026 (AlphabetInv(pa) \u003d\u003e AlphabetInv(alph)))","legal sequence application obligation:(forall pidx:nat \u0026 ((pidx in set (inds alph)) \u003d\u003e (pidx in set (inds alph))))","let be st existence obligation:(forall pch:char \u0026 ((pch in set (elems alph)) \u003d\u003e (exists pidx in set {i | i in set (inds alph) \u0026 (alph(i) \u003d pch)} \u0026 null)))","legal sequence application obligation:(forall pch:char \u0026 ((pch in set (elems alph)) \u003d\u003e (forall i in set (inds alph) \u0026 (i in set (inds alph)))))","type compatibility obligation:(forall pidx:nat, poffset:nat \u0026 (((pidx in set (inds alph)) and (poffset \u003c\u003d (len alph))) \u003d\u003e (RESULT \u003e\u003d 0)))","operation call obligation:(forall pidx:nat \u0026 ((pidx in set (inds alph)) and (pidx \u003c\u003d (len alph))))","legal sequence application obligation:(i in set (inds str))","legal sequence application obligation:(i in set (inds str))","legal map application obligation:(forall penc:nat \u0026 (penc in set (dom config)))","map inverse obligation:(forall pdec:nat \u0026 is_(config, inmap (nat) to (nat)))","legal map application obligation:(forall pdec:nat \u0026 (pdec in set (dom invcfg)))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","state invariant holds obligation:(forall pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((((dom pcfg) inter (rng pcfg)) \u003d {}) and PlugboardInv(pcfg, pa)) \u003d\u003e PlugboardInv(config, alph)))","operation call obligation:(forall pidx:nat \u0026 (((pidx in set (alph.GetIndices)()) and (isofclass(Rotor,next) or isofclass(Reflector,next))) \u003d\u003e (next \u003c\u003e nil)))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {2 |-\u003e 1}, {3 |-\u003e 4}, {4 |-\u003e 3}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","state invariant holds obligation:(forall psp:nat, pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((psp in set (pa.GetIndices)()) and ReflectorInv(next, pcfg, pa)) \u003d\u003e ReflectorInv(next, config, alph)))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall platch_pos:nat, pconfig:inmap (nat) to (nat), palph:Alphabet \u0026 let ainds:set of (nat) \u003d (palph.GetIndices)() in ((platch_pos in set ainds) \u003d\u003e (((dom pconfig) \u003d ainds) \u003d\u003e (((rng pconfig) \u003d ainds) \u003d\u003e (forall x in set (dom pconfig) \u0026 (x in set (dom pconfig)))))))","state invariant holds obligation:(forall psp:nat, plp:nat, pa:Alphabet, pcfg:inmap (nat) to (nat) \u0026 (((psp in set (pa.GetIndices)()) and RotorInv(plp, pcfg, pa)) \u003d\u003e RotorInv(latch_pos, config, alph)))","state invariant holds obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(latch_pos, config, alph)))","state invariant holds obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(latch_pos, config, alph)))","state invariant holds obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(latch_pos, config, alph)))","comprehension map injectivity obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (forall m1, m2 in set {{(alph.Shift)(i) |-\u003e (alph.Shift)(config(i))} | i in set (dom config)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (forall i in set (dom config) \u0026 (i in set (dom config))))","type compatibility obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e is_({(alph.Shift)(i) |-\u003e (alph.Shift)(config(i)) | i in set (dom config)}, inmap (nat) to (nat)))","state invariant holds obligation:((isofclass(Rotor,next) or isofclass(Reflector,next)) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(latch_pos, config, alph)))","operation call obligation:(forall ppos:nat \u0026 ((ppos in set (alph.GetIndices)()) \u003d\u003e (isofclass(Rotor,next) or isofclass(Reflector,next))))","state invariant holds obligation:(forall ppos:nat \u0026 ((ppos in set (alph.GetIndices)()) \u003d\u003e (forall latch_pos1:nat, latch_lock2:bool \u0026 (RotorInv(latch_pos, config, alph) \u003d\u003e (RotorInv(latch_pos, config, alph) \u003d\u003e RotorInv(latch_pos, config, alph))))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 1}, {2 |-\u003e 3}, {3 |-\u003e 2}, {4 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 3}, {2 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e 2}, {2 |-\u003e 4}, {3 |-\u003e 3}, {4 |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]