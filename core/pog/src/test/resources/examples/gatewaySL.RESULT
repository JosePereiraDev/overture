["type invariant satisfiable obligation:(exists s:String \u0026 (s \u003c\u003e []))","type invariant satisfiable obligation:(exists m:Message \u0026 ((len m) \u003c\u003d 100))","recursive function obligation:(forall ms:seq of (Message), cat:Category \u0026 ((not (ms \u003d [])) \u003d\u003e (MesLen(ms, cat) \u003e MesLen((tl ms), cat))))","non-empty sequence obligation:(forall ms:seq of (Message), cat:Category \u0026 ((not (ms \u003d [])) \u003d\u003e (ms \u003c\u003e [])))","non-empty sequence obligation:(forall ms:seq of (Message), cat:Category \u0026 ((not (ms \u003d [])) \u003d\u003e let rest_p:Ports \u003d Gateway((tl ms), cat) in (ms \u003c\u003e [])))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 ((Classify(ms(i), cat) \u003d \u003cHI\u003e) \u003d\u003e (i in set (inds ms)))))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 (i in set (inds ms))))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 ((Classify(ms(i), cat) \u003d \u003cLO\u003e) \u003d\u003e (i in set (inds ms)))))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 (i in set (inds ms))))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 ((Classify(ms(i), cat) \u003d \u003cLO\u003e) \u003d\u003e (i in set (inds ms)))))","legal sequence application obligation:(forall ms:seq of (Message), cat:Category \u0026 (forall i in set (inds ms) \u0026 (i in set (inds ms))))","type compatibility obligation:(forall ms:seq of (Message) \u0026 (((len (conc ms)) \u003c\u003d 100) \u003d\u003e (inv_Message((conc ms)) and (inv_String((conc ms)) and is_((conc ms), seq of (char))))))"]