["recursive function obligation:(forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e (Len(l) \u003e Len((tl l)))))","non-empty sequence obligation:(forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e (l \u003c\u003e [])))","non-empty sequence obligation:(forall l:seq of (int) \u0026 ((not (l \u003d [])) \u003d\u003e let sorted:seq of (int) \u003d DoSorting((tl l)) in (l \u003c\u003e [])))","non-empty sequence obligation:(forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (l \u003c\u003e []))))","recursive function obligation:(forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (Len(i, l) \u003e Len(i, (tl l))))))","non-empty sequence obligation:(forall i:int, l:seq of (int) \u0026 ((not ((l \u003d []) \u003d true)) \u003d\u003e ((not ((i \u003c\u003d (hd l)) \u003d true)) \u003d\u003e (l \u003c\u003e []))))","let be st existence obligation:(forall l:seq of (int) \u0026 (exists r in set Permutations(l) \u0026 IsOrdered(r)))","legal sequence application obligation:(forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (forall j in set Permutations(RestSeq(l, i)) \u0026 (i in set (inds l)))))))","recursive function obligation:(forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (Len(l) \u003e Len(RestSeq(l, i)))))))","legal function application obligation:(forall l:seq of (int) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (int) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 pre_RestSeq(l, i)))))","function establishes postcondition obligation:(forall l:seq of (int), i:nat \u0026 (pre_RestSeq(l, i) \u003d\u003e post_RestSeq(l, i, [l(j) | j in set ((inds l) \\ {i})])))","legal sequence application obligation:(forall l:seq of (int), i:nat \u0026 ((i in set (inds l)) \u003d\u003e (forall j in set ((inds l) \\ {i}) \u0026 (j in set (inds l)))))","legal sequence application obligation:(forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds l)))))","legal sequence application obligation:(forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (j in set (inds l)))))","function postcondition satisfiable obligation:(forall l:seq of (int) \u0026 (exists r:seq of (int) \u0026 post_ImplSorter(l, r)))","legal sequence application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 (forall e in set ((elems l1) union (elems l2)) \u0026 (forall i in set (inds l1) \u0026 (i in set (inds l1)))))","legal sequence application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 (forall e in set ((elems l1) union (elems l2)) \u0026 (forall i in set (inds l2) \u0026 (i in set (inds l2)))))","legal sequence application obligation:(forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds l)))))","legal sequence application obligation:(forall l:seq of (int) \u0026 (forall i, j in set (inds l) \u0026 ((i \u003e j) \u003d\u003e (j in set (inds l)))))","type compatibility obligation:(forall l:seq of (int) \u0026 is_(RESULT, seq of (int)))","let be st existence obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (exists l1 ^ l2 in set {l} \u0026 ((abs ((len l1) - (len l2))) \u003c 2)))))","recursive function obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e (Len(l) \u003e Len(l1)))))))","recursive function obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e (Len(l) \u003e Len(l2)))))))","legal function application obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in pre_Merge(l_l, l_r))))))","type compatibility obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in is_(l_l, seq of (int)))))))","type compatibility obligation:(forall l:seq of (real) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [e]:seq of (real) \u0026 ([e] \u003d l))) \u003d\u003e (forall l1 ^ l2 in set {l} \u0026 (((abs ((len l1) - (len l2))) \u003c 2) \u003d\u003e let l_l:seq of (real) \u003d MergeSorter(l1), l_r:seq of (real) \u003d MergeSorter(l2) in is_(l_r, seq of (int)))))))","legal sequence application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 (forall i in set (inds l1) \u0026 (i in set (inds l1))))","legal sequence application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 (forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) \u003d\u003e (forall i in set (inds l2) \u0026 (i in set (inds l2))))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (l1 \u003c\u003e [])))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (l2 \u003c\u003e [])))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (l1 \u003c\u003e []))))))","legal function application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e pre_Merge((tl l1), l2))))))","recursive function obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (Len(l1, l2) \u003e Len((tl l1), l2)))))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e (((hd l1) \u003c\u003d (hd l2)) \u003d\u003e (l1 \u003c\u003e []))))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (l2 \u003c\u003e []))))))","legal function application obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e pre_Merge(l1, (tl l2)))))))","recursive function obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (Len(l1, l2) \u003e Len(l1, (tl l2))))))))","non-empty sequence obligation:(forall l1:seq of (int), l2:seq of (int) \u0026 ((forall i in set (inds l1) \u0026 ((l1(i) \u003e\u003d 0) and (forall i in set (inds l2) \u0026 (l2(i) \u003e\u003d 0)))) \u003d\u003e ((not (exists mk_([], l):(seq of (int) * seq of (int)) \u0026 (mk_([], l) \u003d mk_(l1, l2)))) \u003d\u003e ((not (exists mk_(l, []):(seq of (int) * seq of (int)) \u0026 (mk_(l, []) \u003d mk_(l1, l2)))) \u003d\u003e ((not ((hd l1) \u003c\u003d (hd l2))) \u003d\u003e (l2 \u003c\u003e []))))))"]