["type invariant satisfiable obligation:(exists num:TargetTemp \u0026 (num \u003c\u003d 100))","type invariant satisfiable obligation:(exists num:CurrentTemp \u0026 (num \u003c\u003d 100))","type invariant satisfiable obligation:(exists num:TargetHumid \u0026 (num \u003c\u003d 100))","type invariant satisfiable obligation:(exists num:CurrentHumid \u0026 (num \u003c\u003d 100))","non-empty sequence obligation:(forall haInputs:HAInputs, outputSoFar:HAOut, curTime:nat \u0026 ((not (haInputs \u003d [])) \u003d\u003e (haInputs \u003c\u003e [])))","non-empty sequence obligation:(forall haInputs:HAInputs, outputSoFar:HAOut, curTime:nat \u0026 ((not (haInputs \u003d [])) \u003d\u003e (haInputs \u003c\u003e [])))","legal sequence application obligation:(forall haInputs:HAInputs, outputSoFar:HAOut, curTime:nat \u0026 ((not (haInputs \u003d [])) \u003d\u003e let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid):HAInput \u003d (hd haInputs), rest:HAInputs \u003d (tl haInputs), nextTime:nat \u003d (curTime + StepLength) in ((outputSoFar \u003c\u003e []) \u003d\u003e ((len outputSoFar) in set (inds outputSoFar)))))","non-empty sequence obligation:(forall haInputs:HAInputs, outputSoFar:HAOut, curTime:AbsTime \u0026 (haInputs \u003c\u003e []))","non-empty sequence obligation:(forall haInputs:HAInputs, outputSoFar:HAOut, curTime:AbsTime \u0026 (haInputs \u003c\u003e []))","non-zero obligation:(forall targetTemp:nat, curTemp:nat, targetHumid:nat, curHumid:nat, curTime:nat, outputSoFar:seq of (OutStep) \u0026 (TempChangeDuration \u003c\u003e 0))","type compatibility obligation:(forall targetTemp:nat, curTemp:nat, targetHumid:nat, curHumid:nat, curTime:nat, outputSoFar:seq of (OutStep) \u0026 is_(let tempChanged:real \u003d (((curHumid - targetHumid) * HumidChangeDuration) / TempChangeDuration), action:(\u003cDecTemp\u003e | \u003cIncTemp\u003e) \u003d (if ((curTemp - tempChanged) \u003e targetTemp)\nthen \u003cDecTemp\u003e\nelse \u003cIncTemp\u003e), timeChange:int \u003d (curTime + ((curHumid - targetHumid) * HumidChangeDuration)) in ((outputSoFar ^ [mk_(\u003cOpenWindow\u003e, curTime)]) ^ (if ((curTemp - tempChanged) \u003c\u003e targetTemp)\nthen [mk_(\u003cCloseWindow\u003e, timeChange), mk_(action, timeChange), mk_(\u003cLeaveTemp\u003e, (timeChange + (((abs (curTemp - targetTemp)) - tempChanged) * TempChangeDuration)))]\nelse [mk_(\u003cCloseWindow\u003e, timeChange)])), seq of (OutStep)))","legal sequence application obligation:(forall output:seq of (OutStep), curTime:nat \u0026 (forall i in set (inds output) \u0026 (let mk_(-, t):OutStep \u003d output(i) in (t \u003c\u003d curTime) \u003d\u003e (i in set (inds output)))))","legal sequence application obligation:(forall output:seq of (OutStep), curTime:nat \u0026 (forall i in set (inds output) \u0026 (i in set (inds output))))","legal sequence application obligation:(forall output:seq of (OutStep), curTime:nat \u0026 ((len output) in set (inds output)))"]