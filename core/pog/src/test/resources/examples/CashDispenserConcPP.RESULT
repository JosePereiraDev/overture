["state invariant holds obligation:(forall cs:map (CardId) to (Cardholder), b:nat \u0026 TransactionsInvariant(transactions))","state invariant holds obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","type compatibility obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e ((balance - amount) \u003e\u003d 0)))","state invariant holds obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","legal map application obligation:(forall cardId:CardId, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (cardId in set (dom cards))))","legal map application obligation:(forall cardId:CardId, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (cardId in set (dom cards))))","state invariant holds obligation:(forall cId:CardId, ch:Cardholder \u0026 ((cId not in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","map compatible obligation:(forall cId:CardId, ch:Cardholder \u0026 ((cId not in set (dom cards)) \u003d\u003e (forall ldom1 in set (dom cards), rdom2 in set (dom {cId |-\u003e ch}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (cards(ldom1) \u003d {cId |-\u003e ch}(rdom2))))))","legal sequence application obligation:(forall ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (((ts(i).date) \u003d date) \u003d\u003e (i in set (inds ts)))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","type compatibility obligation:(forall date:Date, ts:seq of (Transaction) \u0026 is_(Sum([(ts(i).amount) | i in set (inds ts) \u0026 ((ts(i).date) \u003d date)]), nat))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))","state invariant holds obligation:(forall c:Clock, l:Letterbox \u0026 (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))","legal map application obligation:(forall accountId:AccountId, cardId:CardId \u0026 (accountId in set (dom accounts)))","legal map application obligation:(forall accountId:AccountId, cardId:CardId \u0026 ((cardId not in set illegalCards) \u003d\u003e ((accountId in set (dom accounts)) \u003d\u003e (accountId in set (dom accounts)))))","legal map application obligation:(forall cardId:CardId \u0026 (cardId in set (dom numberOfTries)))","state invariant holds obligation:(forall cardId:CardId \u0026 ((forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))) \u003d\u003e (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))))","state invariant holds obligation:(forall cardId:CardId \u0026 ((forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))) \u003d\u003e (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))))","legal map application obligation:(forall cardId:CardId \u0026 (cardId in set (dom numberOfTries)))","state invariant holds obligation:(forall accId:AccountId, acc:Account \u0026 ((accId not in set (dom accounts)) \u003d\u003e ((forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))) \u003d\u003e (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","comprehension map injectivity obligation:(forall accId:AccountId, acc:Account \u0026 ((accId not in set (dom accounts)) \u003d\u003e (forall m1, m2 in set {{cId |-\u003e 0} | cId in set (acc.GetCardIds)()} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","state invariant holds obligation:(forall accId:AccountId, acc:Account \u0026 ((accId not in set (dom accounts)) \u003d\u003e ((forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))) \u003d\u003e (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","state invariant holds obligation:(forall cId:CardId \u0026 ((forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))) \u003d\u003e (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))))","type compatibility obligation:is_(RESULT, Request)","legal sequence application obligation:((statements \u003c\u003e []) \u003d\u003e ((len statements) in set (inds statements)))","type compatibility obligation:(forall accountId:AccountId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e (is_(RESULT, \u003cFail\u003e) or is_(RESULT, [nat])))))","type compatibility obligation:(forall accountId:AccountId, cardId:CardId, amount:nat \u0026 (forall c1:Channel \u0026 (true \u003d\u003e (is_(RESULT, \u003cFail\u003e) or is_(RESULT, bool)))))","type compatibility obligation:(forall accountId:AccountId, cardId:CardId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e (is_(RESULT, \u003cFail\u003e) or is_(RESULT, bool)))))","type compatibility obligation:(forall accountId:AccountId, cardId:CardId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e (is_(RESULT, \u003cFail\u003e) or is_(RESULT, bool)))))","type compatibility obligation:(forall cardId:CardId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e (is_(RESULT, \u003cFail\u003e) or is_(RESULT, bool)))))","type compatibility obligation:(forall cardId:CardId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e is_(RESULT, [\u003cFail\u003e]))))","type compatibility obligation:(forall cardId:CardId \u0026 (forall c1:Channel \u0026 (true \u003d\u003e is_(RESULT, [\u003cFail\u003e]))))","state invariant holds obligation:(forall res:LocalResource \u0026 ((curCard \u003d nil) \u003d\u003e (not cardOk)))","state invariant holds obligation:(forall res:LocalResource \u0026 (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not cardOk))))","state invariant holds obligation:(forall c:Card \u0026 ((not CardInside()) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((c \u003d nil) \u003d\u003e (not cardOk)))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","type compatibility obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (codeOk \u003d\u003e is_(cardLegal, bool))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","type compatibility obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e is_((retainedCards union {curCard}), set of (Card))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","type compatibility obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e is_((retainedCards union {curCard}), set of (Card))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false)))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not false)) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false)))))","state invariant holds obligation:(CardInside() \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not false))))","state invariant holds obligation:(CardInside() \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not false)) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false))))","enumeration map injectivity obligation:(forall m1, m2 in set {{0 |-\u003e \u00270\u0027}, {1 |-\u003e \u00271\u0027}, {2 |-\u003e \u00272\u0027}, {3 |-\u003e \u00273\u0027}, {4 |-\u003e \u00274\u0027}, {5 |-\u003e \u00275\u0027}, {6 |-\u003e \u00276\u0027}, {7 |-\u003e \u00277\u0027}, {8 |-\u003e \u00278\u0027}, {9 |-\u003e \u00279\u0027}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((n \u003c 10) \u003d\u003e (n in set (dom nat2char)))))","type compatibility obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003c 10)) \u003d\u003e ((n div 10) \u003e\u003d 0))))","legal map application obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003c 10)) \u003d\u003e ((n mod 10) in set (dom nat2char)))))","type compatibility obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e ((not (n \u003c 10)) \u003d\u003e ((n mod 10) \u003e\u003d 0))))","legal map application obligation:(forall tid:TillId \u0026 (tid in set (dom tills)))","enumeration map injectivity obligation:(forall m1, m2 in set {{5 |-\u003e peter}, {6 |-\u003e sten}, {7 |-\u003e CSK}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e SetupTill(1, new Till())}, {2 |-\u003e SetupTill(2, new Till())}, {3 |-\u003e SetupTill(3, new Till())}, {4 |-\u003e SetupTill(4, new Till())}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall tillNum:nat \u0026 (tillNum in set (dom tills)))","legal sequence application obligation:(forall tillNum:nat, cardNum:nat, pin:nat \u0026 ((tillNum in set (dom tills)) \u003d\u003e (cardNum in set (inds cards))))","legal map application obligation:(forall tillNum:nat, cardNum:nat, pin:nat \u0026 ((tillNum in set (dom tills)) \u003d\u003e (tillNum in set (dom tills))))","legal map application obligation:(forall tillNum:nat, amount:nat \u0026 (tillNum in set (dom tills)))","legal map application obligation:(forall tillNum:nat \u0026 (tillNum in set (dom tills)))","type compatibility obligation:(forall tillNum:nat \u0026 is_(bal1, nat))"]