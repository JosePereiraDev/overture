["function establishes postcondition obligation:(forall p:Point \u0026 post_around(p, {mk_Point(((p.x) + x), ((p.y) + y)) | x, y in set {-1, 0, (+ 1)} \u0026 ((x \u003c\u003e 0) or (y \u003c\u003e 0))}))","function establishes postcondition obligation:(forall pop:Population, p:Point \u0026 post_neighbourCount(pop, p, (card {q | q in set around(p) \u0026 (q in set pop)})))","function establishes postcondition obligation:(forall pop:Population \u0026 post_newCells(pop, (dunion {{q | q in set around(p) \u0026 ((q not in set pop) and (neighbourCount(pop, q) \u003d GENERATE))} | p in set pop})))","function establishes postcondition obligation:(forall pop:Population \u0026 post_deadCells(pop, {p | p in set pop \u0026 (neighbourCount(pop, p) not in set SURVIVE)}))","type compatibility obligation:(forall n:nat1, pop:Population \u0026 let new_p:Population \u003d generation(pop) in ((not (n \u003d 1)) \u003d\u003e ((n - 1) \u003e 0)))","recursive function obligation:(forall n:nat1, pop:Population \u0026 let new_p:Population \u003d generation(pop) in ((not (n \u003d 1)) \u003d\u003e (measureGenerations(n, pop) \u003e measureGenerations((n - 1), new_p))))","legal function application obligation:(forall pop:Population, n:nat1 \u0026 pre_((generation ** n)pop))","legal function application obligation:(forall pop:Population, n:nat1 \u0026 pre_((generation ** n)pop))","legal function application obligation:(forall pop:Population, n:nat1, max:nat1 \u0026 pre_((generation ** n)pop))","type compatibility obligation:(forall pop:Population, n:nat1 \u0026 (forall a in set {1, ... ,n} \u0026 (a \u003e 0)))","type compatibility obligation:(forall pop:Population, n:nat1 \u0026 (forall a in set {1, ... ,n} \u0026 (a \u003e 0)))","type compatibility obligation:(forall pop:Population, n:nat1, max:nat1 \u0026 (forall a in set {1, ... ,n} \u0026 (a \u003e 0)))","type compatibility obligation:(forall n:nat1, conf:Configuration \u0026 ((conf.gridSide) \u003e 0))","type compatibility obligation:(forall n:nat1, conf:Configuration \u0026 ((conf.sleepTime) \u003e 0))","non-empty sequence obligation:(forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e (pop \u003c\u003e [])))","recursive function obligation:(forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e let -:set of (int) \u003d {newLivingCell((cell.x), (cell.y)) | cell in set (hd pop)} in let -:int \u003d newRound() in (measure_animate_step(pop) \u003e measure_animate_step((tl pop)))))","non-empty sequence obligation:(forall pop:seq of (Population) \u0026 ((not (pop \u003d [])) \u003d\u003e let -:set of (int) \u003d {newLivingCell((cell.x), (cell.y)) | cell in set (hd pop)} in let -:int \u003d newRound() in (pop \u003c\u003e [])))"]