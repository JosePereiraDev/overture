
class IO

--  Overture STANDARD LIBRARY: INPUT/OUTPUT
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customizable. 
-- Don't care's may NOT be used in the parameter lists.
--
-- The in/out functions  will return false if an error occurs. In this
-- case an internal error string will be set (see 'ferror').
--
-- File path:
--  * An absolute path is accepted and used as specified.
--  * A relative path is relative to the debugger or if running in the 
--      Overture IDE relative to the project root.
--

types
 
/**
 * The file directive used in in/out functions.
 */
public filedirective = <start>|<append> 

functions

/**
 * Write VDM value in ASCII format to the console.
 *
 * @param val the VDM value to be written
 * @return true if successful else false
 */
public static writeval[@p]: @p -> bool
writeval(val)==
  is not yet specified;

/**
 * Write VDM value in ASCII format to file. The type of the val must be
 * specified as fwriteval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @param val the VDM value to be written.
 * @param fdir if <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file
 * @return true if successful else false
 */
public static fwriteval[@p]:seq1 of char * @p * filedirective -> bool
fwriteval(filename,val,fdir) ==
  is not yet specified;

/**
 * Read VDM value in ASCII format from file. The type which should be read must be
 * specified as freadval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @return mk_(success,@p) if successful success will be 
 * set to true else false. @p will hold nil if unsuccessful or the value read.
 */
public static freadval[@p]:seq1 of char -> bool * [@p]
freadval(filename) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

operations

/**
 * Write text to std out. Surrounding double quotes will be stripped,
 * backslashed characters should be interpreted.
 *
 * @param text the text to write to the console
 * @return if successful true else false.
 */
public echo: seq of char ==> bool
echo(text) ==
  fecho ("",text,nil);

/**
 * Write text to file like <code>echo</code>.
 *
 * @param filename the name of the file
 * @param text the text to write to be written.
 * @param fdir if nil or <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file.
 * @return true if successful else false
 */
public fecho: seq of char * seq of char * [filedirective] ==> bool
fecho (filename,text,fdir) ==
  is not yet specified
  pre filename = "" <=> fdir = nil;

/**
 * Returns the last error which may have occurred by any of the io/out functions
 *
 * @return the last error message
 */
public ferror:()  ==> seq of char
ferror () ==
  is not yet specified;
  
-- New simplified format printing operations


/**
 * Prints any VDM value to the console
 *
 * @param arg a VDM value of any type
 */
public static print: ? ==> ()
print(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console as a new line
 *
 * @param arg a VDM value of any type
 */
public static println: ? ==> ()
println(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console
 *
 * @param format standard format string used in 
  *  Java by <code>String.format(format,value)</code>
 * @param arg a sequence of VDM values of any type
 */
public static printf: seq of char * seq of ? ==> ()
printf(format, args) ==
    is not yet specified;

end IO

class MMI

operations
  async 
  public HandleKeyPress: nat ==> ()
  HandleKeyPress (pn) ==
    ( cycles (1E5) skip;
      --duration (1E5) skip;
      cases (pn):
        1 -> RadNavSys`radio.AdjustVolumeUp(),
        2 -> RadNavSys`radio.AdjustVolumeDown(),
        3 -> RadNavSys`navigation.DatabaseLookup()
      end ); 

  async 
  public UpdateScreen: nat ==> ()
  UpdateScreen (pn) ==
    ( cycles (5E5) skip;
      --duration (5E5) skip;
      cases (pn):
        1 -> IO`println("Screen Update: Volume Knob"),
        2 -> IO`println("Screen Update: InsertAddress"), --World`envTasks("InsertAddress").HandleEvent(pno),
        3 -> IO`println("Screen Update: TransmitTMC") -- World`envTasks("TransmitTMC").HandleEvent(pno)
      end )

end MMI

class Navigation

operations
  async 
  public DatabaseLookup: () ==> ()
  DatabaseLookup () ==
    ( cycles (5E6) skip;
      --duration (5E6) skip;
      RadNavSys`mmi.UpdateScreen(2) );

  async 
  public DecodeTMC: () ==> ()
  DecodeTMC () ==
    ( cycles (5E5) skip;
      --duration (5E6) skip;
      RadNavSys`mmi.UpdateScreen(3) )

end Navigation

class Radio

values 
  public MAX : nat = 10;

instance variables
  public volume : nat := 0;

operations

  async public AdjustVolumeUp : () ==> ()
  AdjustVolumeUp () ==
	( cycles (1E6) skip;
    if volume < MAX
    then ( volume := volume + 1;		   
           RadNavSys`mmi.UpdateScreen(1))
    );

  async public AdjustVolumeDown : () ==> ()
  AdjustVolumeDown () ==
    ( cycles (1E6) skip;
    if volume > 0
    then ( volume := volume - 1;       
           RadNavSys`mmi.UpdateScreen(1))
    );

  async public HandleTMC: () ==> ()
  HandleTMC () ==
    ( cycles (1E6) skip;
      RadNavSys`navigation.DecodeTMC() 
    );

end Radio

system RadNavSys
instance variables
  -- create application tasks
  static public mmi : MMI := new MMI();
  static public radio : Radio := new Radio();
  static public navigation : Navigation := new Navigation();
  
  -- create CPUs (policy, capacity)
  CPU1 : CPU := new CPU (<FP>, 22E6);
  CPU2 : CPU := new CPU (<FP>, 11E6);
  CPU3 : CPU := new CPU (<FP>, 113E6);

  -- create a bus (policy, capacity, topology)
  BUS1 : BUS := new BUS (<CSMACD>, 72E3, {CPU1, CPU2, CPU3})

operations
  public RadNavSys: () ==> RadNavSys
  RadNavSys () ==
    ( -- deploy mmi on CPU1
      CPU1.deploy(mmi,"MMIT");
      CPU1.setPriority(MMI`HandleKeyPress,100);
      CPU1.setPriority(MMI`UpdateScreen,90);
      -- deploy radio on CPU2
      CPU2.deploy(radio,"RadioT");
      CPU2.setPriority(Radio`AdjustVolumeUp,100);
      CPU2.setPriority(Radio`AdjustVolumeDown,100);
      CPU2.setPriority(Radio`HandleTMC,90);
      -- deploy navigation on CPU3
      CPU3.deploy(navigation,"NavT");
      CPU3.setPriority(Navigation`DatabaseLookup, 100);
      CPU3.setPriority(Navigation`DecodeTMC, 90)
      -- starting the CPUs and BUS is implicit
    );
    
/* timing invariants
separate(#fin(MMI`UpdateScreen), #fin(MMI`UpdateScreen), 500 ms);
*/

end RadNavSys

class Testing

operations
  public Test: () ==> ()
  Test () ==
  (
    new World().RunScenario1();
		start(self);
    block();
  );


  private block : () ==> ()
  block () == skip;

  private op : () ==> ()
  op () == skip;

sync

per block => time > 5000000


thread

  periodic(1000E6,0,0,0)(op)

end Testing



class World
 
types
  public perfdata = nat * nat * real

instance variables
 

operations
  	
  public RunScenario1 : () ==> ()
  RunScenario1 () ==
    ( RadNavSys`mmi.HandleKeyPress(1);
      RadNavSys`mmi.HandleKeyPress(1);
      RadNavSys`mmi.HandleKeyPress(1);
    );

 

end World


