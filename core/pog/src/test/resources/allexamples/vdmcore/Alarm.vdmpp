
class Alarm
types

public String = seq of char;

instance variables 

descr    : String;
reqQuali : Expert`Qualification;

operations

public Alarm: Expert`Qualification * String ==> Alarm
Alarm(quali,str) ==
( descr := str;
  reqQuali := quali
);

public GetReqQuali: () ==> Expert`Qualification
GetReqQuali() ==
  return reqQuali;
  
end Alarm

class Expert

instance variables

quali : set of Qualification;
\end{vdm_al}

\begin{vdm_al}
types
 
public Qualification = <Mech> | <Chem> | <Bio> | <Elec>;
\end{vdm_al}

\begin{vdm_al}
operations

public Expert: set of Qualification ==> Expert
Expert(qs) ==
  quali := qs;

public GetQuali: () ==> set of Qualification
GetQuali() ==
  return quali;
  
end Expert



class GLOBAL

values

public p1: Plant`Period = mk_token("Monday day");
public p2: Plant`Period = mk_token("Monday night");
public p3: Plant`Period = mk_token("Tuesday day");
public p4: Plant`Period = mk_token("Tuesday night");

operations

public static NewTest1: () ==> Test1
NewTest1() ==
  let a1 = new Alarm(<Mech>,"Mechanical fault"),
      a2 = new Alarm(<Chem>,"Tank overflow"),
      ex1 = new Expert({<Mech>,<Bio>}),
      ex2 = new Expert({<Elec>}),
      ex3 = new Expert({<Chem>,<Bio>,<Mech>}),
      ex4 = new Expert({<Elec>,<Chem>})
  in
    return new Test1(a1,a2,ex1,ex2,ex3,ex4,
                     new Plant({a1},{p1 |-> {ex1,ex4},
                                     p2 |-> {ex2,ex3}}));

	functions
-- TODO Define functiones here
	traces
-- TODO Define Combinatorial Test Traces here
end GLOBAL

\begin{vdm_al}
class Plant

instance variables

alarms   : set of Alarm;
schedule : map Period to set of Expert;
inv PlantInv(alarms,schedule);

functions

PlantInv: set of Alarm * map Period to set of Expert -> 
          bool
PlantInv(as,sch) ==
  (forall p in set dom sch & sch(p) <> {}) and
  (forall a in set as &
     forall p in set dom sch &
       exists expert in set sch(p) &
         a.GetReqQuali() in set expert.GetQuali());
\end{vdm_al}

\begin{vdm_al}
types

public Period = token;
\end{vdm_al}
  
\begin{vdm_al}
operations

public ExpertToPage: Alarm * Period ==> Expert
ExpertToPage(a, p) ==
  let expert in set schedule(p) be st
      a.GetReqQuali() in set expert.GetQuali()
  in
    return expert
pre a in set alarms and
    p in set dom schedule
post let expert = RESULT
     in
       expert in set schedule(p) and
       a.GetReqQuali() in set expert.GetQuali();
\end{vdm_al}
	 
\begin{vdm_al}
NumberOfExperts: Period ==> nat
NumberOfExperts(p) ==
  return card schedule(p)
pre p in set dom schedule;
\end{vdm_al}

\begin{vdm_al}
public ExpertIsOnDuty: Expert ==> set of Period
ExpertIsOnDuty(ex) ==
  return {p | p in set dom schedule & 
              ex in set schedule(p)};
\end{vdm_al}

\begin{vdm_al}
public Plant: set of Alarm * 
       map Period to set of Expert ==> Plant
Plant(als,sch) ==
( alarms := als;
  schedule := sch
)
pre PlantInv(als,sch);
\end{vdm_al}

\begin{vdm_al}    
end Plant
\end{vdm_al}


\begin{vdm_al}
class Test1

instance variables

a1   : Alarm;
a2   : Alarm;
ex1  : Expert;
ex2  : Expert;
ex3  : Expert;
ex4  : Expert;
plant: Plant;

operations

public Test1: Alarm * Alarm * Expert * Expert * Expert * Expert * Plant ==> Test1
Test1(aa1,aa2,e1,e2,e3,e4,p) ==
atomic (a1 := aa1;
        a2 := aa2;
        ex1 := e1;
        ex2 := e2;
        ex3 := e3;
        ex4 := e4;
        plant := p);

public Run: () ==> set of Plant`Period * Expert
Run() == 
  let periods = plant.ExpertIsOnDuty(ex1),
      expert  = plant.ExpertToPage(a1,GLOBAL`p1)
  in 
    return mk_(periods,expert);

end Test1



