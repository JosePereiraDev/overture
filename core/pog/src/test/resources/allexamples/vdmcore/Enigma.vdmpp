class IO

--  Overture STANDARD LIBRARY: INPUT/OUTPUT
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customizable. 
-- Don't care's may NOT be used in the parameter lists.
--
-- The in/out functions  will return false if an error occurs. In this
-- case an internal error string will be set (see 'ferror').
--
-- File path:
--  * An absolute path is accepted and used as specified.
--  * A relative path is relative to the debugger or if running in the 
--      Overture IDE relative to the project root.
--

types
 
/**
 * The file directive used in in/out functions.
 */
public filedirective = <start>|<append> 

functions

/**
 * Write VDM value in ASCII format to the console.
 *
 * @param val the VDM value to be written
 * @return true if successful else false
 */
public static writeval[@p]: @p -> bool
writeval(val)==
  is not yet specified;

/**
 * Write VDM value in ASCII format to file. The type of the val must be
 * specified as fwriteval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @param val the VDM value to be written.
 * @param fdir if <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file
 * @return true if successful else false
 */
public static fwriteval[@p]:seq1 of char * @p * filedirective -> bool
fwriteval(filename,val,fdir) ==
  is not yet specified;

/**
 * Read VDM value in ASCII format from file. The type which should be read must be
 * specified as freadval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @return mk_(success,@p) if successful success will be 
 * set to true else false. @p will hold nil if unsuccessful or the value read.
 */
public static freadval[@p]:seq1 of char -> bool * [@p]
freadval(filename) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

operations

/**
 * Write text to std out. Surrounding double quotes will be stripped,
 * backslashed characters should be interpreted.
 *
 * @param text the text to write to the console
 * @return if successful true else false.
 */
public echo: seq of char ==> bool
echo(text) ==
  fecho ("",text,nil);

/**
 * Write text to file like <code>echo</code>.
 *
 * @param filename the name of the file
 * @param text the text to write to be written.
 * @param fdir if nil or <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file.
 * @return true if successful else false
 */
public fecho: seq of char * seq of char * [filedirective] ==> bool
fecho (filename,text,fdir) ==
  is not yet specified
  pre filename = "" <=> fdir = nil;

/**
 * Returns the last error which may have occurred by any of the io/out functions
 *
 * @return the last error message
 */
public ferror:()  ==> seq of char
ferror () ==
  is not yet specified;
  
-- New simplified format printing operations


/**
 * Prints any VDM value to the console
 *
 * @param arg a VDM value of any type
 */
public static print: ? ==> ()
print(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console as a new line
 *
 * @param arg a VDM value of any type
 */
public static println: ? ==> ()
println(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console
 *
 * @param format standard format string used in
 *  Java by <code>String.format(format, value)</code>,
 *  though note that only the %s conversion is supported.
 *  eg. <code>printf("Hello [%2$-5s][%1$5s]\n", [123, {2}])</code>
 *  would produce <code>Hello [{2}  ][  123]</code> and a newline.
 *
 * @param arg a sequence of VDM values of any type
 */
public static printf: seq of char * seq of ? ==> ()
printf(format, args) ==
    is not yet specified;

end IO



class AlphabetTest
  is subclass of TestCase

values
  str : seq of char = "ABCD"

operations
  public AlphabetTest: seq of char ==> AlphabetTest
  AlphabetTest(nm) == name := nm;

  protected SetUp: () ==> ()
  SetUp () == skip;

  protected RunTest: () ==> ()
  RunTest () ==
    ( dcl tc : Alphabet := new Alphabet(str);
      for all i in set inds str do
        ( AssertTrue(tc.GetChar(i) = str(i));
          AssertTrue(tc.GetIndex(str(i)) = i);
          AssertTrue(tc.Shift(1,i) = tc.ShiftOne(i)) );
      AssertTrue(tc.GetSize() = 4);
      AssertTrue(tc.GetIndices() = {1,...,4}) );
      
  protected TearDown: () ==> ()
  TearDown () == skip;

end AlphabetTest


class Alphabet

instance variables --instance values
  alph : seq of char;

inv AlphabetInv(alph)

functions
  AlphabetInv: seq of char -> bool
  AlphabetInv (palph) ==
    len palph mod 2 = 0 and
    card elems palph = len palph

operations
  public Alphabet: seq of char ==> Alphabet
  Alphabet (pa) == alph := pa
  pre AlphabetInv(pa);

-- all can be formulated as instance functions since alph does not change after 
-- object creation

  public GetChar: nat ==> char
  GetChar (pidx) == return alph(pidx)
  pre pidx in set inds alph;

  public GetIndex: char ==> nat
  GetIndex (pch) ==
    let pidx in set {i | i in set inds alph
                       & alph(i) = pch} in
      return pidx
  pre pch in set elems alph;

  public GetIndices: () ==> set of nat
  GetIndices () == return inds alph;

  public GetSize: () ==> nat
  GetSize () == return len alph;

  public Shift: nat * nat ==> nat
  Shift (pidx, poffset) ==
    if pidx + poffset > len alph
    then return pidx + poffset - len alph
    else return pidx + poffset
  pre pidx in set inds alph and
      poffset <= len alph;

  public ShiftOne: nat ==> nat
  ShiftOne (pidx) == Shift(pidx, 1)
end Alphabet


class Component

instance variables
  protected next : [Component];
  protected alph : Alphabet

operations

public Component: [Component] * Alphabet ==> Component
Component(com,al) ==
  atomic(next := com;
         alph := al);

  public Successors: () ==> set of Component
  Successors () ==
    if next = nil
    then return {self}
    else return {self} union next.Successors();

  public Substitute: nat ==> nat
  Substitute (-) == is subclass responsibility;

  public Rotate: () ==> ()
  Rotate () == skip;

  public Rotate: nat ==> ()
  Rotate (-) == skip

end Component



class ConfigurationTest
  is subclass of Configuration, TestCase

values
  cfg : inmap nat to nat =
    { 1 |-> 2, 3 |-> 4 }
    
operations
  public ConfigurationTest: seq of char ==> ConfigurationTest
  ConfigurationTest(nm) == name := nm;

  protected SetUp: () ==> ()
  SetUp () == config := cfg;

  protected RunTest: () ==> ()
  RunTest () == 
    ( AssertTrue(Encode(1) = 2);
      AssertTrue(Encode(2) = 2);
      AssertTrue(Encode(3) = 4);
      AssertTrue(Encode(4) = 4);
      AssertTrue(Decode(1) = 1);
      AssertTrue(Decode(2) = 1);
      AssertTrue(Decode(3) = 3);
      AssertTrue(Decode(4) = 3) );

  protected TearDown: () ==> ()
  TearDown () == skip;

end ConfigurationTest



class Configuration
  is subclass of Component

instance variables
  protected config: inmap nat to nat;

operations

public Configuration: (inmap nat to nat) * [Component] * Alphabet ==>
       Configuration
Configuration(cf,com,al) ==
  atomic(config := cf;
         next := com;
         alph := al);
 
  protected Encode: nat ==> nat
  Encode (penc) ==
    if penc in set dom config
    then return config(penc)
    else return penc;

  protected Decode: nat ==> nat
  Decode (pdec) ==
    let invcfg = inverse config in
      if pdec in set dom invcfg
      then return invcfg(pdec)
      else return pdec;

  public Substitute: nat ==> nat
  Substitute(pidx) ==
    return Decode(next.Substitute(Encode(pidx)))
  pre next <> nil

end Configuration


class GLOBAL
values
   refcfg : inmap nat to nat =
     {1 |-> 3, 2 |-> 4};
   rotcfg : inmap nat to nat =
     {1 |-> 2, 2 |-> 4, 3 |-> 3, 4 |-> 1};
   pbcfg : inmap nat to nat =
     {2 |-> 3}

operations

public static NewSimpleEnigma: () ==> SimpleEnigma
NewSimpleEnigma() ==
  let alph = new Alphabet("ABCD"),
      reflec = new Reflector(4,alph,nil,refcfg),
      rot3 = new Rotor(3,3,reflec,alph,rotcfg),
      rot2 = new Rotor(2,2,rot3,alph,rotcfg),
      rot1 = new Rotor(1,1,rot2,alph,rotcfg),
      plug = new Plugboard(alph,rot1,pbcfg) 
  in
    return new SimpleEnigma(plug,alph);

  public EnigmaTestExecute: () ==> ()
  EnigmaTestExecute () ==
  let alph = new Alphabet("ABCD")
  in
    (dcl ts : TestSuite := new TestSuite();
     ts.AddTest(new AlphabetTest("Alphabet"));
     ts.AddTest(new ConfigurationTest("Configuration"));
     ts.AddTest(new ReflectorTest("Reflector",alph));
     ts.AddTest(new RotorTest("Rotor",alph));
     ts.AddTest(new PlugboardTest("Plugboard",alph));
     ts.AddTest(new SimpleEnigmaTest("SimpleEnigma"));
     ts.Run())

end GLOBAL

class PlugboardTest
  is subclass of TestCase

values
  refcfg : inmap nat to nat =
    {1 |-> 2, 3 |-> 4};

  rotcfg : inmap nat to nat =
    {1 |-> 2, 2 |-> 1, 3 |-> 4, 4 |-> 3};

  pbcfg : inmap nat to nat =
    {1 |-> 3}

instance variables
  alph : Alphabet
  
operations
  public PlugboardTest: seq of char * Alphabet ==> PlugboardTest
  PlugboardTest(nm,al) ==
    atomic ( name := nm;
             alph := al);

  protected SetUp: () ==> ()
  SetUp () == alph := new Alphabet("ABCD");

  protected SimpleTest: () ==> ()
  SimpleTest () ==
    (dcl tc : Plugboard := new Plugboard(alph,new Reflector(1,alph,nil,refcfg),pbcfg);
     AssertTrue(tc.Substitute(1) = 4);
     AssertTrue(tc.Substitute(2) = 3);
     AssertTrue(tc.Substitute(3) = 2);
     AssertTrue(tc.Substitute(4) = 1));

  protected ComplexTest: () ==> ()
  ComplexTest () ==
    let reflec : Reflector = new Reflector(1,alph,nil,refcfg),
        rot : Rotor = new Rotor(1,1,reflec,alph,rotcfg),
        tc : Plugboard = new Plugboard(alph,rot,pbcfg)
    in
     (AssertTrue(tc.Substitute(1) = 4);
      AssertTrue(tc.Substitute(2) = 3);
      AssertTrue(tc.Substitute(3) = 2);
      AssertTrue(tc.Substitute(4) = 1));

  protected RunTest: () ==> ()
  RunTest () == (SimpleTest(); ComplexTest());

  protected TearDown: () ==> ()
  TearDown () == skip;

end PlugboardTest


class Plugboard
  is subclass of Configuration

instance variables
  inv PlugboardInv(config, alph)

functions
  PlugboardInv: inmap nat to nat * Alphabet -> bool
  PlugboardInv (pconfig, palph) ==
    dom pconfig subset palph.GetIndices()

operations
  public Plugboard:
    Alphabet * [Component] * inmap nat to nat ==> Plugboard
  Plugboard (pa, com, pcfg) ==
    atomic (alph := pa;
      next := com;
      config := pcfg munion inverse pcfg)
  pre dom pcfg inter rng pcfg = {} and
      PlugboardInv(pcfg, pa);

  public Substitute: nat ==> nat
  Substitute (pidx) ==
    (next.Rotate();
     Configuration`Substitute(pidx))
  pre pidx in set alph.GetIndices() and
      (isofclass(Rotor,next) or
       isofclass(Reflector,next))

end Plugboard


class ReflectorTest
  is subclass of TestCase

values
  cfg : inmap nat to nat =
    { 1 |-> 2, 3 |-> 4 }
    
instance variables
  alph : Alphabet;

operations
  public ReflectorTest: seq of char * Alphabet ==> ReflectorTest
  ReflectorTest(nm,al) == 
    atomic (name := nm;
            alph := al);

  protected SetUp: () ==> ()
  SetUp () == alph := new Alphabet("ABCD");

  SimpleTest: () ==> ()
  SimpleTest () ==
    ( dcl tc1 : Reflector := new Reflector(1, alph, nil, cfg),
          tc2 : Reflector := new Reflector(2, alph, nil, cfg);
      AssertTrue (tc1.Substitute(1) = 2);
      AssertTrue (tc1.Substitute(2) = 1);
      AssertTrue (tc1.Substitute(3) = 4);
      AssertTrue (tc1.Substitute(4) = 3);
      AssertTrue (tc2.Substitute(1) = 4);
      AssertTrue (tc2.Substitute(2) = 3);
      AssertTrue (tc2.Substitute(3) = 2);
      AssertTrue (tc2.Substitute(4) = 1) );


  ComplexTest: () ==> ()
  ComplexTest () ==
    for all x in set alph.GetIndices() do
      ( dcl tc : Reflector := new Reflector(x, alph, nil, cfg);
        for all y in set alph.GetIndices() do
          AssertTrue(tc.Substitute(tc.Substitute(y)) = y) );

  protected RunTest: () ==> ()
  RunTest () == ( SimpleTest(); ComplexTest() );

  protected TearDown: () ==> ()
  TearDown () == skip

end ReflectorTest



class Reflector
  is subclass of Configuration

instance variables
  inv ReflectorInv(next, config, alph)

functions
  public static ReflectorInv:
    [Component] * inmap nat to nat * Alphabet -> bool
  ReflectorInv (pnext, pconfig, palph) ==
    pnext = nil and
    dom pconfig inter rng pconfig = {} and
    dom pconfig union rng pconfig = palph.GetIndices()

operations
  public Reflector:
    nat * Alphabet * [Component] * inmap nat to nat ==> Reflector
  Reflector (psp, pa, com, pcfg) ==
    atomic (alph := pa;
      next := com;
      config := {pa.Shift(i, psp-1) |->
        pa.Shift(pcfg(i), psp-1) |
        i in set dom pcfg})
  pre psp in set pa.GetIndices() and
      ReflectorInv(com, pcfg, pa);

  public Substitute: nat ==> nat
  Substitute (pidx) ==
    if pidx in set dom config
    then Encode(pidx)
    else Decode(pidx)

end Reflector



class RotorTest
  is subclass of TestCase

values
  refcfg : inmap nat to nat =
    { 1 |-> 2, 3 |-> 4};

  rotcfg : inmap nat to nat =
    { 1 |-> 1,  2 |-> 3, 3 |-> 2, 4 |-> 4}
    
instance variables
  alph : Alphabet

operations
  public RotorTest: seq of char * Alphabet ==> RotorTest
  RotorTest(nm,al) == 
    atomic(name := nm;
           alph := al);

  protected SetUp: () ==> ()
  SetUp () == alph := new Alphabet("ABCD");

  protected SimpleTest: () ==> ()
  SimpleTest () ==
    ( dcl tc : Rotor := new Rotor(1,1,new Reflector(1,alph,nil,refcfg),
                                  alph,rotcfg);
      AssertTrue(tc.Substitute(1) = 3);
      AssertTrue(tc.Substitute(2) = 4);
      AssertTrue(tc.Substitute(3) = 1);
      AssertTrue(tc.Substitute(4) = 2);
      tc.Rotate();
      AssertTrue(tc.Substitute(1) = 2);
      AssertTrue(tc.Substitute(2) = 1);
      AssertTrue(tc.Substitute(3) = 4);
      AssertTrue(tc.Substitute(4) = 3);
      tc.Rotate();
      AssertTrue(tc.Substitute(1) = 3);
      AssertTrue(tc.Substitute(2) = 4);
      AssertTrue(tc.Substitute(3) = 1);
      AssertTrue(tc.Substitute(4) = 2);
      tc.Rotate();
      AssertTrue(tc.Substitute(1) = 2);
      AssertTrue(tc.Substitute(2) = 1);
      AssertTrue(tc.Substitute(3) = 4);
      AssertTrue(tc.Substitute(4) = 3) );

  protected ComplexTest: () ==> ()
  ComplexTest () ==
    let reflec : Reflector = new Reflector(1,alph,nil, refcfg),
        tc1 : Rotor = new Rotor(1,1,reflec,alph,rotcfg),
        tc2 : Rotor = new Rotor(1,1,tc1,alph,rotcfg)
    in
     (AssertTrue(tc2.Substitute(1) = 2);
      AssertTrue(tc2.Substitute(2) = 1);
      AssertTrue(tc2.Substitute(3) = 4);
      AssertTrue(tc2.Substitute(4) = 3);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 2);
      AssertTrue(tc2.Substitute(2) = 1);
      AssertTrue(tc2.Substitute(3) = 4);
      AssertTrue(tc2.Substitute(4) = 3);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 3);
      AssertTrue(tc2.Substitute(2) = 4);
      AssertTrue(tc2.Substitute(3) = 1);
      AssertTrue(tc2.Substitute(4) = 2);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 2);
      AssertTrue(tc2.Substitute(2) = 1);
      AssertTrue(tc2.Substitute(3) = 4);
      AssertTrue(tc2.Substitute(4) = 3);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 3);
      AssertTrue(tc2.Substitute(2) = 4);
      AssertTrue(tc2.Substitute(3) = 1);
      AssertTrue(tc2.Substitute(4) = 2);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 2);
      AssertTrue(tc2.Substitute(2) = 1);
      AssertTrue(tc2.Substitute(3) = 4);
      AssertTrue(tc2.Substitute(4) = 3);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 2);
      AssertTrue(tc2.Substitute(2) = 1);
      AssertTrue(tc2.Substitute(3) = 4);
      AssertTrue(tc2.Substitute(4) = 3);
      tc2.Rotate();
      AssertTrue(tc2.Substitute(1) = 4);
      AssertTrue(tc2.Substitute(2) = 3);
      AssertTrue(tc2.Substitute(3) = 2);
      AssertTrue(tc2.Substitute(4) = 1) );

  protected RunTest: () ==> ()
  RunTest () == ( SimpleTest(); ComplexTest() );

  protected TearDown: () ==> ()
  TearDown () == skip;

end RotorTest



class Rotor
  is subclass of Configuration

instance variables
  latch_pos : nat;
  latch_lock : bool := false;

inv RotorInv(latch_pos, config, alph)

functions
  RotorInv: nat * inmap nat to nat * Alphabet -> bool
  RotorInv (platch_pos, pconfig, palph) ==
    let ainds = palph.GetIndices() in
      platch_pos in set ainds and
      dom pconfig = ainds and
      rng pconfig = ainds and
      exists x in set dom pconfig & x <> pconfig(x)

operations
  public Rotor:
    nat * nat * [Component] * Alphabet * inmap nat to nat ==> Rotor
  Rotor (psp, plp, com, pa, pcfg) == 
    atomic (latch_pos := pa.Shift(plp,psp-1); 
      next := com;
      alph := pa;
      config := {pa.Shift(i,psp-1) |->
                 pa.Shift(pcfg(i),psp-1) |
                 i in set dom pcfg})
  pre psp in set pa.GetIndices() and
      RotorInv(plp, pcfg, pa);

  public Rotate: () ==> ()
  Rotate () ==
    (-- propagate the rotation to the next component
     -- and tell it where our latch position is
     next.Rotate(latch_pos);
     -- update our own latch position and take the
     -- alphabet size into account
     if latch_pos = alph.GetSize()
     then latch_pos := 1
     else latch_pos := latch_pos+1;
     -- update the transpositioning relation by
     -- shifting all indices one position
     config := {alph.ShiftOne(i) |->
                alph.ShiftOne(config(i)) |
                i in set dom config};
     -- remember the rotation
     latch_lock := true)
  pre isofclass(Rotor,next) or
      isofclass(Reflector,next);

  public Rotate: nat ==> ()
  Rotate (ppos) ==
    -- compare the latch position and the lock
    if ppos = latch_pos and not latch_lock
    -- perform the actual rotation
    then Rotate()
    -- otherwise reset the lock
    else latch_lock := false
  pre ppos in set alph.GetIndices();
    
end Rotor


class SimpleEnigmaTest is subclass of TestCase

operations
  public SimpleEnigmaTest: seq of char ==> SimpleEnigmaTest
  SimpleEnigmaTest(nm) == name := nm;

  protected SetUp: () ==> ()
  SetUp () == skip;

  protected RunTest: () ==> ()
  RunTest () == 
    (dcl se1 : SimpleEnigma := GLOBAL`NewSimpleEnigma(),
         se2 : SimpleEnigma := GLOBAL`NewSimpleEnigma();
     for ch in "ABCDDCBAABCDDCBAAABBCCDD" do
       AssertTrue(
         se1.Keystroke(se2.Keystroke(ch)) = ch));

  protected TearDown: () ==> ()
  TearDown () == skip

end SimpleEnigmaTest


class SimpleEnigma
  is subclass of Component


operations
  public SimpleEnigma: [Component] * Alphabet ==> SimpleEnigma
  SimpleEnigma (com,al) ==
    atomic(next := com;
           alph := al);

  public Keystroke : char ==> char
  Keystroke (pch) ==
    let pidx = alph.GetIndex(pch) in
      return alph.GetChar(next.Substitute(pidx))
  pre isofclass(Plugboard,next)

end SimpleEnigma


class TestCase
  is subclass of Test

instance variables
  protected name : seq of char

operations
  public TestCase: seq of char ==> TestCase
  TestCase(nm) == name := nm;

  public GetName: () ==> seq of char
  GetName () == return name;

  protected AssertTrue: bool ==> ()
  AssertTrue (pb) == if not pb then exit <FAILURE>;

  protected AssertFalse: bool ==> ()
  AssertFalse (pb) == if pb then exit <FAILURE>;

  public Run: TestResult ==> ()
  Run (ptr) ==
    trap <FAILURE>
      with 
        ptr.AddFailure(self)
      in
        (SetUp();
	 RunTest();
	 TearDown());

  protected SetUp: () ==> ()
  SetUp () == is subclass responsibility;

  protected RunTest: () ==> ()
  RunTest () == is subclass responsibility;

  protected TearDown: () ==> ()
  TearDown () == is subclass responsibility

end TestCase


class TestResult

instance variables
  failures : seq of TestCase := []
  
operations
  public AddFailure: TestCase ==> ()
  AddFailure (ptst) == failures := failures ^ [ptst];

  public Print: seq of char ==> ()
  Print (pstr) ==
    def - = new IO().echo(pstr ^ "\n") in skip;
    
  public Show: () ==> ()
  Show () ==
    if failures = [] then
      Print ("No failures detected")
    else
      for failure in failures do
        Print (failure.GetName() ^ " failed")
  
end TestResult


class TestSuite
  is subclass of Test

instance variables
  tests : seq of Test := [];

operations
  public Run: () ==> ()
  Run () ==
    (dcl ntr : TestResult := new TestResult();
     Run(ntr);
     ntr.Show());

  public Run: TestResult ==> ()
  Run (result) ==
    for test in tests do
      test.Run(result);

  public AddTest: Test ==> ()
  AddTest(test) ==
    tests := tests ^ [test];

end TestSuite


class Test

operations
  public Run: TestResult ==> ()
  Run (-) == is subclass responsibility

end Test




