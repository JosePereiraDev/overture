
class IO

--  Overture STANDARD LIBRARY: INPUT/OUTPUT
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customizable. 
-- Don't care's may NOT be used in the parameter lists.
--
-- The in/out functions  will return false if an error occurs. In this
-- case an internal error string will be set (see 'ferror').
--
-- File path:
--  * An absolute path is accepted and used as specified.
--  * A relative path is relative to the debugger or if running in the 
--      Overture IDE relative to the project root.
--

types
 
/**
 * The file directive used in in/out functions.
 */
public filedirective = <start>|<append> 

functions

/**
 * Write VDM value in ASCII format to the console.
 *
 * @param val the VDM value to be written
 * @return true if successful else false
 */
public static writeval[@p]: @p -> bool
writeval(val)==
  is not yet specified;

/**
 * Write VDM value in ASCII format to file. The type of the val must be
 * specified as fwriteval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @param val the VDM value to be written.
 * @param fdir if <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file
 * @return true if successful else false
 */
public static fwriteval[@p]:seq1 of char * @p * filedirective -> bool
fwriteval(filename,val,fdir) ==
  is not yet specified;

/**
 * Read VDM value in ASCII format from file. The type which should be read must be
 * specified as freadval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @return mk_(success,@p) if successful success will be 
 * set to true else false. @p will hold nil if unsuccessful or the value read.
 */
public static freadval[@p]:seq1 of char -> bool * [@p]
freadval(filename) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

operations

/**
 * Write text to std out. Surrounding double quotes will be stripped,
 * backslashed characters should be interpreted.
 *
 * @param text the text to write to the console
 * @return if successful true else false.
 */
public echo: seq of char ==> bool
echo(text) ==
  fecho ("",text,nil);

/**
 * Write text to file like <code>echo</code>.
 *
 * @param filename the name of the file
 * @param text the text to write to be written.
 * @param fdir if nil or <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file.
 * @return true if successful else false
 */
public fecho: seq of char * seq of char * [filedirective] ==> bool
fecho (filename,text,fdir) ==
  is not yet specified
  pre filename = "" <=> fdir = nil;

/**
 * Returns the last error which may have occurred by any of the io/out functions
 *
 * @return the last error message
 */
public ferror:()  ==> seq of char
ferror () ==
  is not yet specified;
  
-- New simplified format printing operations


/**
 * Prints any VDM value to the console
 *
 * @param arg a VDM value of any type
 */
public static print: ? ==> ()
print(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console as a new line
 *
 * @param arg a VDM value of any type
 */
public static println: ? ==> ()
println(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console
 *
 * @param format standard format string used in 
  *  Java by <code>String.format(format,value)</code>
 * @param arg a sequence of VDM values of any type
 */
public static printf: seq of char * seq of ? ==> ()
printf(format, args) ==
    is not yet specified;

end IO

class Colli

functions

instance variables

ID : int := 0;
destination : int := 0;

operations

public Colli: int * int ==> Colli
Colli(id, dest) ==
(
ID := id;
destination := dest;
);

public getDestination : () ==> int
getDestination() ==
  return destination;

public getID : () ==> int
getID() == return ID;

public setID : int ==> ()
setID(id) == ID := id;

public setDestination : int ==> ()
setDestination(dest) == destination := dest;

end Colli

class Conveyor
 
functions

instance variables
goods : seq of Colli := [];
slides : seq of Slide := [];
inv forall a,b in set inds slides & 
 a<>b => slides(a).getID() <> slides(b).getID();

operations

 public addColli : Colli ==> ()
 addColli(elem) == goods := goods ^ [elem];

 public addSlide : Slide ==> ()
 addSlide(elem) == slides := slides ^ [elem]
pre forall a in set inds slides & elem.getID() <> slides(a).getID();

 public getSlides : () ==> seq of Slide
 getSlides() == return slides;

 public
 distributeGoods : () ==> ()
 distributeGoods() ==
 (dcl doomed : set of Colli := {};
  for all x in set inds goods do 
   for all y in set inds slides do 
    if goods(x).getDestination() = slides(y).getID() 
    then --hvis destination matcher slisk ID
    (slides(y).addGoods(goods(x));
     doomed := doomed union {goods(x)};
    );
  for all i in set doomed do 
   removeGoods(i);
 );

 public removeGoods : Colli ==> ()
 removeGoods(elem) ==
  (goods := [goods(x)|x in set inds goods & goods(x) <> elem ]
    --build a new sequence of all the elements <> input
   --IO`print( "removeGoods called, goods: \n");
   --IO`print(goods);
  );

 public checkForUndeliverableGoods : () ==> set of Colli
 checkForUndeliverableGoods() ==
 (
  return {goods(x)|x in set inds goods & 
   not exists s in set inds slides &
   slides(s).getID() = goods(x).getDestination() };
 );

--print methods for testing
 public printColli : () ==> ()
 printColli()==
 for all x in set inds goods do
 (IO`print( goods(x).getID() );
  IO`print("\t");
 );

 public printSlides : () ==> ()
 printSlides()==
 for all x in set inds slides do
 (IO`print(slides(x).getID() );
  IO`print("\t");
 );

end Conveyor
  

class Slide

functions

instance variables
 goods: set of Colli := {};
 ID : int := 0;

operations

public Slide : int ==> Slide
Slide(id) == ID := id;

public getID : () ==> int
getID() ==
 return ID;

public addGoods : Colli ==> ()
addGoods(elem) ==
goods := goods union {elem};

public setID : int ==> ()
setID(id) == ID := id;

public printColli : () ==> ()
printColli()==
for all x in set goods do (
 IO`print("\t");
 IO`print(x.getID() );
);

end Slide

class Test

instance variables

goods : set of Colli := {new Colli(0,0),
                         new Colli(1,1),
                         new Colli(2,2),
                         new Colli(3,3), --bad colli
                         new Colli(4,0),
                         new Colli(359,14) }; --bad colli
slides : set of Slide := {new Slide(0),
                          new Slide(1),
                          new Slide(2) };
--test inv and precondition
conveyor : Conveyor := new Conveyor();

operations
public Run : () ==> ()
Run() ==
(dcl temp : set of Colli := {};
 for all x in set goods do
   conveyor.addColli(x);

 for all y in set slides do
   conveyor.addSlide(y);

 IO`print("\nTest started..");

 IO`print("\ngoods in conveyor:\n");
 conveyor.printColli();
 IO`print("\nslides in conveyor:\n");
 conveyor.printSlides();

 for all s in set elems conveyor.getSlides() do
 (IO`print("\nSlide ID:\t");
  IO`print(s.getID() );
  IO`print(" has goods:");
  s.printColli();
 );

 IO`print("\n\n..Distributing goods!\n");
 conveyor.distributeGoods();

 IO`print("\ngoods in conveyor:\n");
 conveyor.printColli();
 IO`print("\nslides in conveyor:\n");
 conveyor.printSlides();

 for all s in set elems conveyor.getSlides() do
 (IO`print("\nSlide ID:\t");
  IO`print(s.getID() );
  IO`print(" has goods:");
  s.printColli();
 );

 temp := conveyor.checkForUndeliverableGoods();

 IO`print("\nundeliverable goods:\t");
 for all s in set temp do
 (IO`print(s.getID());
  IO`print("\t");
 );

);

end Test


