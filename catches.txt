diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/AClassClassDefinitionAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/AClassClassDefinitionAssistantInterpreter.java
index b337b5d..9a7b5e9 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/AClassClassDefinitionAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/AClassClassDefinitionAssistantInterpreter.java
@@ -2,6 +2,7 @@ package org.overture.interpreter.assistant.definition;
 
 import java.util.HashMap;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.definitions.AClassClassDefinition;
 import org.overture.ast.definitions.PDefinition;
 import org.overture.ast.intf.lex.ILexNameToken;
@@ -25,7 +26,7 @@ public class AClassClassDefinitionAssistantInterpreter
 
 	public static ObjectValue newInstance(AClassClassDefinition node,
 			PDefinition ctorDefinition, ValueList argvals, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		if (node.getIsAbstract())
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/SClassDefinitionAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/SClassDefinitionAssistantInterpreter.java
index 183ebb2..26cab56 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/SClassDefinitionAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/definition/SClassDefinitionAssistantInterpreter.java
@@ -7,6 +7,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.pattern.PTypeList;
 import org.overture.ast.definitions.ABusClassDefinition;
 import org.overture.ast.definitions.AClassClassDefinition;
@@ -136,7 +137,14 @@ public class SClassDefinitionAssistantInterpreter extends
 			return ABusClassDefinitionAssitantInterpreter.newInstance((ABusClassDefinition) node, ctorDefinition, argvals, ctxt);
 		} else if (node instanceof AClassClassDefinition)
 		{
-			return AClassClassDefinitionAssistantInterpreter.newInstance((AClassClassDefinition) node, ctorDefinition, argvals, ctxt);
+			try
+			{
+				return AClassClassDefinitionAssistantInterpreter.newInstance((AClassClassDefinition) node, ctorDefinition, argvals, ctxt);
+			} catch (AnalysisException e)//DONE
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
 		} else if (node instanceof ACpuClassDefinition)
 		{
 			return ACpuClassDefinitionAssistantInterpreter.newInstance((ACpuClassDefinition) node, ctorDefinition, argvals, ctxt);
@@ -151,7 +159,7 @@ public class SClassDefinitionAssistantInterpreter extends
 
 	protected static ObjectValue makeNewInstance(SClassDefinition node,
 			PDefinition ctorDefinition, ValueList argvals, Context ctxt,
-			Map<ILexNameToken, ObjectValue> done) throws ValueException
+			Map<ILexNameToken, ObjectValue> done) throws AnalysisException
 	{
 		setStaticDefinitions(node, ctxt.getGlobal()); // When static member := new X()
 		setStaticValues(node, ctxt.getGlobal()); // When static member := new X()
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AConcatenationPatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AConcatenationPatternAssistantInterpreter.java
index 1226ea8..eca41d4 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AConcatenationPatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AConcatenationPatternAssistantInterpreter.java
@@ -30,173 +30,173 @@ public class AConcatenationPatternAssistantInterpreter
 		this.af = af;
 	}
 
-	public static List<NameValuePairList> getAllNamedValues(
-			AConcatenationPattern pattern, Value expval, Context ctxt)
-			throws PatternMatchException
-	{
-		ValueList values = null;
-
-		try
-		{
-			values = expval.seqValue(ctxt);
-		} catch (ValueException e)
-		{
-			VdmRuntimeError.patternFail(e, pattern.getLocation());
-		}
-
-		int llen = PPatternAssistantInterpreter.getLength(pattern.getLeft());
-		int rlen = PPatternAssistantInterpreter.getLength(pattern.getRight());
-		int size = values.size();
-
-		if (llen == PPatternAssistantInterpreter.ANY && rlen > size
-				|| rlen == PPatternAssistantInterpreter.ANY && llen > size
-				|| rlen != PPatternAssistantInterpreter.ANY
-				&& llen != PPatternAssistantInterpreter.ANY
-				&& size != llen + rlen)
-		{
-			VdmRuntimeError.patternFail(4108, "Sequence concatenation pattern does not match expression", pattern.getLocation());
-		}
-
-		// If the left and right sizes are ANY (ie. flexible) then we have to
-		// generate a set of splits of the values, and offer these to sub-matches
-		// to see whether they fit. Otherwise, there is just one split at this level.
-
-		List<Integer> leftSizes = new Vector<Integer>();
-
-		if (llen == PPatternAssistantInterpreter.ANY)
-		{
-			if (rlen == PPatternAssistantInterpreter.ANY)
-			{
-				if (size == 0)
-				{
-					// Can't match a ^ b with []
-				} else if (size % 2 == 1)
-				{
-					// Odd => add the middle, then those either side
-					int half = size / 2 + 1;
-					if (half > 0)
-					{
-						leftSizes.add(half);
-					}
-
-					for (int delta = 1; half - delta > 0; delta++)
-					{
-						leftSizes.add(half + delta);
-						leftSizes.add(half - delta);
-					}
-
-					leftSizes.add(0);
-				} else
-				{
-					// Even => add those either side of the middle
-					int half = size / 2;
-					if (half > 0)
-					{
-						leftSizes.add(half);
-					}
-
-					for (int delta = 1; half - delta > 0; delta++)
-					{
-						leftSizes.add(half + delta);
-						leftSizes.add(half - delta);
-					}
-
-					leftSizes.add(size);
-					leftSizes.add(0);
-				}
-			} else
-			{
-				leftSizes.add(size - rlen);
-			}
-		} else
-		{
-			leftSizes.add(llen);
-		}
-
-		// Now loop through the various splits and attempt to match the l/r
-		// sub-patterns to the split sequence value.
-
-		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
-
-		for (Integer lsize : leftSizes)
-		{
-			Iterator<Value> iter = values.iterator();
-			ValueList head = new ValueList();
-
-			for (int i = 0; i < lsize; i++)
-			{
-				head.add(iter.next());
-			}
-
-			ValueList tail = new ValueList();
-
-			while (iter.hasNext()) // Everything else in second
-			{
-				tail.add(iter.next());
-			}
-
-			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
-			int psize = 2;
-			int[] counts = new int[psize];
-
-			try
-			{
-				List<NameValuePairList> lnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getLeft(), new SeqValue(head), ctxt);
-				nvplists.add(lnvps);
-				counts[0] = lnvps.size();
-
-				List<NameValuePairList> rnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getRight(), new SeqValue(tail), ctxt);
-				nvplists.add(rnvps);
-				counts[1] = rnvps.size();
-			} catch (PatternMatchException e)
-			{
-				continue;
-			}
-
-			Permutor permutor = new Permutor(counts);
-
-			while (permutor.hasNext())
-			{
-				try
-				{
-					NameValuePairMap results = new NameValuePairMap();
-					int[] selection = permutor.next();
-
-					for (int p = 0; p < psize; p++)
-					{
-						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
-						{
-							Value v = results.get(nvp.name);
-
-							if (v == null)
-							{
-								results.put(nvp);
-							} else
-							// Names match, so values must also
-							{
-								if (!v.equals(nvp.value))
-								{
-									VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
-								}
-							}
-						}
-					}
-
-					finalResults.add(results.asList()); // Consistent set of nvps
-				} catch (PatternMatchException pme)
-				{
-					// try next perm
-				}
-			}
-		}
-
-		if (finalResults.isEmpty())
-		{
-			VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
-		}
-
-		return finalResults;
-	}
+//	public static List<NameValuePairList> getAllNamedValues(
+//			AConcatenationPattern pattern, Value expval, Context ctxt)
+//			throws PatternMatchException
+//	{
+//		ValueList values = null;
+//
+//		try
+//		{
+//			values = expval.seqValue(ctxt);
+//		} catch (ValueException e)
+//		{
+//			VdmRuntimeError.patternFail(e, pattern.getLocation());
+//		}
+//
+//		int llen = PPatternAssistantInterpreter.getLength(pattern.getLeft());
+//		int rlen = PPatternAssistantInterpreter.getLength(pattern.getRight());
+//		int size = values.size();
+//
+//		if (llen == PPatternAssistantInterpreter.ANY && rlen > size
+//				|| rlen == PPatternAssistantInterpreter.ANY && llen > size
+//				|| rlen != PPatternAssistantInterpreter.ANY
+//				&& llen != PPatternAssistantInterpreter.ANY
+//				&& size != llen + rlen)
+//		{
+//			VdmRuntimeError.patternFail(4108, "Sequence concatenation pattern does not match expression", pattern.getLocation());
+//		}
+//
+//		// If the left and right sizes are ANY (ie. flexible) then we have to
+//		// generate a set of splits of the values, and offer these to sub-matches
+//		// to see whether they fit. Otherwise, there is just one split at this level.
+//
+//		List<Integer> leftSizes = new Vector<Integer>();
+//
+//		if (llen == PPatternAssistantInterpreter.ANY)
+//		{
+//			if (rlen == PPatternAssistantInterpreter.ANY)
+//			{
+//				if (size == 0)
+//				{
+//					// Can't match a ^ b with []
+//				} else if (size % 2 == 1)
+//				{
+//					// Odd => add the middle, then those either side
+//					int half = size / 2 + 1;
+//					if (half > 0)
+//					{
+//						leftSizes.add(half);
+//					}
+//
+//					for (int delta = 1; half - delta > 0; delta++)
+//					{
+//						leftSizes.add(half + delta);
+//						leftSizes.add(half - delta);
+//					}
+//
+//					leftSizes.add(0);
+//				} else
+//				{
+//					// Even => add those either side of the middle
+//					int half = size / 2;
+//					if (half > 0)
+//					{
+//						leftSizes.add(half);
+//					}
+//
+//					for (int delta = 1; half - delta > 0; delta++)
+//					{
+//						leftSizes.add(half + delta);
+//						leftSizes.add(half - delta);
+//					}
+//
+//					leftSizes.add(size);
+//					leftSizes.add(0);
+//				}
+//			} else
+//			{
+//				leftSizes.add(size - rlen);
+//			}
+//		} else
+//		{
+//			leftSizes.add(llen);
+//		}
+//
+//		// Now loop through the various splits and attempt to match the l/r
+//		// sub-patterns to the split sequence value.
+//
+//		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+//
+//		for (Integer lsize : leftSizes)
+//		{
+//			Iterator<Value> iter = values.iterator();
+//			ValueList head = new ValueList();
+//
+//			for (int i = 0; i < lsize; i++)
+//			{
+//				head.add(iter.next());
+//			}
+//
+//			ValueList tail = new ValueList();
+//
+//			while (iter.hasNext()) // Everything else in second
+//			{
+//				tail.add(iter.next());
+//			}
+//
+//			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+//			int psize = 2;
+//			int[] counts = new int[psize];
+//
+//			try
+//			{
+//				List<NameValuePairList> lnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getLeft(), new SeqValue(head), ctxt);
+//				nvplists.add(lnvps);
+//				counts[0] = lnvps.size();
+//
+//				List<NameValuePairList> rnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getRight(), new SeqValue(tail), ctxt);
+//				nvplists.add(rnvps);
+//				counts[1] = rnvps.size();
+//			} catch (PatternMatchException e)
+//			{
+//				continue;
+//			}
+//
+//			Permutor permutor = new Permutor(counts);
+//
+//			while (permutor.hasNext())
+//			{
+//				try
+//				{
+//					NameValuePairMap results = new NameValuePairMap();
+//					int[] selection = permutor.next();
+//
+//					for (int p = 0; p < psize; p++)
+//					{
+//						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+//						{
+//							Value v = results.get(nvp.name);
+//
+//							if (v == null)
+//							{
+//								results.put(nvp);
+//							} else
+//							// Names match, so values must also
+//							{
+//								if (!v.equals(nvp.value))
+//								{
+//									VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
+//								}
+//							}
+//						}
+//					}
+//
+//					finalResults.add(results.asList()); // Consistent set of nvps
+//				} catch (PatternMatchException pme)
+//				{
+//					// try next perm
+//				}
+//			}
+//		}
+//
+//		if (finalResults.isEmpty())
+//		{
+//			VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
+//		}
+//
+//		return finalResults;
+//	}
 
 //	public static boolean isConstrained(AConcatenationPattern pattern)
 //	{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternAssistantInterpreter.java
index a5e71e8..4e6b758 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternAssistantInterpreter.java
@@ -31,116 +31,116 @@ public class AMapPatternAssistantInterpreter
 		this.af = af;
 	}
 
-	public static List<NameValuePairList> getAllNamedValues(
-			AMapPattern pattern, Value expval, Context ctxt)
-			throws PatternMatchException
-	{
-		ValueMap values = null;
-
-		try
-		{
-			values = expval.mapValue(ctxt);
-		} catch (ValueException e)
-		{
-			VdmRuntimeError.patternFail(e, pattern.getLocation());
-		}
-
-		if (values.size() != pattern.getMaplets().size())
-		{
-			VdmRuntimeError.patternFail(4152, "Wrong number of elements for map pattern", pattern.getLocation());
-		}
-
-		// Since the member patterns may indicate specific map members, we
-		// have to permute through the various map orderings to see
-		// whether there are any which match both sides. If the members
-		// are not constrained however, the initial ordering will be
-		// fine.
-
-		List<ValueMap> allMaps;
-
-		if (isConstrained(pattern))
-		{
-			allMaps = values.permutedMaps();
-		} else
-		{
-			allMaps = new Vector<ValueMap>();
-			allMaps.add(values);
-		}
-
-		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
-		int psize = pattern.getMaplets().size();
-
-		if (pattern.getMaplets().isEmpty())
-		{
-			finalResults.add(new NameValuePairList());
-			return finalResults;
-		}
-
-		for (ValueMap mapPerm : allMaps)
-		{
-			Iterator<Entry<Value, Value>> iter = mapPerm.entrySet().iterator();
-
-			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
-			int[] counts = new int[psize];
-			int i = 0;
-
-			try
-			{
-				for (AMapletPatternMaplet p : pattern.getMaplets())
-				{
-					List<NameValuePairList> pnvps = AMapPatternMapletAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
-					nvplists.add(pnvps);
-					counts[i++] = pnvps.size();
-				}
-			} catch (Exception e)
-			{
-				continue;
-			}
-
-			Permutor permutor = new Permutor(counts);
-
-			while (permutor.hasNext())
-			{
-				try
-				{
-					NameValuePairMap results = new NameValuePairMap();
-					int[] selection = permutor.next();
-
-					for (int p = 0; p < psize; p++)
-					{
-						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
-						{
-							Value v = results.get(nvp.name);
-
-							if (v == null)
-							{
-								results.put(nvp);
-							} else
-							// Names match, so values must also
-							{
-								if (!v.equals(nvp.value))
-								{
-									VdmRuntimeError.patternFail(4153, "Values do not match map pattern", pattern.getLocation());
-								}
-							}
-						}
-					}
-
-					finalResults.add(results.asList());
-				} catch (PatternMatchException pme)
-				{
-					// Try next perm then...
-				}
-			}
-		}
-
-		if (finalResults.isEmpty())
-		{
-			VdmRuntimeError.patternFail(4154, "Cannot match map pattern", pattern.getLocation());
-		}
-
-		return finalResults;
-	}
+//	public static List<NameValuePairList> getAllNamedValues(
+//			AMapPattern pattern, Value expval, Context ctxt)
+//			throws PatternMatchException
+//	{
+//		ValueMap values = null;
+//
+//		try
+//		{
+//			values = expval.mapValue(ctxt);
+//		} catch (ValueException e)
+//		{
+//			VdmRuntimeError.patternFail(e, pattern.getLocation());
+//		}
+//
+//		if (values.size() != pattern.getMaplets().size())
+//		{
+//			VdmRuntimeError.patternFail(4152, "Wrong number of elements for map pattern", pattern.getLocation());
+//		}
+//
+//		// Since the member patterns may indicate specific map members, we
+//		// have to permute through the various map orderings to see
+//		// whether there are any which match both sides. If the members
+//		// are not constrained however, the initial ordering will be
+//		// fine.
+//
+//		List<ValueMap> allMaps;
+//
+//		if (isConstrained(pattern))
+//		{
+//			allMaps = values.permutedMaps();
+//		} else
+//		{
+//			allMaps = new Vector<ValueMap>();
+//			allMaps.add(values);
+//		}
+//
+//		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+//		int psize = pattern.getMaplets().size();
+//
+//		if (pattern.getMaplets().isEmpty())
+//		{
+//			finalResults.add(new NameValuePairList());
+//			return finalResults;
+//		}
+//
+//		for (ValueMap mapPerm : allMaps)
+//		{
+//			Iterator<Entry<Value, Value>> iter = mapPerm.entrySet().iterator();
+//
+//			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+//			int[] counts = new int[psize];
+//			int i = 0;
+//
+//			try
+//			{
+//				for (AMapletPatternMaplet p : pattern.getMaplets())
+//				{
+//					List<NameValuePairList> pnvps = AMapPatternMapletAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
+//					nvplists.add(pnvps);
+//					counts[i++] = pnvps.size();
+//				}
+//			} catch (Exception e)
+//			{
+//				continue;
+//			}
+//
+//			Permutor permutor = new Permutor(counts);
+//
+//			while (permutor.hasNext())
+//			{
+//				try
+//				{
+//					NameValuePairMap results = new NameValuePairMap();
+//					int[] selection = permutor.next();
+//
+//					for (int p = 0; p < psize; p++)
+//					{
+//						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+//						{
+//							Value v = results.get(nvp.name);
+//
+//							if (v == null)
+//							{
+//								results.put(nvp);
+//							} else
+//							// Names match, so values must also
+//							{
+//								if (!v.equals(nvp.value))
+//								{
+//									VdmRuntimeError.patternFail(4153, "Values do not match map pattern", pattern.getLocation());
+//								}
+//							}
+//						}
+//					}
+//
+//					finalResults.add(results.asList());
+//				} catch (PatternMatchException pme)
+//				{
+//					// Try next perm then...
+//				}
+//			}
+//		}
+//
+//		if (finalResults.isEmpty())
+//		{
+//			VdmRuntimeError.patternFail(4154, "Cannot match map pattern", pattern.getLocation());
+//		}
+//
+//		return finalResults;
+//	}
 
 	public static boolean isConstrained(AMapPattern pattern)
 	{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternMapletAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternMapletAssistantInterpreter.java
index 8847c07..101cee1 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternMapletAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/AMapPatternMapletAssistantInterpreter.java
@@ -4,6 +4,7 @@ import java.util.List;
 import java.util.Map.Entry;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.patterns.AIdentifierPattern;
 import org.overture.ast.patterns.AMapletPatternMaplet;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
@@ -38,7 +39,7 @@ public class AMapPatternMapletAssistantInterpreter
 
 	public static List<NameValuePairList> getAllNamedValues(
 			AMapletPatternMaplet p, Entry<Value, Value> maplet, Context ctxt)
-			throws PatternMatchException
+			throws AnalysisException
 	{
 		List<NameValuePairList> flist = PPatternAssistantInterpreter.getAllNamedValues(p.getFrom(), maplet.getKey(), ctxt);
 		List<NameValuePairList> tlist = PPatternAssistantInterpreter.getAllNamedValues(p.getTo(), maplet.getValue(), ctxt);
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ARecordPatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ARecordPatternAssistantInterpreter.java
index 4417ada..d30c05a 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ARecordPatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ARecordPatternAssistantInterpreter.java
@@ -34,96 +34,96 @@ public class ARecordPatternAssistantInterpreter
 		this.af = af;
 	}
 
-	public static List<NameValuePairList> getAllNamedValues(
-			ARecordPattern pattern, Value expval, Context ctxt)
-			throws PatternMatchException
-	{
-		FieldMap fields = null;
-		RecordValue exprec = null;
-
-		try
-		{
-			exprec = expval.recordValue(ctxt);
-			fields = exprec.fieldmap;
-		} catch (ValueException e)
-		{
-			VdmRuntimeError.patternFail(e, pattern.getLocation());
-		}
-
-		// if (!type.equals(exprec.type))
-		if (!TypeComparator.compatible(pattern.getType(), exprec.type))
-		{
-			VdmRuntimeError.patternFail(4114, "Record type does not match pattern", pattern.getLocation());
-		}
-
-		if (fields.size() != pattern.getPlist().size())
-		{
-			VdmRuntimeError.patternFail(4115, "Record expression does not match pattern", pattern.getLocation());
-		}
-
-		Iterator<FieldValue> iter = fields.iterator();
-		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
-		int psize = pattern.getPlist().size();
-		int[] counts = new int[psize];
-		int i = 0;
-
-		for (PPattern p : pattern.getPlist())
-		{
-			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next().value, ctxt);
-			nvplists.add(pnvps);
-			counts[i++] = pnvps.size();
-		}
-
-		Permutor permutor = new Permutor(counts);
-		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
-
-		if (pattern.getPlist().isEmpty())
-		{
-			finalResults.add(new NameValuePairList());
-			return finalResults;
-		}
-
-		while (permutor.hasNext())
-		{
-			try
-			{
-				NameValuePairMap results = new NameValuePairMap();
-				int[] selection = permutor.next();
-
-				for (int p = 0; p < psize; p++)
-				{
-					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
-					{
-						Value v = results.get(nvp.name);
-
-						if (v == null)
-						{
-							results.put(nvp);
-						} else
-						// Names match, so values must also
-						{
-							if (!v.equals(nvp.value))
-							{
-								VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
-							}
-						}
-					}
-				}
-
-				finalResults.add(results.asList()); // Consistent set of nvps
-			} catch (PatternMatchException pme)
-			{
-				// try next perm
-			}
-		}
-
-		if (finalResults.isEmpty())
-		{
-			VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
-		}
-
-		return finalResults;
-	}
+//	public static List<NameValuePairList> getAllNamedValues(
+//			ARecordPattern pattern, Value expval, Context ctxt)
+//			throws PatternMatchException
+//	{
+//		FieldMap fields = null;
+//		RecordValue exprec = null;
+//
+//		try
+//		{
+//			exprec = expval.recordValue(ctxt);
+//			fields = exprec.fieldmap;
+//		} catch (ValueException e)
+//		{
+//			VdmRuntimeError.patternFail(e, pattern.getLocation());
+//		}
+//
+//		// if (!type.equals(exprec.type))
+//		if (!TypeComparator.compatible(pattern.getType(), exprec.type))
+//		{
+//			VdmRuntimeError.patternFail(4114, "Record type does not match pattern", pattern.getLocation());
+//		}
+//
+//		if (fields.size() != pattern.getPlist().size())
+//		{
+//			VdmRuntimeError.patternFail(4115, "Record expression does not match pattern", pattern.getLocation());
+//		}
+//
+//		Iterator<FieldValue> iter = fields.iterator();
+//		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+//		int psize = pattern.getPlist().size();
+//		int[] counts = new int[psize];
+//		int i = 0;
+//
+//		for (PPattern p : pattern.getPlist())
+//		{
+//			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next().value, ctxt);
+//			nvplists.add(pnvps);
+//			counts[i++] = pnvps.size();
+//		}
+//
+//		Permutor permutor = new Permutor(counts);
+//		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+//
+//		if (pattern.getPlist().isEmpty())
+//		{
+//			finalResults.add(new NameValuePairList());
+//			return finalResults;
+//		}
+//
+//		while (permutor.hasNext())
+//		{
+//			try
+//			{
+//				NameValuePairMap results = new NameValuePairMap();
+//				int[] selection = permutor.next();
+//
+//				for (int p = 0; p < psize; p++)
+//				{
+//					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+//					{
+//						Value v = results.get(nvp.name);
+//
+//						if (v == null)
+//						{
+//							results.put(nvp);
+//						} else
+//						// Names match, so values must also
+//						{
+//							if (!v.equals(nvp.value))
+//							{
+//								VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
+//							}
+//						}
+//					}
+//				}
+//
+//				finalResults.add(results.asList()); // Consistent set of nvps
+//			} catch (PatternMatchException pme)
+//			{
+//				// try next perm
+//			}
+//		}
+//
+//		if (finalResults.isEmpty())
+//		{
+//			VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
+//		}
+//
+//		return finalResults;
+//	}
 
 //	public static boolean isConstrained(ARecordPattern pattern)
 //	{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ASeqPatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ASeqPatternAssistantInterpreter.java
index 6ca118b..50914fa 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ASeqPatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ASeqPatternAssistantInterpreter.java
@@ -30,88 +30,88 @@ public class ASeqPatternAssistantInterpreter
 		this.af = af;
 	}
 
-	public static List<NameValuePairList> getAllNamedValues(
-			ASeqPattern pattern, Value expval, Context ctxt)
-			throws PatternMatchException
-	{
-		ValueList values = null;
-
-		try
-		{
-			values = expval.seqValue(ctxt);
-		} catch (ValueException e)
-		{
-			VdmRuntimeError.patternFail(e, pattern.getLocation());
-		}
-
-		if (values.size() != pattern.getPlist().size())
-		{
-			VdmRuntimeError.patternFail(4117, "Wrong number of elements for sequence pattern", pattern.getLocation());
-		}
-
-		ListIterator<Value> iter = values.listIterator();
-		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
-		int psize = pattern.getPlist().size();
-		int[] counts = new int[psize];
-		int i = 0;
-
-		for (PPattern p : pattern.getPlist())
-		{
-			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
-			nvplists.add(pnvps);
-			counts[i++] = pnvps.size();
-		}
-
-		Permutor permutor = new Permutor(counts);
-		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
-
-		if (pattern.getPlist().isEmpty())
-		{
-			finalResults.add(new NameValuePairList());
-			return finalResults;
-		}
-
-		while (permutor.hasNext())
-		{
-			try
-			{
-				NameValuePairMap results = new NameValuePairMap();
-				int[] selection = permutor.next();
-
-				for (int p = 0; p < psize; p++)
-				{
-					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
-					{
-						Value v = results.get(nvp.name);
-
-						if (v == null)
-						{
-							results.put(nvp);
-						} else
-						// Names match, so values must also
-						{
-							if (!v.equals(nvp.value))
-							{
-								VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
-							}
-						}
-					}
-				}
-
-				finalResults.add(results.asList()); // Consistent set of nvps
-			} catch (PatternMatchException pme)
-			{
-				// try next perm
-			}
-		}
-
-		if (finalResults.isEmpty())
-		{
-			VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
-		}
-
-		return finalResults;
-	}
+//	public static List<NameValuePairList> getAllNamedValues(
+//			ASeqPattern pattern, Value expval, Context ctxt)
+//			throws PatternMatchException
+//	{
+//		ValueList values = null;
+//
+//		try
+//		{
+//			values = expval.seqValue(ctxt);
+//		} catch (ValueException e)
+//		{
+//			VdmRuntimeError.patternFail(e, pattern.getLocation());
+//		}
+//
+//		if (values.size() != pattern.getPlist().size())
+//		{
+//			VdmRuntimeError.patternFail(4117, "Wrong number of elements for sequence pattern", pattern.getLocation());
+//		}
+//
+//		ListIterator<Value> iter = values.listIterator();
+//		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+//		int psize = pattern.getPlist().size();
+//		int[] counts = new int[psize];
+//		int i = 0;
+//
+//		for (PPattern p : pattern.getPlist())
+//		{
+//			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
+//			nvplists.add(pnvps);
+//			counts[i++] = pnvps.size();
+//		}
+//
+//		Permutor permutor = new Permutor(counts);
+//		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+//
+//		if (pattern.getPlist().isEmpty())
+//		{
+//			finalResults.add(new NameValuePairList());
+//			return finalResults;
+//		}
+//
+//		while (permutor.hasNext())
+//		{
+//			try
+//			{
+//				NameValuePairMap results = new NameValuePairMap();
+//				int[] selection = permutor.next();
+//
+//				for (int p = 0; p < psize; p++)
+//				{
+//					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+//					{
+//						Value v = results.get(nvp.name);
+//
+//						if (v == null)
+//						{
+//							results.put(nvp);
+//						} else
+//						// Names match, so values must also
+//						{
+//							if (!v.equals(nvp.value))
+//							{
+//								VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
+//							}
+//						}
+//					}
+//				}
+//
+//				finalResults.add(results.asList()); // Consistent set of nvps
+//			} catch (PatternMatchException pme)
+//			{
+//				// try next perm
+//			}
+//		}
+//
+//		if (finalResults.isEmpty())
+//		{
+//			VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
+//		}
+//
+//		return finalResults;
+//	}
 
 	public static boolean isConstrained(ASeqPattern pattern)
 	{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATuplePatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATuplePatternAssistantInterpreter.java
index ec43783..caf9e63 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATuplePatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATuplePatternAssistantInterpreter.java
@@ -31,83 +31,83 @@ public class ATuplePatternAssistantInterpreter
 		this.af = af;
 	}
 
-	public static List<NameValuePairList> getAllNamedValues(
-			ATuplePattern pattern, Value expval, Context ctxt)
-			throws PatternMatchException
-	{
-		ValueList values = null;
-
-		try
-		{
-			values = expval.tupleValue(ctxt);
-		} catch (ValueException e)
-		{
-			VdmRuntimeError.patternFail(e, pattern.getLocation());
-		}
-
-		if (values.size() != pattern.getPlist().size())
-		{
-			VdmRuntimeError.patternFail(4123, "Tuple expression does not match pattern", pattern.getLocation());
-		}
-
-		ListIterator<Value> iter = values.listIterator();
-		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
-		int psize = pattern.getPlist().size();
-		int[] counts = new int[psize];
-		int i = 0;
-
-		for (PPattern p : pattern.getPlist())
-		{
-			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
-			
-			nvplists.add(pnvps);
-			counts[i++] = pnvps.size();
-		}
-
-		Permutor permutor = new Permutor(counts);
-		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
-
-		while (permutor.hasNext())
-		{
-			try
-			{
-				NameValuePairMap results = new NameValuePairMap();
-				int[] selection = permutor.next();
-
-				for (int p = 0; p < psize; p++)
-				{
-					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
-					{
-						Value v = results.get(nvp.name);
-
-						if (v == null)
-						{
-							results.put(nvp);
-						} else
-						// Names match, so values must also
-						{
-							if (!v.equals(nvp.value))
-							{
-								VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
-							}
-						}
-					}
-				}
-
-				finalResults.add(results.asList()); // Consistent set of nvps
-			} catch (PatternMatchException pme)
-			{
-				// try next perm
-			}
-		}
-
-		if (finalResults.isEmpty())
-		{
-			VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
-		}
-
-		return finalResults;
-	}
+//	public static List<NameValuePairList> getAllNamedValues(
+//			ATuplePattern pattern, Value expval, Context ctxt)
+//			throws PatternMatchException
+//	{
+//		ValueList values = null;
+//
+//		try
+//		{
+//			values = expval.tupleValue(ctxt);
+//		} catch (ValueException e)
+//		{
+//			VdmRuntimeError.patternFail(e, pattern.getLocation());
+//		}
+//
+//		if (values.size() != pattern.getPlist().size())
+//		{
+//			VdmRuntimeError.patternFail(4123, "Tuple expression does not match pattern", pattern.getLocation());
+//		}
+//
+//		ListIterator<Value> iter = values.listIterator();
+//		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+//		int psize = pattern.getPlist().size();
+//		int[] counts = new int[psize];
+//		int i = 0;
+//
+//		for (PPattern p : pattern.getPlist())
+//		{
+//			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), ctxt);
+//			
+//			nvplists.add(pnvps);
+//			counts[i++] = pnvps.size();
+//		}
+//
+//		Permutor permutor = new Permutor(counts);
+//		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+//
+//		while (permutor.hasNext())
+//		{
+//			try
+//			{
+//				NameValuePairMap results = new NameValuePairMap();
+//				int[] selection = permutor.next();
+//
+//				for (int p = 0; p < psize; p++)
+//				{
+//					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+//					{
+//						Value v = results.get(nvp.name);
+//
+//						if (v == null)
+//						{
+//							results.put(nvp);
+//						} else
+//						// Names match, so values must also
+//						{
+//							if (!v.equals(nvp.value))
+//							{
+//								VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
+//							}
+//						}
+//					}
+//				}
+//
+//				finalResults.add(results.asList()); // Consistent set of nvps
+//			} catch (PatternMatchException pme)
+//			{
+//				// try next perm
+//			}
+//		}
+//
+//		if (finalResults.isEmpty())
+//		{
+//			VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
+//		}
+//
+//		return finalResults;
+//	}
 
 //	public static boolean isConstrained(ATuplePattern pattern)
 //	{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATypeBindAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATypeBindAssistantInterpreter.java
index 7042b92..977739f 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATypeBindAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/ATypeBindAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.pattern;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.patterns.ATypeBind;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
 import org.overture.interpreter.assistant.type.PTypeAssistantInterpreter;
@@ -21,7 +22,7 @@ public class ATypeBindAssistantInterpreter extends ATypeBindAssistantTC
 	}
 
 	public static ValueList getBindValues(ATypeBind bind, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		return PTypeAssistantInterpreter.getAllValues(bind.getType(), ctxt);
 	}
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PBindAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PBindAssistantInterpreter.java
index c824e04..04154e4 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PBindAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PBindAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.pattern;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.patterns.ASetBind;
 import org.overture.ast.patterns.ATypeBind;
 import org.overture.ast.patterns.PBind;
@@ -22,7 +23,7 @@ public class PBindAssistantInterpreter extends PBindAssistantTC
 	}
 
 	public static ValueList getBindValues(PBind bind, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		if (bind instanceof ASetBind)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PPatternAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PPatternAssistantInterpreter.java
index 17427f1..642671f 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PPatternAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/pattern/PPatternAssistantInterpreter.java
@@ -27,6 +27,7 @@ import org.overture.ast.patterns.PPattern;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
 import org.overture.interpreter.runtime.Context;
 import org.overture.interpreter.runtime.PatternMatchException;
+import org.overture.interpreter.utilities.pattern.AllNamedValuesLocator;
 import org.overture.interpreter.values.NameValuePairList;
 import org.overture.interpreter.values.Value;
 import org.overture.typechecker.assistant.pattern.PPatternAssistantTC;
@@ -46,7 +47,7 @@ public class PPatternAssistantInterpreter extends PPatternAssistantTC
 	public static int ANY = -1;
 
 	public static NameValuePairList getNamedValues(PPattern p, Value expval,
-			Context ctxt) throws PatternMatchException
+			Context ctxt) throws AnalysisException
 	{
 		List<AIdentifierPattern> ids = findIdentifiers(p);
 
@@ -84,108 +85,116 @@ public class PPatternAssistantInterpreter extends PPatternAssistantTC
 		{
 			return new Vector<AIdentifierPattern>(); // Most have none
 		}
-//		if (pattern instanceof AConcatenationPattern)
-//		{
-//			return AConcatenationPatternAssistantInterpreter.findIdentifiers((AConcatenationPattern) pattern);
-//		} else if (pattern instanceof AIdentifierPattern)
-//		{
-//			return AIdentifierPatternAssistantInterpreter.findIdentifiers((AIdentifierPattern) pattern);
-//		} else if (pattern instanceof AMapPattern)
-//		{
-//			return AMapPatternAssistantInterpreter.findIdentifiers((AMapPattern) pattern);
-//		} else if (pattern instanceof AMapUnionPattern)
-//		{
-//			return AMapUnionPatternAssistantInterpreter.findIdentifiers((AMapUnionPattern) pattern);
-//		} else if (pattern instanceof ARecordPattern)
-//		{
-//			return ARecordPatternAssistantInterpreter.findIndentifiers((ARecordPattern) pattern);
-//		} else if (pattern instanceof ASeqPattern)
-//		{
-//			return ASeqPatternAssistantInterpreter.findIdentifiers((ASeqPattern) pattern);
-//		} else if (pattern instanceof ASetPattern)
-//		{
-//			return ASetPatternAssistantInterpreter.findIdentifiers((ASetPattern) pattern);
-//		} else if (pattern instanceof ATuplePattern)
-//		{
-//			return ATuplePatternAssistantInterpreter.findIdentifiers((ATuplePattern) pattern);
-//		} else if (pattern instanceof AUnionPattern)
-//		{
-//			return AUnionPatternAssistantInterpreter.findIdentifiers((AUnionPattern) pattern);
-//		} else
-//		{
-//			return new Vector<AIdentifierPattern>(); // Most have none
-//		}
+		// if (pattern instanceof AConcatenationPattern)
+		// {
+		// return AConcatenationPatternAssistantInterpreter.findIdentifiers((AConcatenationPattern) pattern);
+		// } else if (pattern instanceof AIdentifierPattern)
+		// {
+		// return AIdentifierPatternAssistantInterpreter.findIdentifiers((AIdentifierPattern) pattern);
+		// } else if (pattern instanceof AMapPattern)
+		// {
+		// return AMapPatternAssistantInterpreter.findIdentifiers((AMapPattern) pattern);
+		// } else if (pattern instanceof AMapUnionPattern)
+		// {
+		// return AMapUnionPatternAssistantInterpreter.findIdentifiers((AMapUnionPattern) pattern);
+		// } else if (pattern instanceof ARecordPattern)
+		// {
+		// return ARecordPatternAssistantInterpreter.findIndentifiers((ARecordPattern) pattern);
+		// } else if (pattern instanceof ASeqPattern)
+		// {
+		// return ASeqPatternAssistantInterpreter.findIdentifiers((ASeqPattern) pattern);
+		// } else if (pattern instanceof ASetPattern)
+		// {
+		// return ASetPatternAssistantInterpreter.findIdentifiers((ASetPattern) pattern);
+		// } else if (pattern instanceof ATuplePattern)
+		// {
+		// return ATuplePatternAssistantInterpreter.findIdentifiers((ATuplePattern) pattern);
+		// } else if (pattern instanceof AUnionPattern)
+		// {
+		// return AUnionPatternAssistantInterpreter.findIdentifiers((AUnionPattern) pattern);
+		// } else
+		// {
+		// return new Vector<AIdentifierPattern>(); // Most have none
+		// }
 	}
 
 	public static List<NameValuePairList> getAllNamedValues(PPattern pattern,
-			Value expval, Context ctxt) throws PatternMatchException
+			Value expval, Context ctxt) throws AnalysisException
 	{
+
 //		try
 //		{
-//			return pattern.apply(af.getAllNamedValuesLocator(), new AllNamedValuesLocator.Newquestion(expval, ctxt));
+			return pattern.apply(af.getAllNamedValuesLocator(), new AllNamedValuesLocator.Newquestion(expval, ctxt));
 //		} catch (AnalysisException e) //DONE
 //		{
-//			return null;
+//			if (e instanceof PatternMatchException)
+//				throw (PatternMatchException) e;
+//			else
+//			{
+//				return null; // should never happen
+//			}
 //		}
-		if (pattern instanceof ABooleanPattern)
-		{
-			return ABooleanPatternAssistantInterpreter.getAllNamedValues((ABooleanPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ACharacterPattern)
-		{
-			return ACharacterPatternAssistantInterpreter.getAllNamedValues((ACharacterPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AConcatenationPattern)
-		{
-			return AConcatenationPatternAssistantInterpreter.getAllNamedValues((AConcatenationPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AExpressionPattern)
-		{
-			return AExpressionPatternAssistantInterpreter.getAllNamedValues((AExpressionPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AIdentifierPattern)
-		{
-			return AIdentifierPatternAssistantInterpreter.getAllNamedValues((AIdentifierPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AIgnorePattern)
-		{
-			return AIgnorePatternAssistantInterpreter.getAllNamedValues((AIgnorePattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AIntegerPattern)
-		{
-			return AIntegerPatternAssistantInterpreter.getAllNamedValues((AIntegerPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AMapPattern)
-		{
-			return AMapPatternAssistantInterpreter.getAllNamedValues((AMapPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AMapUnionPattern)
-		{
-			return AMapUnionPatternAssistantInterpreter.getAllNamedValues((AMapUnionPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ANilPattern)
-		{
-			return ANilPatternAssistantInterpreter.getAllNamedValues((ANilPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AQuotePattern)
-		{
-			return AQuotePatternAssistantInterpreter.getAllNamedValues((AQuotePattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ARealPattern)
-		{
-			return ARealPatternAssistantInterpreter.getAllNamedValues((ARealPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ARecordPattern)
-		{
-			return ARecordPatternAssistantInterpreter.getAllNamedValues((ARecordPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ASeqPattern)
-		{
-			return ASeqPatternAssistantInterpreter.getAllNamedValues((ASeqPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ASetPattern)
-		{
-			return ASetPatternAssistantInterpreter.getAllNamedValues((ASetPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AStringPattern)
-		{
-			return AStringPatternAssistantInterpreter.getAllNamedValues((AStringPattern) pattern, expval, ctxt);
-		} else if (pattern instanceof ATuplePattern)
-		{
-			return ATuplePatternAssistantInterpreter.getAllNamedValues((ATuplePattern) pattern, expval, ctxt);
-		} else if (pattern instanceof AUnionPattern)
-		{
-			return AUnionPatternAssistantInterpreter.getAllNamedValues((AUnionPattern) pattern, expval, ctxt);
-		} else
-		{
-			assert false : "Should not happen!";
-			return null;
-		}
+
+		// if (pattern instanceof ABooleanPattern)
+		// {
+		// return ABooleanPatternAssistantInterpreter.getAllNamedValues((ABooleanPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ACharacterPattern)
+		// {
+		// return ACharacterPatternAssistantInterpreter.getAllNamedValues((ACharacterPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AConcatenationPattern)
+		// {
+		// return AConcatenationPatternAssistantInterpreter.getAllNamedValues((AConcatenationPattern) pattern, expval,
+		// ctxt);
+		// } else if (pattern instanceof AExpressionPattern)
+		// {
+		// return AExpressionPatternAssistantInterpreter.getAllNamedValues((AExpressionPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AIdentifierPattern)
+		// {
+		// return AIdentifierPatternAssistantInterpreter.getAllNamedValues((AIdentifierPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AIgnorePattern)
+		// {
+		// return AIgnorePatternAssistantInterpreter.getAllNamedValues((AIgnorePattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AIntegerPattern)
+		// {
+		// return AIntegerPatternAssistantInterpreter.getAllNamedValues((AIntegerPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AMapPattern)
+		// {
+		// return AMapPatternAssistantInterpreter.getAllNamedValues((AMapPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AMapUnionPattern)
+		// {
+		// return AMapUnionPatternAssistantInterpreter.getAllNamedValues((AMapUnionPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ANilPattern)
+		// {
+		// return ANilPatternAssistantInterpreter.getAllNamedValues((ANilPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AQuotePattern)
+		// {
+		// return AQuotePatternAssistantInterpreter.getAllNamedValues((AQuotePattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ARealPattern)
+		// {
+		// return ARealPatternAssistantInterpreter.getAllNamedValues((ARealPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ARecordPattern)
+		// {
+		// return ARecordPatternAssistantInterpreter.getAllNamedValues((ARecordPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ASeqPattern)
+		// {
+		// return ASeqPatternAssistantInterpreter.getAllNamedValues((ASeqPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ASetPattern)
+		// {
+		// return ASetPatternAssistantInterpreter.getAllNamedValues((ASetPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AStringPattern)
+		// {
+		// return AStringPatternAssistantInterpreter.getAllNamedValues((AStringPattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof ATuplePattern)
+		// {
+		// return ATuplePatternAssistantInterpreter.getAllNamedValues((ATuplePattern) pattern, expval, ctxt);
+		// } else if (pattern instanceof AUnionPattern)
+		// {
+		// return AUnionPatternAssistantInterpreter.getAllNamedValues((AUnionPattern) pattern, expval, ctxt);
+		// } else
+		// {
+		// assert false : "Should not happen!";
+		// return null;
+		// }
 	}
 
 	/**
@@ -199,39 +208,39 @@ public class PPatternAssistantInterpreter extends PPatternAssistantTC
 			return pattern.apply(af.getLengthFinder());// FIXME: should we handle exceptions like this
 		} catch (AnalysisException e) //DONE
 		{
-			return 1; //Most only identify one member
+			return 1; // Most only identify one member
 		}
-//		if (pattern instanceof AConcatenationPattern)
-//		{
-//			return AConcatenationPatternAssistantInterpreter.getLength((AConcatenationPattern) pattern);
-//		} else if (pattern instanceof AIdentifierPattern)
-//		{
-//			return AIdentifierPatternAssistantInterpreter.getLength((AIdentifierPattern) pattern);
-//		} else if (pattern instanceof AIgnorePattern)
-//		{
-//			return AIgnorePatternAssistantInterpreter.getLength((AIgnorePattern) pattern);
-//		} else if (pattern instanceof AMapPattern)
-//		{
-//			return AMapPatternAssistantInterpreter.getLength((AMapPattern) pattern);
-//		} else if (pattern instanceof AMapUnionPattern)
-//		{
-//			return AMapUnionPatternAssistantInterpreter.getLength((AMapUnionPattern) pattern);
-//		} else if (pattern instanceof ASeqPattern)
-//		{
-//			return ASeqPatternAssistantInterpreter.getLength((ASeqPattern) pattern);
-//		} else if (pattern instanceof ASetPattern)
-//		{
-//			return ASetPatternAssistantInterpreter.getLength((ASetPattern) pattern);
-//		} else if (pattern instanceof AStringPattern)
-//		{
-//			return AStringPatternAssistantInterpreter.getLength((AStringPattern) pattern);
-//		} else if (pattern instanceof AUnionPattern)
-//		{
-//			return AUnionPatternAssistantInterpreter.getLength((AUnionPattern) pattern);
-//		} else
-//		{
-//			return 1; // Most only identify one member
-//		}
+		// if (pattern instanceof AConcatenationPattern)
+		// {
+		// return AConcatenationPatternAssistantInterpreter.getLength((AConcatenationPattern) pattern);
+		// } else if (pattern instanceof AIdentifierPattern)
+		// {
+		// return AIdentifierPatternAssistantInterpreter.getLength((AIdentifierPattern) pattern);
+		// } else if (pattern instanceof AIgnorePattern)
+		// {
+		// return AIgnorePatternAssistantInterpreter.getLength((AIgnorePattern) pattern);
+		// } else if (pattern instanceof AMapPattern)
+		// {
+		// return AMapPatternAssistantInterpreter.getLength((AMapPattern) pattern);
+		// } else if (pattern instanceof AMapUnionPattern)
+		// {
+		// return AMapUnionPatternAssistantInterpreter.getLength((AMapUnionPattern) pattern);
+		// } else if (pattern instanceof ASeqPattern)
+		// {
+		// return ASeqPatternAssistantInterpreter.getLength((ASeqPattern) pattern);
+		// } else if (pattern instanceof ASetPattern)
+		// {
+		// return ASetPatternAssistantInterpreter.getLength((ASetPattern) pattern);
+		// } else if (pattern instanceof AStringPattern)
+		// {
+		// return AStringPatternAssistantInterpreter.getLength((AStringPattern) pattern);
+		// } else if (pattern instanceof AUnionPattern)
+		// {
+		// return AUnionPatternAssistantInterpreter.getLength((AUnionPattern) pattern);
+		// } else
+		// {
+		// return 1; // Most only identify one member
+		// }
 	}
 
 	/**
@@ -247,39 +256,39 @@ public class PPatternAssistantInterpreter extends PPatternAssistantTC
 		{
 			return true;
 		}
-//		if (pattern instanceof AConcatenationPattern)
-//		{
-//			return AConcatenationPatternAssistantInterpreter.isConstrained((AConcatenationPattern) pattern);
-//		} else if (pattern instanceof AIdentifierPattern)
-//		{
-//			return AIdentifierPatternAssistantInterpreter.isConstrained((AIdentifierPattern) pattern);
-//		} else if (pattern instanceof AIgnorePattern)
-//		{
-//			return AIgnorePatternAssistantInterpreter.isConstrained((AIgnorePattern) pattern);
-//		} else if (pattern instanceof AMapPattern)
-//		{
-//			return AMapPatternAssistantInterpreter.isConstrained((AMapPattern) pattern);
-//		} else if (pattern instanceof AMapUnionPattern)
-//		{
-//			return AMapUnionPatternAssistantInterpreter.isConstrained((AMapUnionPattern) pattern);
-//		} else if (pattern instanceof ARecordPattern)
-//		{
-//			return ARecordPatternAssistantInterpreter.isConstrained((ARecordPattern) pattern);
-//		} else if (pattern instanceof ASeqPattern)
-//		{
-//			return ASeqPatternAssistantInterpreter.isConstrained((ASeqPattern) pattern);
-//		} else if (pattern instanceof ASetPattern)
-//		{
-//			return ASetPatternAssistantInterpreter.isConstrained((ASetPattern) pattern);
-//		} else if (pattern instanceof ATuplePattern)
-//		{
-//			return ATuplePatternAssistantInterpreter.isConstrained((ATuplePattern) pattern);
-//		} else if (pattern instanceof AUnionPattern)
-//		{
-//			return AUnionPatternAssistantInterpreter.isConstrained((AUnionPattern) pattern);
-//		} else
-//		{
-//			return true;
-//		}
+		// if (pattern instanceof AConcatenationPattern)
+		// {
+		// return AConcatenationPatternAssistantInterpreter.isConstrained((AConcatenationPattern) pattern);
+		// } else if (pattern instanceof AIdentifierPattern)
+		// {
+		// return AIdentifierPatternAssistantInterpreter.isConstrained((AIdentifierPattern) pattern);
+		// } else if (pattern instanceof AIgnorePattern)
+		// {
+		// return AIgnorePatternAssistantInterpreter.isConstrained((AIgnorePattern) pattern);
+		// } else if (pattern instanceof AMapPattern)
+		// {
+		// return AMapPatternAssistantInterpreter.isConstrained((AMapPattern) pattern);
+		// } else if (pattern instanceof AMapUnionPattern)
+		// {
+		// return AMapUnionPatternAssistantInterpreter.isConstrained((AMapUnionPattern) pattern);
+		// } else if (pattern instanceof ARecordPattern)
+		// {
+		// return ARecordPatternAssistantInterpreter.isConstrained((ARecordPattern) pattern);
+		// } else if (pattern instanceof ASeqPattern)
+		// {
+		// return ASeqPatternAssistantInterpreter.isConstrained((ASeqPattern) pattern);
+		// } else if (pattern instanceof ASetPattern)
+		// {
+		// return ASetPatternAssistantInterpreter.isConstrained((ASetPattern) pattern);
+		// } else if (pattern instanceof ATuplePattern)
+		// {
+		// return ATuplePatternAssistantInterpreter.isConstrained((ATuplePattern) pattern);
+		// } else if (pattern instanceof AUnionPattern)
+		// {
+		// return AUnionPatternAssistantInterpreter.isConstrained((AUnionPattern) pattern);
+		// } else
+		// {
+		// return true;
+		// }
 	}
 }
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AInMapMapTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AInMapMapTypeAssistantInterpreter.java
index fc2a4e7..89bbc58 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AInMapMapTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AInMapMapTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AInMapMapType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
 import org.overture.interpreter.runtime.Context;
@@ -19,7 +20,7 @@ public class AInMapMapTypeAssistantInterpreter
 	}
 
 	public static ValueList getAllValues(AInMapMapType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList maps = SMapTypeAssistantInterpreter.getAllValues(type, ctxt);
 		ValueList result = new ValueList();
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ANamedInvariantTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ANamedInvariantTypeAssistantInterpreter.java
index 8a9e349..c5ae278 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ANamedInvariantTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ANamedInvariantTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.type.ANamedInvariantTypeAssistant;
 import org.overture.ast.types.ANamedInvariantType;
 import org.overture.config.Settings;
@@ -24,7 +25,7 @@ public class ANamedInvariantTypeAssistantInterpreter extends ANamedInvariantType
 	}
 
 	public static ValueList getAllValues(ANamedInvariantType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList raw = PTypeAssistantInterpreter.getAllValues(type.getType(), ctxt);
 		boolean checks = Settings.invchecks;
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AOptionalTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AOptionalTypeAssistantInterpreter.java
index b781fc2..568e283 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AOptionalTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AOptionalTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.type.AOptionalTypeAssistant;
 import org.overture.ast.types.AOptionalType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
@@ -20,7 +21,7 @@ public class AOptionalTypeAssistantInterpreter extends AOptionalTypeAssistant
 	}
 
 	public static ValueList getAllValues(AOptionalType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList list = PTypeAssistantInterpreter.getAllValues(type.getType(), ctxt);
 		list.add(new NilValue());
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AParameterTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AParameterTypeAssistantInterpreter.java
index 915d0af..95bb9d0 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AParameterTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AParameterTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.type.AParameterTypeAssistant;
 import org.overture.ast.types.AParameterType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
@@ -21,7 +22,7 @@ public class AParameterTypeAssistantInterpreter extends AParameterTypeAssistant
 	}
 
 	public static ValueList getAllValues(AParameterType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		Value t = ctxt.lookup(type.getName());
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AProductTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AProductTypeAssistantInterpreter.java
index fc436b6..1e5b88b 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AProductTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AProductTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AProductType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
 import org.overture.interpreter.runtime.Context;
@@ -17,7 +18,7 @@ public class AProductTypeAssistantInterpreter
 	}
 
 	public static ValueList getAllValues(AProductType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		return PTypeListAssistant.getAllValues(type.getTypes(), ctxt);
 	}
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ARecordInvariantTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ARecordInvariantTypeAssistantInterpreter.java
index e0ecbf3..af80ded 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ARecordInvariantTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ARecordInvariantTypeAssistantInterpreter.java
@@ -3,6 +3,7 @@ package org.overture.interpreter.assistant.type;
 import java.util.List;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AFieldField;
 import org.overture.ast.types.ARecordInvariantType;
 import org.overture.ast.types.PType;
@@ -29,7 +30,7 @@ public class ARecordInvariantTypeAssistantInterpreter extends
 	}
 
 	public static ValueList getAllValues(ARecordInvariantType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		List<PType> types = new Vector<PType>();
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ASetTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ASetTypeAssistantInterpreter.java
index 41ea69f..9f42bac 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ASetTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/ASetTypeAssistantInterpreter.java
@@ -2,6 +2,7 @@ package org.overture.interpreter.assistant.type;
 
 import java.util.List;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ASetType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
 import org.overture.interpreter.runtime.Context;
@@ -21,7 +22,7 @@ public class ASetTypeAssistantInterpreter
 	}
 
 	public static ValueList getAllValues(ASetType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList list = PTypeAssistantInterpreter.getAllValues(type.getSetof(), ctxt);
 		ValueSet set = new ValueSet(list.size());
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AUnionTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AUnionTypeAssistantInterpreter.java
index 0bbfb0e..d86268e 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AUnionTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/AUnionTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AUnionType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
@@ -20,7 +21,7 @@ public class AUnionTypeAssistantInterpreter extends AUnionTypeAssistantTC
 	}
 
 	public static ValueList getAllValues(AUnionType utype, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList v = new ValueList();
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeAssistantInterpreter.java
index a2d537f..2e8bb1d 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AInMapMapType;
 import org.overture.ast.types.AMapMapType;
 import org.overture.ast.types.AOptionalType;
@@ -30,7 +31,7 @@ public class PTypeAssistantInterpreter extends PTypeAssistantTC
 	}
 
 	public static ValueList getAllValues(PType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		if (type instanceof SBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeListAssistant.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeListAssistant.java
index 1a0138f..ac1d61c 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeListAssistant.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/PTypeListAssistant.java
@@ -2,6 +2,7 @@ package org.overture.interpreter.assistant.type;
 
 import java.util.List;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.factory.AstFactory;
 import org.overture.ast.lex.LexNameToken;
 import org.overture.ast.patterns.PPattern;
@@ -27,7 +28,7 @@ public class PTypeListAssistant
 	}
 
 	public static ValueList getAllValues(List<PType> linkedList, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		QuantifierList quantifiers = new QuantifierList();
 		int n = 0;
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SInvariantTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SInvariantTypeAssistantInterpreter.java
index b92966c..2db5acd 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SInvariantTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SInvariantTypeAssistantInterpreter.java
@@ -1,5 +1,6 @@
 package org.overture.interpreter.assistant.type;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.definitions.AExplicitFunctionDefinition;
 import org.overture.ast.types.ANamedInvariantType;
 import org.overture.ast.types.ARecordInvariantType;
@@ -41,7 +42,7 @@ public class SInvariantTypeAssistantInterpreter
 	}
 
 	public static ValueList getAllValues(SInvariantType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		if (type instanceof ANamedInvariantType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SMapTypeAssistantInterpreter.java b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SMapTypeAssistantInterpreter.java
index cee2088..fa5da1b 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SMapTypeAssistantInterpreter.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/assistant/type/SMapTypeAssistantInterpreter.java
@@ -2,6 +2,7 @@ package org.overture.interpreter.assistant.type;
 
 import java.util.List;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.pattern.PTypeList;
 import org.overture.ast.types.SMapType;
 import org.overture.interpreter.assistant.IInterpreterAssistantFactory;
@@ -25,7 +26,7 @@ public class SMapTypeAssistantInterpreter
 	}
 
 	public static ValueList getAllValues(SMapType type, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		PTypeList tuple = new PTypeList();
 		tuple.add(type.getFrom());
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/utilities/pattern/AllNamedValuesLocator.java b/core/interpreter/src/main/java/org/overture/interpreter/utilities/pattern/AllNamedValuesLocator.java
index b947195..6edcc6b 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/utilities/pattern/AllNamedValuesLocator.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/utilities/pattern/AllNamedValuesLocator.java
@@ -1,6 +1,10 @@
 package org.overture.interpreter.utilities.pattern;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.ListIterator;
+import java.util.Vector;
+import java.util.Map.Entry;
 
 import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.analysis.QuestionAnswerAdaptor;
@@ -14,6 +18,7 @@ import org.overture.ast.patterns.AIgnorePattern;
 import org.overture.ast.patterns.AIntegerPattern;
 import org.overture.ast.patterns.AMapPattern;
 import org.overture.ast.patterns.AMapUnionPattern;
+import org.overture.ast.patterns.AMapletPatternMaplet;
 import org.overture.ast.patterns.ANilPattern;
 import org.overture.ast.patterns.AQuotePattern;
 import org.overture.ast.patterns.ARealPattern;
@@ -33,6 +38,7 @@ import org.overture.interpreter.assistant.pattern.AIdentifierPatternAssistantInt
 import org.overture.interpreter.assistant.pattern.AIgnorePatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.AIntegerPatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.AMapPatternAssistantInterpreter;
+import org.overture.interpreter.assistant.pattern.AMapPatternMapletAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.AMapUnionPatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.ANilPatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.AQuotePatternAssistantInterpreter;
@@ -43,9 +49,28 @@ import org.overture.interpreter.assistant.pattern.ASetPatternAssistantInterprete
 import org.overture.interpreter.assistant.pattern.AStringPatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.ATuplePatternAssistantInterpreter;
 import org.overture.interpreter.assistant.pattern.AUnionPatternAssistantInterpreter;
+import org.overture.interpreter.assistant.pattern.PPatternAssistantInterpreter;
 import org.overture.interpreter.runtime.Context;
+import org.overture.interpreter.runtime.PatternMatchException;
+import org.overture.interpreter.runtime.ValueException;
+import org.overture.interpreter.runtime.VdmRuntime;
+import org.overture.interpreter.runtime.VdmRuntimeError;
+import org.overture.interpreter.traces.Permutor;
+import org.overture.interpreter.values.FieldMap;
+import org.overture.interpreter.values.FieldValue;
+import org.overture.interpreter.values.MapValue;
+import org.overture.interpreter.values.NameValuePair;
 import org.overture.interpreter.values.NameValuePairList;
+import org.overture.interpreter.values.NameValuePairMap;
+import org.overture.interpreter.values.NilValue;
+import org.overture.interpreter.values.RecordValue;
+import org.overture.interpreter.values.SeqValue;
+import org.overture.interpreter.values.SetValue;
 import org.overture.interpreter.values.Value;
+import org.overture.interpreter.values.ValueList;
+import org.overture.interpreter.values.ValueMap;
+import org.overture.interpreter.values.ValueSet;
+import org.overture.typechecker.TypeComparator;
 
 public class AllNamedValuesLocator 
 	extends QuestionAnswerAdaptor<AllNamedValuesLocator.Newquestion, List<NameValuePairList>>
@@ -69,11 +94,82 @@ public class AllNamedValuesLocator
 		this.af = af;
 	}
 	
+//	} else if (pattern instanceof ACharacterPattern)
+//	{
+//		return ACharacterPatternAssistantInterpreter.getAllNamedValues((ACharacterPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AConcatenationPattern)
+//	{
+//		return AConcatenationPatternAssistantInterpreter.getAllNamedValues((AConcatenationPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AExpressionPattern)
+//	{
+//		return AExpressionPatternAssistantInterpreter.getAllNamedValues((AExpressionPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AIdentifierPattern)
+//	{
+//		return AIdentifierPatternAssistantInterpreter.getAllNamedValues((AIdentifierPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AIgnorePattern)
+//	{
+//		return AIgnorePatternAssistantInterpreter.getAllNamedValues((AIgnorePattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AIntegerPattern)
+//	{
+//		return AIntegerPatternAssistantInterpreter.getAllNamedValues((AIntegerPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AMapPattern)
+//	{
+//		return AMapPatternAssistantInterpreter.getAllNamedValues((AMapPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AMapUnionPattern)
+//	{
+//		return AMapUnionPatternAssistantInterpreter.getAllNamedValues((AMapUnionPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ANilPattern)
+//	{
+//		return ANilPatternAssistantInterpreter.getAllNamedValues((ANilPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AQuotePattern)
+//	{
+//		return AQuotePatternAssistantInterpreter.getAllNamedValues((AQuotePattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ARealPattern)
+//	{
+//		return ARealPatternAssistantInterpreter.getAllNamedValues((ARealPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ARecordPattern)
+//	{
+//		return ARecordPatternAssistantInterpreter.getAllNamedValues((ARecordPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ASeqPattern)
+//	{
+//		return ASeqPatternAssistantInterpreter.getAllNamedValues((ASeqPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ASetPattern)
+//	{
+//		return ASetPatternAssistantInterpreter.getAllNamedValues((ASetPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AStringPattern)
+//	{
+//		return AStringPatternAssistantInterpreter.getAllNamedValues((AStringPattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof ATuplePattern)
+//	{
+//		return ATuplePatternAssistantInterpreter.getAllNamedValues((ATuplePattern) pattern, expval, ctxt);
+//	} else if (pattern instanceof AUnionPattern)
+//	{
+//		return AUnionPatternAssistantInterpreter.getAllNamedValues((AUnionPattern) pattern, expval, ctxt);
+//	} else
+//	{
+//		assert false : "Should not happen!";
+//		return null;
+//	}
 	@Override
 	public List<NameValuePairList> caseABooleanPattern(ABooleanPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ABooleanPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ABooleanPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (question.expval.boolValue(question.ctxt) != pattern.getValue().getValue())
+			{
+				VdmRuntimeError.patternFail(4106, "Boolean pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 
 	@Override
@@ -81,7 +177,22 @@ public class AllNamedValuesLocator
 			ACharacterPattern pattern, Newquestion question)
 			throws AnalysisException
 	{
-		return ACharacterPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ACharacterPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (question.expval.charValue(question.ctxt) != pattern.getValue().getValue())
+			{
+				VdmRuntimeError.patternFail(4107, "Character pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
@@ -89,7 +200,169 @@ public class AllNamedValuesLocator
 			AConcatenationPattern pattern, Newquestion question)
 			throws AnalysisException
 	{
-		return AConcatenationPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AConcatenationPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueList values = null;
+
+		try
+		{
+			values = question.expval.seqValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		int llen = PPatternAssistantInterpreter.getLength(pattern.getLeft());
+		int rlen = PPatternAssistantInterpreter.getLength(pattern.getRight());
+		int size = values.size();
+
+		if (llen == PPatternAssistantInterpreter.ANY && rlen > size
+				|| rlen == PPatternAssistantInterpreter.ANY && llen > size
+				|| rlen != PPatternAssistantInterpreter.ANY
+				&& llen != PPatternAssistantInterpreter.ANY
+				&& size != llen + rlen)
+		{
+			VdmRuntimeError.patternFail(4108, "Sequence concatenation pattern does not match expression", pattern.getLocation());
+		}
+
+		// If the left and right sizes are ANY (ie. flexible) then we have to
+		// generate a set of splits of the values, and offer these to sub-matches
+		// to see whether they fit. Otherwise, there is just one split at this level.
+
+		List<Integer> leftSizes = new Vector<Integer>();
+
+		if (llen == PPatternAssistantInterpreter.ANY)
+		{
+			if (rlen == PPatternAssistantInterpreter.ANY)
+			{
+				if (size == 0)
+				{
+					// Can't match a ^ b with []
+				} else if (size % 2 == 1)
+				{
+					// Odd => add the middle, then those either side
+					int half = size / 2 + 1;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(0);
+				} else
+				{
+					// Even => add those either side of the middle
+					int half = size / 2;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(size);
+					leftSizes.add(0);
+				}
+			} else
+			{
+				leftSizes.add(size - rlen);
+			}
+		} else
+		{
+			leftSizes.add(llen);
+		}
+
+		// Now loop through the various splits and attempt to match the l/r
+		// sub-patterns to the split sequence value.
+
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		for (Integer lsize : leftSizes)
+		{
+			Iterator<Value> iter = values.iterator();
+			ValueList head = new ValueList();
+
+			for (int i = 0; i < lsize; i++)
+			{
+				head.add(iter.next());
+			}
+
+			ValueList tail = new ValueList();
+
+			while (iter.hasNext()) // Everything else in second
+			{
+				tail.add(iter.next());
+			}
+
+			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+			int psize = 2;
+			int[] counts = new int[psize];
+
+			try
+			{
+				List<NameValuePairList> lnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getLeft(), new SeqValue(head), question.ctxt);
+				nvplists.add(lnvps);
+				counts[0] = lnvps.size();
+
+				List<NameValuePairList> rnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getRight(), new SeqValue(tail), question.ctxt);
+				nvplists.add(rnvps);
+				counts[1] = rnvps.size();
+			} catch (PatternMatchException e)
+			{
+				continue;
+			}
+
+			Permutor permutor = new Permutor(counts);
+
+			while (permutor.hasNext())
+			{
+				try
+				{
+					NameValuePairMap results = new NameValuePairMap();
+					int[] selection = permutor.next();
+
+					for (int p = 0; p < psize; p++)
+					{
+						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+						{
+							Value v = results.get(nvp.name);
+
+							if (v == null)
+							{
+								results.put(nvp);
+							} else
+							// Names match, so values must also
+							{
+								if (!v.equals(nvp.value))
+								{
+									VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
+								}
+							}
+						}
+					}
+
+					finalResults.add(results.asList()); // Consistent set of nvps
+				} catch (PatternMatchException pme)
+				{
+					// try next perm
+				}
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4109, "Values do not match concatenation pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
@@ -97,7 +370,26 @@ public class AllNamedValuesLocator
 			AExpressionPattern pattern, Newquestion question)
 			throws AnalysisException
 	{
-		return AExpressionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AExpressionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (!question.expval.equals(pattern.getExp().apply(VdmRuntime.getExpressionEvaluator(), question.ctxt)))
+			{
+				VdmRuntimeError.patternFail(4110, "Expression pattern match failed", pattern.getLocation());
+			}
+		} catch (AnalysisException e)//DONE
+		{
+			if (e instanceof PatternMatchException)
+			{
+				throw (PatternMatchException) e;
+			}
+			e.printStackTrace();
+		}
+
+		result.add(new NameValuePairList());
+		return result; // NB no values for a match, as there's no definition
 	}
 	
 	@Override
@@ -105,97 +397,984 @@ public class AllNamedValuesLocator
 			AIdentifierPattern pattern, Newquestion question)
 			throws AnalysisException
 	{
-		return AIdentifierPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AIdentifierPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+		NameValuePairList list = new NameValuePairList();
+		list.add(new NameValuePair(pattern.getName(), question.expval));
+		result.add(list);
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAIgnorePattern(AIgnorePattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AIgnorePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AIgnorePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAIntegerPattern(AIntegerPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AIntegerPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AIntegerPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (question.expval.intValue(question.ctxt) != pattern.getValue().getValue())
+			{
+				VdmRuntimeError.patternFail(4111, "Integer pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAMapPattern(AMapPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AMapPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AMapPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueMap values = null;
+
+		try
+		{
+			values = question.expval.mapValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		if (values.size() != pattern.getMaplets().size())
+		{
+			VdmRuntimeError.patternFail(4152, "Wrong number of elements for map pattern", pattern.getLocation());
+		}
+
+		// Since the member patterns may indicate specific map members, we
+		// have to permute through the various map orderings to see
+		// whether there are any which match both sides. If the members
+		// are not constrained however, the initial ordering will be
+		// fine.
+
+		List<ValueMap> allMaps;
+
+		if (AMapPatternAssistantInterpreter.isConstrained(pattern))
+		{
+			allMaps = values.permutedMaps();
+		} else
+		{
+			allMaps = new Vector<ValueMap>();
+			allMaps.add(values);
+		}
+
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+		int psize = pattern.getMaplets().size();
+
+		if (pattern.getMaplets().isEmpty())
+		{
+			finalResults.add(new NameValuePairList());
+			return finalResults;
+		}
+
+		for (ValueMap mapPerm : allMaps)
+		{
+			Iterator<Entry<Value, Value>> iter = mapPerm.entrySet().iterator();
+
+			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+			int[] counts = new int[psize];
+			int i = 0;
+
+			try
+			{
+				for (AMapletPatternMaplet p : pattern.getMaplets())
+				{
+					List<NameValuePairList> pnvps = AMapPatternMapletAssistantInterpreter.getAllNamedValues(p, iter.next(), question.ctxt);
+					nvplists.add(pnvps);
+					counts[i++] = pnvps.size();
+				}
+			} catch (Exception e)
+			{
+				continue;
+			}
+
+			Permutor permutor = new Permutor(counts);
+
+			while (permutor.hasNext())
+			{
+				try
+				{
+					NameValuePairMap results = new NameValuePairMap();
+					int[] selection = permutor.next();
+
+					for (int p = 0; p < psize; p++)
+					{
+						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+						{
+							Value v = results.get(nvp.name);
+
+							if (v == null)
+							{
+								results.put(nvp);
+							} else
+							// Names match, so values must also
+							{
+								if (!v.equals(nvp.value))
+								{
+									VdmRuntimeError.patternFail(4153, "Values do not match map pattern", pattern.getLocation());
+								}
+							}
+						}
+					}
+
+					finalResults.add(results.asList());
+				} catch (PatternMatchException pme)
+				{
+					// Try next perm then...
+				}
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4154, "Cannot match map pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAMapUnionPattern(AMapUnionPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AMapUnionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AMapUnionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueMap values = null;
+
+		try
+		{
+			values = question.expval.mapValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		int llen = PPatternAssistantInterpreter.getLength(pattern.getLeft());
+		int rlen = PPatternAssistantInterpreter.getLength(pattern.getRight());
+		int size = values.size();
+
+		if (llen == PPatternAssistantInterpreter.ANY && rlen > size
+				|| rlen == PPatternAssistantInterpreter.ANY && llen > size
+				|| rlen != PPatternAssistantInterpreter.ANY
+				&& llen != PPatternAssistantInterpreter.ANY
+				&& size != llen + rlen)
+		{
+			VdmRuntimeError.patternFail(4155, "Map union pattern does not match expression", pattern.getLocation());
+		}
+
+		// If the left and right sizes are zero (ie. flexible) then we have to
+		// generate a set of splits of the values, and offer these to sub-matches
+		// to see whether they fit. Otherwise, there is just one split at this level.
+
+		List<Integer> leftSizes = new Vector<Integer>();
+
+		if (llen == PPatternAssistantInterpreter.ANY)
+		{
+			if (rlen == PPatternAssistantInterpreter.ANY)
+			{
+				if (size == 0)
+				{
+					// Can't match a munion b with {|->}
+				} else if (size % 2 == 1)
+				{
+					// Odd => add the middle, then those either side
+					int half = size / 2 + 1;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(0);
+				} else
+				{
+					// Even => add those either side of the middle
+					int half = size / 2;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(size);
+					leftSizes.add(0);
+				}
+			} else
+			{
+				leftSizes.add(size - rlen);
+			}
+		} else
+		{
+			leftSizes.add(llen);
+		}
+
+		// Since the left and right may have specific element members, we
+		// have to permute through the various map orderings to see
+		// whether there are any which match both sides. If the patterns
+		// are not constrained however, the initial ordering will be
+		// fine.
+
+		List<ValueMap> allMaps;
+
+		if (AMapUnionPatternAssistantInterpreter.isConstrained(pattern))
+		{
+			allMaps = values.permutedMaps();
+		} else
+		{
+			allMaps = new Vector<ValueMap>();
+			allMaps.add(values);
+		}
+
+		// Now loop through the various splits and attempt to match the l/r
+		// sub-patterns to the split map value.
+
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		for (Integer lsize : leftSizes)
+		{
+			for (ValueMap setPerm : allMaps)
+			{
+				Iterator<Entry<Value, Value>> iter = setPerm.entrySet().iterator();
+				ValueMap first = new ValueMap();
+
+				for (int i = 0; i < lsize; i++)
+				{
+					Entry<Value, Value> e = iter.next();
+					first.put(e.getKey(), e.getValue());
+				}
+
+				ValueMap second = new ValueMap();
+
+				while (iter.hasNext()) // Everything else in second
+				{
+					Entry<Value, Value> e = iter.next();
+					second.put(e.getKey(), e.getValue());
+				}
+
+				List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+				int psize = 2;
+				int[] counts = new int[psize];
+
+				try
+				{
+					List<NameValuePairList> lnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getLeft(), new MapValue(first), question.ctxt);
+					nvplists.add(lnvps);
+					counts[0] = lnvps.size();
+
+					List<NameValuePairList> rnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getRight(), new MapValue(second), question.ctxt);
+					nvplists.add(rnvps);
+					counts[1] = rnvps.size();
+				} catch (Exception e)
+				{
+					continue;
+				}
+
+				Permutor permutor = new Permutor(counts);
+
+				while (permutor.hasNext())
+				{
+					try
+					{
+						NameValuePairMap results = new NameValuePairMap();
+						int[] selection = permutor.next();
+
+						for (int p = 0; p < psize; p++)
+						{
+							for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+							{
+								Value v = results.get(nvp.name);
+
+								if (v == null)
+								{
+									results.put(nvp);
+								} else
+								// Names match, so values must also
+								{
+									if (!v.equals(nvp.value))
+									{
+										VdmRuntimeError.patternFail(4126, "Values do not match union pattern", pattern.getLocation());
+									}
+								}
+							}
+						}
+
+						finalResults.add(results.asList());
+					} catch (PatternMatchException pme)
+					{
+						// Try next perm then...
+					}
+				}
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4156, "Cannot match map pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseANilPattern(ANilPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ANilPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ANilPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		if (!(question.expval.deref() instanceof NilValue))
+		{
+			VdmRuntimeError.patternFail(4106, "Nil pattern match failed", pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAQuotePattern(AQuotePattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AQuotePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AQuotePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (!question.expval.quoteValue(question.ctxt).equals(pattern.getValue().getValue()))
+			{
+				VdmRuntimeError.patternFail(4112, "Quote pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseARealPattern(ARealPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ARealPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ARealPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (question.expval.realValue(question.ctxt) != pattern.getValue().getValue())
+			{
+				VdmRuntimeError.patternFail(4113, "Real pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseARecordPattern(ARecordPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ARecordPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ARecordPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		FieldMap fields = null;
+		RecordValue exprec = null;
+
+		try
+		{
+			exprec = question.expval.recordValue(question.ctxt);
+			fields = exprec.fieldmap;
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		// if (!type.equals(exprec.type))
+		if (!TypeComparator.compatible(pattern.getType(), exprec.type))
+		{
+			VdmRuntimeError.patternFail(4114, "Record type does not match pattern", pattern.getLocation());
+		}
+
+		if (fields.size() != pattern.getPlist().size())
+		{
+			VdmRuntimeError.patternFail(4115, "Record expression does not match pattern", pattern.getLocation());
+		}
+
+		Iterator<FieldValue> iter = fields.iterator();
+		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+		int psize = pattern.getPlist().size();
+		int[] counts = new int[psize];
+		int i = 0;
+
+		for (PPattern p : pattern.getPlist())
+		{
+			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next().value, question.ctxt);
+			nvplists.add(pnvps);
+			counts[i++] = pnvps.size();
+		}
+
+		Permutor permutor = new Permutor(counts);
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		if (pattern.getPlist().isEmpty())
+		{
+			finalResults.add(new NameValuePairList());
+			return finalResults;
+		}
+
+		while (permutor.hasNext())
+		{
+			try
+			{
+				NameValuePairMap results = new NameValuePairMap();
+				int[] selection = permutor.next();
+
+				for (int p = 0; p < psize; p++)
+				{
+					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+					{
+						Value v = results.get(nvp.name);
+
+						if (v == null)
+						{
+							results.put(nvp);
+						} else
+						// Names match, so values must also
+						{
+							if (!v.equals(nvp.value))
+							{
+								VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
+							}
+						}
+					}
+				}
+
+				finalResults.add(results.asList()); // Consistent set of nvps
+			} catch (PatternMatchException pme)
+			{
+				// try next perm
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4116, "Values do not match record pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseASeqPattern(ASeqPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ASeqPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ASeqPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueList values = null;
+
+		try
+		{
+			values = question.expval.seqValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		if (values.size() != pattern.getPlist().size())
+		{
+			VdmRuntimeError.patternFail(4117, "Wrong number of elements for sequence pattern", pattern.getLocation());
+		}
+
+		ListIterator<Value> iter = values.listIterator();
+		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+		int psize = pattern.getPlist().size();
+		int[] counts = new int[psize];
+		int i = 0;
+
+		for (PPattern p : pattern.getPlist())
+		{
+			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), question.ctxt);
+			nvplists.add(pnvps);
+			counts[i++] = pnvps.size();
+		}
+
+		Permutor permutor = new Permutor(counts);
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		if (pattern.getPlist().isEmpty())
+		{
+			finalResults.add(new NameValuePairList());
+			return finalResults;
+		}
+
+		while (permutor.hasNext())
+		{
+			try
+			{
+				NameValuePairMap results = new NameValuePairMap();
+				int[] selection = permutor.next();
+
+				for (int p = 0; p < psize; p++)
+				{
+					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+					{
+						Value v = results.get(nvp.name);
+
+						if (v == null)
+						{
+							results.put(nvp);
+						} else
+						// Names match, so values must also
+						{
+							if (!v.equals(nvp.value))
+							{
+								VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
+							}
+						}
+					}
+				}
+
+				finalResults.add(results.asList()); // Consistent set of nvps
+			} catch (PatternMatchException pme)
+			{
+				// try next perm
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4118, "Values do not match sequence pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseASetPattern(ASetPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ASetPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ASetPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueSet values = null;
+
+		try
+		{
+			values = question.expval.setValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		if (values.size() != pattern.getPlist().size())
+		{
+			VdmRuntimeError.patternFail(4119, "Wrong number of elements for set pattern", pattern.getLocation());
+		}
+
+		// Since the member patterns may indicate specific set members, we
+		// have to permute through the various set orderings to see
+		// whether there are any which match both sides. If the members
+		// are not constrained however, the initial ordering will be
+		// fine.
+
+		List<ValueSet> allSets;
+
+		if (ASetPatternAssistantInterpreter.isConstrained(pattern))
+		{
+			allSets = values.permutedSets();
+		} else
+		{
+			allSets = new Vector<ValueSet>();
+			allSets.add(values);
+		}
+
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+		int psize = pattern.getPlist().size();
+
+		if (pattern.getPlist().isEmpty())
+		{
+			finalResults.add(new NameValuePairList());
+			return finalResults;
+		}
+
+		for (ValueSet setPerm : allSets)
+		{
+			Iterator<Value> iter = setPerm.iterator();
+
+			List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+			int[] counts = new int[psize];
+			int i = 0;
+
+			try
+			{
+				for (PPattern p : pattern.getPlist())
+				{
+					List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), question.ctxt);
+					nvplists.add(pnvps);
+					counts[i++] = pnvps.size();
+				}
+			} catch (Exception e)
+			{
+				continue;
+			}
+
+			Permutor permutor = new Permutor(counts);
+
+			while (permutor.hasNext())
+			{
+				try
+				{
+					NameValuePairMap results = new NameValuePairMap();
+					int[] selection = permutor.next();
+
+					for (int p = 0; p < psize; p++)
+					{
+						for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+						{
+							Value v = results.get(nvp.name);
+
+							if (v == null)
+							{
+								results.put(nvp);
+							} else
+							// Names match, so values must also
+							{
+								if (!v.equals(nvp.value))
+								{
+									VdmRuntimeError.patternFail(4120, "Values do not match set pattern", pattern.getLocation());
+								}
+							}
+						}
+					}
+
+					finalResults.add(results.asList());
+				} catch (PatternMatchException pme)
+				{
+					// Try next perm then...
+				}
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4121, "Cannot match set pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAStringPattern(AStringPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AStringPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AStringPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		List<NameValuePairList> result = new Vector<NameValuePairList>();
+
+		try
+		{
+			if (!question.expval.stringValue(question.ctxt).equals(pattern.getValue().getValue()))
+			{
+				VdmRuntimeError.patternFail(4122, "String pattern match failed", pattern.getLocation());
+			}
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		result.add(new NameValuePairList());
+		return result;
 	}
 	@Override
 	public List<NameValuePairList> caseATuplePattern(ATuplePattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return ATuplePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return ATuplePatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueList values = null;
+
+		try
+		{
+			values = question.expval.tupleValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		if (values.size() != pattern.getPlist().size())
+		{
+			VdmRuntimeError.patternFail(4123, "Tuple expression does not match pattern", pattern.getLocation());
+		}
+
+		ListIterator<Value> iter = values.listIterator();
+		List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+		int psize = pattern.getPlist().size();
+		int[] counts = new int[psize];
+		int i = 0;
+
+		for (PPattern p : pattern.getPlist())
+		{
+			List<NameValuePairList> pnvps = PPatternAssistantInterpreter.getAllNamedValues(p, iter.next(), question.ctxt);
+			
+			nvplists.add(pnvps);
+			counts[i++] = pnvps.size();
+		}
+
+		Permutor permutor = new Permutor(counts);
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		while (permutor.hasNext())
+		{
+			try
+			{
+				NameValuePairMap results = new NameValuePairMap();
+				int[] selection = permutor.next();
+
+				for (int p = 0; p < psize; p++)
+				{
+					for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+					{
+						Value v = results.get(nvp.name);
+
+						if (v == null)
+						{
+							results.put(nvp);
+						} else
+						// Names match, so values must also
+						{
+							if (!v.equals(nvp.value))
+							{
+								VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
+							}
+						}
+					}
+				}
+
+				finalResults.add(results.asList()); // Consistent set of nvps
+			} catch (PatternMatchException pme)
+			{
+				// try next perm
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4124, "Values do not match tuple pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
 	public List<NameValuePairList> caseAUnionPattern(AUnionPattern pattern,
 			Newquestion question) throws AnalysisException
 	{
-		return AUnionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		//return AUnionPatternAssistantInterpreter.getAllNamedValues(pattern, question.expval, question.ctxt);
+		ValueSet values = null;
+
+		try
+		{
+			values = question.expval.setValue(question.ctxt);
+		} catch (ValueException e)
+		{
+			VdmRuntimeError.patternFail(e, pattern.getLocation());
+		}
+
+		int llen = PPatternAssistantInterpreter.getLength(pattern.getLeft());
+		int rlen = PPatternAssistantInterpreter.getLength(pattern.getRight());
+		int size = values.size();
+
+		if (llen == PPatternAssistantInterpreter.ANY && rlen > size
+				|| rlen == PPatternAssistantInterpreter.ANY && llen > size
+				|| rlen != PPatternAssistantInterpreter.ANY
+				&& llen != PPatternAssistantInterpreter.ANY
+				&& size != llen + rlen)
+		{
+			VdmRuntimeError.patternFail(4125, "Set union pattern does not match expression", pattern.getLocation());
+		}
+
+		// If the left and right sizes are zero (ie. flexible) then we have to
+		// generate a set of splits of the values, and offer these to sub-matches
+		// to see whether they fit. Otherwise, there is just one split at this level.
+
+		List<Integer> leftSizes = new Vector<Integer>();
+
+		if (llen == PPatternAssistantInterpreter.ANY)
+		{
+			if (rlen == PPatternAssistantInterpreter.ANY)
+			{
+				if (size == 0)
+				{
+					// Can't match a union b with {}
+				} else if (size % 2 == 1)
+				{
+					// Odd => add the middle, then those either side
+					int half = size / 2 + 1;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(0);
+				} else
+				{
+					// Even => add those either side of the middle
+					int half = size / 2;
+					if (half > 0)
+					{
+						leftSizes.add(half);
+					}
+
+					for (int delta = 1; half - delta > 0; delta++)
+					{
+						leftSizes.add(half + delta);
+						leftSizes.add(half - delta);
+					}
+
+					leftSizes.add(size);
+					leftSizes.add(0);
+				}
+			} else
+			{
+				leftSizes.add(size - rlen);
+			}
+		} else
+		{
+			leftSizes.add(llen);
+		}
+
+		// Since the left and right may have specific set members, we
+		// have to permute through the various set orderings to see
+		// whether there are any which match both sides. If the patterns
+		// are not constrained however, the initial ordering will be
+		// fine.
+
+		List<ValueSet> allSets;
+
+		if (AUnionPatternAssistantInterpreter.isConstrained(pattern))
+		{
+			allSets = values.permutedSets();
+		} else
+		{
+			allSets = new Vector<ValueSet>();
+			allSets.add(values);
+		}
+
+		// Now loop through the various splits and attempt to match the l/r
+		// sub-patterns to the split set value.
+
+		List<NameValuePairList> finalResults = new Vector<NameValuePairList>();
+
+		for (Integer lsize : leftSizes)
+		{
+			for (ValueSet setPerm : allSets)
+			{
+				Iterator<Value> iter = setPerm.iterator();
+				ValueSet first = new ValueSet();
+
+				for (int i = 0; i < lsize; i++)
+				{
+					first.add(iter.next());
+				}
+
+				ValueSet second = new ValueSet();
+
+				while (iter.hasNext()) // Everything else in second
+				{
+					second.add(iter.next());
+				}
+
+				List<List<NameValuePairList>> nvplists = new Vector<List<NameValuePairList>>();
+				int psize = 2;
+				int[] counts = new int[psize];
+
+				try
+				{
+					List<NameValuePairList> lnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getLeft(), new SetValue(first), question.ctxt);
+					nvplists.add(lnvps);
+					counts[0] = lnvps.size();
+
+					List<NameValuePairList> rnvps = PPatternAssistantInterpreter.getAllNamedValues(pattern.getRight(), new SetValue(second), question.ctxt);
+					nvplists.add(rnvps);
+					counts[1] = rnvps.size();
+				} catch (Exception e)
+				{
+					continue;
+				}
+
+				Permutor permutor = new Permutor(counts);
+
+				while (permutor.hasNext())
+				{
+					try
+					{
+						NameValuePairMap results = new NameValuePairMap();
+						int[] selection = permutor.next();
+
+						for (int p = 0; p < psize; p++)
+						{
+							for (NameValuePair nvp : nvplists.get(p).get(selection[p]))
+							{
+								Value v = results.get(nvp.name);
+
+								if (v == null)
+								{
+									results.put(nvp);
+								} else
+								// Names match, so values must also
+								{
+									if (!v.equals(nvp.value))
+									{
+										VdmRuntimeError.patternFail(4126, "Values do not match union pattern", pattern.getLocation());
+									}
+								}
+							}
+						}
+
+						finalResults.add(results.asList());
+					} catch (PatternMatchException pme)
+					{
+						// Try next perm then...
+					}
+				}
+			}
+		}
+
+		if (finalResults.isEmpty())
+		{
+			VdmRuntimeError.patternFail(4127, "Cannot match set pattern", pattern.getLocation());
+		}
+
+		return finalResults;
 	}
 	
 	@Override
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/BooleanValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/BooleanValue.java
index 8142933..0b86712 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/BooleanValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/BooleanValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ABooleanBasicType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -81,7 +82,7 @@ public class BooleanValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to,ABooleanBasicType.class))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/CharacterValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/CharacterValue.java
index ec281b3..63419a3 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/CharacterValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/CharacterValue.java
@@ -26,6 +26,7 @@ package org.overture.interpreter.values;
 import java.util.FormattableFlags;
 import java.util.Formatter;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ACharBasicType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -108,7 +109,7 @@ public class CharacterValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to,ACharBasicType.class))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/ClassInvariantListener.java b/core/interpreter/src/main/java/org/overture/interpreter/values/ClassInvariantListener.java
index ca1cc14..c57aee3 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/ClassInvariantListener.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/ClassInvariantListener.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.io.Serializable;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.config.Settings;
 import org.overture.interpreter.runtime.Context;
@@ -43,7 +44,7 @@ public class ClassInvariantListener implements ValueListener, Serializable
 		this.invopvalue = invopvalue;
 	}
 
-	public void changedValue(ILexLocation location, Value value, Context ctxt)
+	public void changedValue(ILexLocation location, Value value, Context ctxt) throws AnalysisException
 	{
 		if (doInvariantChecks && Settings.invchecks)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/CompFunctionValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/CompFunctionValue.java
index 4238375..cf47be8 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/CompFunctionValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/CompFunctionValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.factory.AstFactory;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.interpreter.runtime.Context;
@@ -54,7 +55,7 @@ public class CompFunctionValue extends FunctionValue
 
 	@Override
 	public Value eval(
-		ILexLocation from, ValueList argValues, Context ctxt) throws ValueException
+		ILexLocation from, ValueList argValues, Context ctxt) throws AnalysisException
 	{
 		ValueList f1arg = new ValueList();
 		f1arg.add(ff2.eval(from, argValues, ctxt));
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/FunctionValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/FunctionValue.java
index 483b711..2ce0c56 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/FunctionValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/FunctionValue.java
@@ -263,14 +263,14 @@ public class FunctionValue extends Value
 	}
 
 	public Value eval(ILexLocation from, Value arg, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		ValueList args = new ValueList(arg);
 		return eval(from, args, ctxt, null);
 	}
 
 	public Value eval(ILexLocation from, ValueList argValues, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		return eval(from, argValues, ctxt, null);
 	}
@@ -294,7 +294,7 @@ public class FunctionValue extends Value
 	}
 
 	public Value eval(ILexLocation from, ValueList argValues, Context ctxt,
-			Context sctxt) throws ValueException
+			Context sctxt) throws AnalysisException
 	{
 		if (uninstantiated)
 		{
@@ -700,7 +700,7 @@ public class FunctionValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to, AFunctionType.class))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/IntegerValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/IntegerValue.java
index 1b3ab4c..9c2d86d 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/IntegerValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/IntegerValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.messages.InternalException;
 import org.overture.ast.types.AIntNumericBasicType;
 import org.overture.ast.types.PType;
@@ -106,7 +107,7 @@ public class IntegerValue extends RationalValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof AIntNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValue.java
index f86b54c..39e703f 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ANamedInvariantType;
 import org.overture.ast.types.PType;
 import org.overture.config.Settings;
@@ -38,7 +39,7 @@ public class InvariantValue extends ReferenceValue
 	private FunctionValue invariant;
 
 	public InvariantValue(ANamedInvariantType type, Value value, Context ctxt)
-		throws ValueException
+		throws AnalysisException
 	{
 		super(value);
 		this.type = type;
@@ -47,7 +48,7 @@ public class InvariantValue extends ReferenceValue
 		checkInvariant(ctxt);
 	}
 
-	public void checkInvariant(Context ctxt) throws ValueException
+	public void checkInvariant(Context ctxt) throws AnalysisException
 	{
 		if (invariant != null && Settings.invchecks)
 		{
@@ -65,7 +66,7 @@ public class InvariantValue extends ReferenceValue
 				{
 					abort(4060, "Type invariant violated for " + type.getName(), ctxt);
 				}
-			}
+			} 
 			finally
 			{
 				ctxt.threadState.setAtomic(false);
@@ -82,7 +83,7 @@ public class InvariantValue extends ReferenceValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to.equals(type))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValueListener.java b/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValueListener.java
index 93a68b5..259c213 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValueListener.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/InvariantValueListener.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.io.Serializable;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.config.Settings;
 import org.overture.interpreter.runtime.Context;
@@ -52,7 +53,7 @@ public class InvariantValueListener implements ValueListener, Serializable
 		this.root = value;		// Always an updatable InvariantValue
 	}
 
-	public void changedValue(ILexLocation location, Value value, Context ctxt)
+	public void changedValue(ILexLocation location, Value value, Context ctxt) throws AnalysisException 
 	{
 		// InvariantValueListeners are created at every Value point (with
 		// an inv function) in a structure, but the simplest level is actually
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/IterFunctionValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/IterFunctionValue.java
index ef0cef4..7533b1e 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/IterFunctionValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/IterFunctionValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.interpreter.runtime.Context;
 import org.overture.interpreter.runtime.ValueException;
@@ -50,7 +51,7 @@ public class IterFunctionValue extends FunctionValue
 
 	@Override
 	public Value eval(
-		ILexLocation from, ValueList argValues, Context ctxt) throws ValueException
+		ILexLocation from, ValueList argValues, Context ctxt) throws AnalysisException
 	{
 		Value result = function.eval(from, argValues, ctxt);
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/MapValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/MapValue.java
index 62e0c5d..6e15f7c 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/MapValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/MapValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AInMapMapType;
 import org.overture.ast.types.PType;
 import org.overture.ast.types.SMapType;
@@ -127,7 +128,7 @@ public class MapValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof SMapType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalOneValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalOneValue.java
index a0a06a2..2a4bcad 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalOneValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalOneValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.messages.InternalException;
 import org.overture.ast.types.ANatOneNumericBasicType;
 import org.overture.ast.types.PType;
@@ -51,7 +52,7 @@ public class NaturalOneValue extends NaturalValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ANatOneNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalValue.java
index 621b434..a2599a3 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/NaturalValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.messages.InternalException;
 import org.overture.ast.types.ANatNumericBasicType;
 import org.overture.ast.types.PType;
@@ -51,7 +52,7 @@ public class NaturalValue extends IntegerValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ANatNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/NilValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/NilValue.java
index 5b5cbd5..edb5907 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/NilValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/NilValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AOptionalType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -64,7 +65,7 @@ public class NilValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		// Note, don't use isType, as this skips the OptionalType wrapper.
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/NumericValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/NumericValue.java
index 1a7ff68..efa0470 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/NumericValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/NumericValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AIntNumericBasicType;
 import org.overture.ast.types.ANatNumericBasicType;
 import org.overture.ast.types.ANatOneNumericBasicType;
@@ -98,7 +99,7 @@ public abstract class NumericValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ARealNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/ObjectValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/ObjectValue.java
index 71eca40..31db0ce 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/ObjectValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/ObjectValue.java
@@ -32,6 +32,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.assistant.pattern.PTypeList;
 import org.overture.ast.definitions.ASystemClassDefinition;
 import org.overture.ast.intf.lex.ILexNameToken;
@@ -357,7 +358,7 @@ public class ObjectValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		Value conv = convertToHierarchy(to);
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/OperationValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/OperationValue.java
index 92daca5..5d2cce7 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/OperationValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/OperationValue.java
@@ -256,7 +256,7 @@ public class OperationValue extends Value
 	}
 
 	public Value eval(ILexLocation from, ValueList argValues, Context ctxt)
-			throws ValueException
+			throws AnalysisException
 	{
 		// Note args cannot be Updateable, so we convert them here. This means
 		// that TransactionValues pass the local "new" value to the far end.
@@ -278,7 +278,7 @@ public class OperationValue extends Value
 	}
 
 	public Value localEval(ILexLocation from, ValueList argValues,
-			Context ctxt, boolean logreq) throws ValueException
+			Context ctxt, boolean logreq) throws AnalysisException
 	{
 		if (state != null && stateName == null)
 		{
@@ -336,7 +336,7 @@ public class OperationValue extends Value
 			} catch (PatternMatchException e)
 			{
 				abort(e.number, e, ctxt);
-			}
+			} 
 		}
 
 		if (self != null)
@@ -750,7 +750,7 @@ public class OperationValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to, AOperationType.class))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/Quantifier.java b/core/interpreter/src/main/java/org/overture/interpreter/values/Quantifier.java
index 3fe1572..a6ea3e5 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/Quantifier.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/Quantifier.java
@@ -26,6 +26,7 @@ package org.overture.interpreter.values;
 import java.util.List;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.patterns.PPattern;
 import org.overture.interpreter.assistant.pattern.PPatternAssistantInterpreter;
 import org.overture.interpreter.runtime.Context;
@@ -44,7 +45,7 @@ public class Quantifier
 		this.nvlist = new Vector<NameValuePairList>(values.size());
 	}
 
-	public int size(Context ctxt, boolean allPossibilities)
+	public int size(Context ctxt, boolean allPossibilities) throws AnalysisException
 	{
 		for (Value value : values)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/QuantifierList.java b/core/interpreter/src/main/java/org/overture/interpreter/values/QuantifierList.java
index 16edd33..4417520 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/QuantifierList.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/QuantifierList.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.interpreter.runtime.Context;
 import org.overture.interpreter.runtime.PatternMatchException;
 
@@ -39,7 +40,7 @@ public class QuantifierList extends Vector<Quantifier>
 	private NameValuePairList result = null;
 	private boolean done = false;
 
-	public void init(Context ctxt, boolean allPossibilities)
+	public void init(Context ctxt, boolean allPossibilities) throws AnalysisException
 	{
 		count = size();
 		size = new int[count];
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/QuoteValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/QuoteValue.java
index 99ddba4..cb7bc2d 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/QuoteValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/QuoteValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AQuoteType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -81,7 +82,7 @@ public class QuoteValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof AQuoteType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/RationalValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/RationalValue.java
index f95219c..f62d4ed 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/RationalValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/RationalValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ARationalNumericBasicType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -50,7 +51,7 @@ public class RationalValue extends RealValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ARationalNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/RealValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/RealValue.java
index b109a6d..6c7efaa 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/RealValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/RealValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ARealNumericBasicType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -134,7 +135,7 @@ public class RealValue extends NumericValue
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ARealNumericBasicType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/RecordValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/RecordValue.java
index 6e0bc8d..a4841b9 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/RecordValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/RecordValue.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.util.Iterator;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AFieldField;
 import org.overture.ast.types.ARecordInvariantType;
 import org.overture.ast.types.PType;
@@ -47,7 +48,7 @@ public class RecordValue extends Value
 
 	// mk_ expressions
 	public RecordValue(ARecordInvariantType type,	ValueList values, Context ctxt)
-		throws ValueException
+		throws AnalysisException
 	{
 		this.type = type;
 		this.fieldmap = new FieldMap();
@@ -71,7 +72,7 @@ public class RecordValue extends Value
 
 	// mu_ expressions
 	public RecordValue(ARecordInvariantType type,	FieldMap mapvalues, Context ctxt)
-		throws ValueException
+		throws AnalysisException
 	{
 		this.type = type;
 		this.fieldmap = new FieldMap();
@@ -123,7 +124,7 @@ public class RecordValue extends Value
 		}
 	}
 
-	public void checkInvariant(Context ctxt) throws ValueException
+	public void checkInvariant(Context ctxt) throws AnalysisException
 	{
 		if (invariant != null && Settings.invchecks)
 		{
@@ -298,7 +299,7 @@ public class RecordValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().equals(to, type))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/ReferenceValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/ReferenceValue.java
index a8b57af..fba9975 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/ReferenceValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/ReferenceValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
 import org.overture.interpreter.runtime.ValueException;
@@ -45,7 +46,7 @@ abstract public class ReferenceValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		return value.convertValueTo(to, ctxt);
 	}
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/SeqValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/SeqValue.java
index 823f01a..6faa6f5 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/SeqValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/SeqValue.java
@@ -26,6 +26,7 @@ package org.overture.interpreter.values;
 import java.util.FormattableFlags;
 import java.util.Formatter;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.lex.LexStringToken;
 import org.overture.ast.types.ASeq1SeqType;
 import org.overture.ast.types.PType;
@@ -165,7 +166,7 @@ public class SeqValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		// We can't use the isSeq method as it plucks out one sequence
 		// value from a union. We need to try all union members. So we
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/SetValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/SetValue.java
index cd0e6f1..5eb3786 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/SetValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/SetValue.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.util.List;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ASetType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -144,7 +145,7 @@ public class SetValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof ASetType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/State.java b/core/interpreter/src/main/java/org/overture/interpreter/values/State.java
index cb79ca3..da9f0ae 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/State.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/State.java
@@ -154,7 +154,11 @@ public class State implements ValueListener
     		catch (ValueException e)
     		{
     			throw new ContextException(e, location);
-    		}
+    		} catch (AnalysisException e)//DONE
+			{
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
 		}
 	}
 }
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/TokenValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/TokenValue.java
index da7feff..ce7eacb 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/TokenValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/TokenValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.ATokenBasicType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -75,7 +76,7 @@ public class TokenValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to,ATokenBasicType.class))
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/TransactionValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/TransactionValue.java
index 854dc34..682f4d6 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/TransactionValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/TransactionValue.java
@@ -27,6 +27,7 @@ import java.util.List;
 import java.util.ListIterator;
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.ast.lex.Dialect;
 import org.overture.ast.types.PType;
@@ -86,13 +87,13 @@ public class TransactionValue extends UpdatableValue
 	}
 
 	@Override
-	public synchronized Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public synchronized Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		return select().convertValueTo(to, ctxt).getUpdatable(listeners);
 	}
 
 	@Override
-	public void set(ILexLocation location, Value newval, Context ctxt)
+	public void set(ILexLocation location, Value newval, Context ctxt) throws AnalysisException
 	{
 		long current = BasicSchedulableThread.getThread(Thread.currentThread()).getId();
 
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/TupleValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/TupleValue.java
index 7af207b..daae65a 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/TupleValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/TupleValue.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.util.Iterator;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AProductType;
 import org.overture.ast.types.PType;
 import org.overture.ast.util.Utils;
@@ -144,7 +145,7 @@ public class TupleValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof AProductType)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/UpdatableValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/UpdatableValue.java
index a1004f0..3f5c6db 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/UpdatableValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/UpdatableValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.ast.lex.Dialect;
 import org.overture.ast.types.PType;
@@ -97,13 +98,13 @@ public class UpdatableValue extends ReferenceValue
 	}
 
 	@Override
-	public synchronized Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public synchronized Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		return value.convertValueTo(to, ctxt).getUpdatable(listeners);
 	}
 
 	@Override
-	public void set(ILexLocation location, Value newval, Context ctxt)
+	public void set(ILexLocation location, Value newval, Context ctxt) throws AnalysisException
 	{
 		// Anything with structure added to an UpdateableValue has to be
 		// updatable, otherwise you can "freeze" part of the substructure
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/Value.java b/core/interpreter/src/main/java/org/overture/interpreter/values/Value.java
index c73ba59..3be71ea 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/Value.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/Value.java
@@ -28,6 +28,7 @@ import java.util.Formattable;
 import java.util.FormattableFlags;
 import java.util.Formatter;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.ast.types.ABracketType;
 import org.overture.ast.types.ANamedInvariantType;
@@ -151,11 +152,10 @@ abstract public class Value implements Comparable<Value>, Serializable, Formatta
 	 * @param to The target type.
 	 * @param ctxt The context in which to make the conversion.
 	 * @return This value converted to the target type.
-	 *
-	 * @throws ValueException Cannot perform the type conversion.
+	 * @throws AnalysisException 
 	 */
 
-	public Value convertTo(PType to, Context ctxt) throws ValueException
+	public Value convertTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (Settings.dynamictypechecks)
 		{
@@ -183,7 +183,7 @@ abstract public class Value implements Comparable<Value>, Serializable, Formatta
 		}
 	}
 
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (to instanceof AUnionType)
 		{
@@ -258,9 +258,10 @@ abstract public class Value implements Comparable<Value>, Serializable, Formatta
 	 * @param newval The new value to set
 	 * @param ctxt The context used
 	 * @throws ValueException
+	 * @throws AnalysisException 
 	 */
 
-	public void set(ILexLocation location, Value newval, Context ctxt) throws ValueException
+	public void set(ILexLocation location, Value newval, Context ctxt) throws ValueException, AnalysisException
 	{
 		abort(4088, "Set not permitted for " + kind(), ctxt);
 	}
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListener.java b/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListener.java
index 5f512c8..6a997ff 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListener.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListener.java
@@ -23,11 +23,12 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.interpreter.runtime.Context;
 
 
 public interface ValueListener
 {
-	public void changedValue(ILexLocation location, Value value, Context ctxt);
+	public void changedValue(ILexLocation location, Value value, Context ctxt) throws AnalysisException;
 }
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListenerList.java b/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListenerList.java
index 65efe70..034f91c 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListenerList.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/ValueListenerList.java
@@ -25,6 +25,7 @@ package org.overture.interpreter.values;
 
 import java.util.Vector;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.intf.lex.ILexLocation;
 import org.overture.interpreter.runtime.Context;
 
@@ -38,7 +39,7 @@ public class ValueListenerList extends Vector<ValueListener>
 		add(listener);
 	}
 
-	public void changedValue(ILexLocation location, Value value, Context ctxt)
+	public void changedValue(ILexLocation location, Value value, Context ctxt) throws AnalysisException
 	{
 		for (ValueListener vl: this)
 		{
diff --git a/core/interpreter/src/main/java/org/overture/interpreter/values/VoidValue.java b/core/interpreter/src/main/java/org/overture/interpreter/values/VoidValue.java
index b90f366..5e97097 100644
--- a/core/interpreter/src/main/java/org/overture/interpreter/values/VoidValue.java
+++ b/core/interpreter/src/main/java/org/overture/interpreter/values/VoidValue.java
@@ -23,6 +23,7 @@
 
 package org.overture.interpreter.values;
 
+import org.overture.ast.analysis.AnalysisException;
 import org.overture.ast.types.AVoidType;
 import org.overture.ast.types.PType;
 import org.overture.interpreter.runtime.Context;
@@ -70,7 +71,7 @@ public class VoidValue extends Value
 	}
 
 	@Override
-	public Value convertValueTo(PType to, Context ctxt) throws ValueException
+	public Value convertValueTo(PType to, Context ctxt) throws AnalysisException
 	{
 		if (ctxt.assistantFactory.createPTypeAssistant().isType(to,AVoidType.class))
 		{
